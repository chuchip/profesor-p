[
{
	"uri": "http://ww2.profesor-p.com/4-angular/curso/",
	"title": "Curso de Angular 6",
	"tags": [],
	"description": "",
	"content": "En esta página iré poniendo las sucesivas entradas donde intentare dar un curso básico sobre Angular 6\nEn el curso se desarrollara una aplicación que usando peticiones RESTFUL, realizara una consulta mostrando un histórico de ventas. En la aplicación se usara Boostrap y se explicara como utilizar rultas.\nLa aplicación backend, en el servidor, esta hecho en Java, usando Spring Framework, y se puede ver en su desarrollo en la pagina: http://www.profesor-p.com/aplicacion-usando-java-y-angular/\nEstas son las entradas creadas de momento:\n ¡¡Angular es reactivo!! Instalación y configuración básica de Angular Inicializando aplicación Manejando rutas  \u0026hellip; continuara\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/4-angular/aplicacion/",
	"title": "Aplicación usando Java y Angular",
	"tags": [],
	"description": "",
	"content": " A continuación detallo las entradas donde voy explicando, paso a paso, como crear un aplicación, que es una migración de una consulta realizada en el ERP Anjelica, el cual es software libre . Esta es la pantalla original de la aplicación en Anjelica.\nEsta aplicación es una consulta donde la parte del servidor se realiza en Java, usando Spring como Framework y la parte del cliente se realiza en Angular. La comunicación entre ambas partes se realiza con servicios REST, usando JSON.\nParte servidor  Primera parte Segunda parte Tercera parte Cuarta parte Quinta parte  Parte cliente  ¡¡Angular es reactivo!! Instalación y configuración básica de Angular Inicializando aplicación Manejando rutas  \u0026nbsp;\n\u0026#8230; continuaremos 😉\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/1-testing/",
	"title": "Testing",
	"tags": [],
	"description": "",
	"content": "Estos son los artículos disponibles sobre testing:\n Testeando las aplicaciones  En una próxima entrada hablare sobre como testear las aplicaciones con pruebas unitarias. Bueno, mostrare como lo hago en mi código.\nDe momento, viendo que alguien ya la ha hecho antes (y seguramente mejor) dejo este enlace como aperitivo.\n Uso de perfiles para testear en Spring Boot  Como comentaba en el articulo anterior gracias al uso de perfiles es fácil personalizar las aplicaciones en Spring Boot.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/11/28/generar-paginas-web-estaticas-dinamicamente/",
	"title": "Generar paginas Web estáticas dinámicamente",
	"tags": ["hugo", "web"],
	"description": "",
	"content": "Vamos a hablar de Hugo. Este un software permite crear sitios web estáticos pero trabajando casi como si fueran dinámicos. Para ello podremos usar diferentes plantillas que configuraremos, para luego añadir entradas y contenido dinámico fácilmente.\nHugo usa markdown para añadir los contenidos pero también podremos usar HTML, CSS y JavaScript si fuera necesario.\nPara crear una pagina web lo primero que tenemos que hacer es bajarnos el programa, lo cual podemos hacer desde https://github.com/gohugoio/hugo/releases Una vez tengamos instalado hugo en nuestro ordenador, podremos empezar a crear nuestra propia pagina web.\nComo primer paso abriremos un terminal y ejecutaremos la siguiente sentencia:\n \u0026gt; hugo new site mipagina  Con esto hugo creara un directorio llamado \u0026#8216;mipagina\u0026#8217; debajo del actual. Nos moveremos a el directorio para poder instalar el tema con el que queremos que funcione nuestra página web.\n\u0026gt; cd mipagina  En https://themes.gohugo.io/ tenemos todas los temas (o plantillas) sobre las que basar nuestra página web. Estos temas están en su mayoría alojados en GitHub por lo cual lo más fácil para descargarlos es usar el comando git . De todos modos, siempre tenemos la opción de descargar un fichero zip que después descomprimiremos en el directorio themes\nSupongamos que queremos usar el tema initio que es el que usamos en la página de RiojaTech Alliance . Para ello iremos a su URL https://themes.gohugo.io/hugo-initio/ y pulsaremos sobre el botón \u0026#8216;Download\u0026#8216;, lo cual nos llevara a GitHub, a la dirección https://github.com/miguelsimoni/hugo-initio. Allí descargaremos el fichero ZIP, dándole a l botón Download ZIP.\nDespués descomprimiremos el fichero ZIP dentro del directorio themes , de tal manera que la estructura de nuestros directorios será como la siguiente:\nSuele ser una buena idea copiar el contenido del directorio example-site dentro de nuestro directorio principal para tener una plantilla sobre la que empezar a trabajar.\n Probando nuestra pagina web  Ahora, para ver como va quedando nuestra página web, ejecutaremos este comando:\n\u0026gt; hugo -F serve  De está manera se lanzara un pequeño servidor web el cual escuchara en el puerto 1313 .\nEste servidor monitorizara los cambios en los ficheros de tal manera que si modificamos cualquier fichero, nuestra pagina web será recargada automáticamente.\nEn la dirección http://localhost:1313/ con nuestro navegador favorito podremos ver el resultado.\n Añadiendo contenido  Si queremos añadir una entrada en la pagina web usaremos este comando:\n\u0026gt; hugo new post/post0.md  Esto nos generara el fichero \u0026#8216;post0.md\u0026#8217; en el directorio content/post/\nEste fichero tendrá el siguiente contenido.\n--- title: \u0026quot;post0\u0026quot; # Nombre del post date: 2018-11-01T11:21:58+01:00 ## fecha actual. draft: true # Poner a false para que aparezca el evento ---  Debajo deberemos poner el contenido de nuestro articulo. Recordar que se puede usar el lenguaje markdown y también HTML.\nSi ponemos la etiqueta \u0026lt;!--more--\u0026gt;, si nuestra plantilla lo soporta, separaremos el sumario de nuestro articulo, del articulo completo en si.\n Configurando HUGO  El fichero principal de Hugo esta en el directorio raíz y se llama config.toml\nEn este fichero configuraremos el tema a usar , el titulo de nuestra pagina web y otra serie de parámetros. Estos parámetros pueden variar de un tema a otro aunque siempre suele haber unos cuantos en común.\nEsto es un extracto del fichero config.toml de la web www.lariojatech.org\nbaseURL = \u0026quot;http://lariojatech.org/\u0026quot; languageCode = \u0026quot;es-es\u0026quot; title = \u0026quot;La Rioja Tech Alliance\u0026quot; theme = \u0026quot;hugo-initio\u0026quot; publishDir = \u0026quot;docs\u0026quot; [params] name = \u0026quot;La Rioja Tech Alliance\u0026quot; description = \u0026quot;Los grupos de tecnología de La Rioja hacemos piña para promover la tecnología \u0026quot; favicon = \u0026quot;images/gt_favicon.png\u0026quot; DateForm = \u0026quot;2, January 2006\u0026quot; .....  Si queremos hacer algún cambio a la plantilla descargada deberemos cambiar los ficheros ubicados en themes/NOMBRE_PLANTILLA/layouts/partials . Ahí encontraremos una serie de ficheros donde se especifica el comportamiento de la plantilla.\nEn themes/NOMBRE_PLANTILLA/_default es probable que existan los ficheros list.html y single.html. En single.html se definirá como se deben presentar una pagina de tipo lista, es decir cuando se deben mostrar diferentes artículos juntos. En single.html se especifica como se debe presentar una pagina de un sola entrada.\n Generando pagina web con HTML estático  Para generar todos los ficheros que deberán ir en el servidor web, ejecutaremos el comando\n\u0026gt; hugo -F  Los ficheros, por defecto serán generados, en el directorio public . Ese comportamiento se puede cambiar añadiendo la directiva publishDir en el fichero config.toml\nEl flag \u0026#8220;\u0026#8221;-F\u0026#8221; es para obligar a Hugo a incluir los posts cuya fecha sea superior a la actual, pues por defecto no los incluye. Si no la pusiéramos todos los eventos futuros no aparecerían.\nY esto es todo, solo animaros a que utilizeis este fantastico programa con el que podreis crear paginas dinamicamente para alojarlas, por ejemplo, en GitHub. Gratuitamente por supuesto.\n"
},
{
	"uri": "http://ww2.profesor-p.com/1-java/kotlin/",
	"title": "Kotlin",
	"tags": [],
	"description": "",
	"content": "Articulos relacionados con el lenguaje de programación Kotlin:\n Kotlin vs Java  Ultimamente se habla mucho de Kotlin, que si Google lo ha marcado como lenguaje preferente en la IO 2017, que si es un lenguaje muy mega-guay para programar en Android, que si soluciona los problemas de Null Pointer Exception.\nEn esta entrada voy a dar mi opinión (sin que nadie me pague 😉 ) comparando ambos lenguajes y diciendo, en mi opinión si es tan guay Kotlin, o es mas humo e intereses comerciales.\n Aplicacion CRUD con REST en Kotlin y SpringBoot  Buenas chavales, En esta nueva entrada os enseñare como realizar un programa CRUD, que sirva peticiones REST, usando Spring Boot y como lenguaje de programación usar Kotlin. Creo que no hará falta aclarar que una aplicación CRUD es la típica aplicación que permite consultar, insertar, modificar y borrar los datos de una tabla. Vamos, lo que se suele ir llamando un mantenimiento de una tabla. Esta aplicación seria una variación del que explique en la entrada http://www.\n Aplicacion CRUD con REST en Kotlin y SpringBoot (2ª Parte)  Hola de nuevo, chicos. Continuo con la entrada http://www.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-con-springboot/ para ver como realizar las peticiones REST , con protocolo JSON que es el estándar de facto 😉 en Kotlin. Una vez que ya tenemos la lógica de acceso a nuestra base de datos, tenemos que hacer la parte Web. Pues, aunque os parezca increíble, esto se hace con una sola clase y ademas de muy pocas lineas. La clase en cuestión es ApiController.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/06/aplicacion-rest-en-javaee/",
	"title": "Aplicación CRUD usando REST en JavaEE",
	"tags": ["glassfish", "javaee", "json", "netbeans", "rest"],
	"description": "",
	"content": "Explicaré como hacer una aplicación CRUD, que sirva peticiones REST con el protocolo JSON, usando JavaEE y Glasfish como servidor de aplicaciones. En esta aplicación actualizaremos y consultaremos una pequeña tabla a través de diferentes peticiones REST.\nSi bien es cierto que JavaEE no soporta oficialmente JSON en sus especificaciones, la realidad es que es muy fácil el realizar una aplicación totalmente funcional y muy fácilmente con la libreria JACKSON.\nLo primero, aclarar que en https://github.com/chuchip/crudJavaEE teneis código fuente del que hablo en esta entrada. Y ahora, pongámonos manos a la obra.\nComo ya he dicho vamos a utilizar la libreria Jackson que viene incluida con JavaEE 8.0, por lo cual no necesitaremos incluir ninguna librería externa excepto las necesarias para acceder a la base de datos, a través de JPA. En este caso utilizaremos EclipseLink, por lo que deberemos incluir en nuestro fichero pom.xml las siguientes dependencias:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;org.eclipse.persistence.core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;org.eclipse.persistence.jpa.jpql\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javax.persistence\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.eclipse.persistence\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;org.eclipse.persistence.jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.7.3\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt;  También incluiremos las dependencias para las libreria LOMBOK y WEB.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;javax\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;javaee-web-api\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;8.0\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.16.22\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; Vale, ya tenemos nuestras librerias. Ahora empecemos con el programa.Primero voy a crear la clase donde definimos el punto de entrada de nuestras peticiones REST. Esto lo hacemos en la clase RestConfiguration.java\npackage profesorp.restexample.resource; import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application; @ApplicationPath(\"api\") public class RestConfiguration extends Application { } Como podéis ver es una clase supersencilla. Tan solo tenemos que crear una clase que herede de Application y añadir la etiqueta @ApplicationPath. Con esto ya especificaremos que todas las peticiones que vayan a la trayectoria (Path para los ingleses) api seran tratadas por el servlet de la librería JACKSON.\nAhora vamos a especificar los diferentes recursos dentro de esta trayectoria o camino. Esto lo haremos en la clase LocaleResource, la cual detallo a continuación:\n@Path(\"locale\") @Stateless public class LocaleResource { @Inject private LocaleController localeController; private Logger logger= Logger.getLogger(LocaleResource.class.getName());  ..... FUNCIONES .... } Y como decía, Jack El Destripador, vayamos por partes 😉\nLo primero es observar la etiqueta @Path(\u0026#8220;locale\u0026#8221;) que indicara la trayectoria a la que responderá esta clase. En este caso indicamos la trayectoria locale. Es decir, esta clase sera usada cuando vayamos a la URL: \u0026#8220;http://localhost:8080/restExample/api/locale\u0026#8221; . Aclarar que restExample es donde desplegaremos la aplicación en el servidor Glassfish .\nLa etiqueta @Stateless es usada para poder inyectar las dependencias correctamente (vosotros, de momento, hacerme caso y creer que es necesario. ¡¡ Un acto de fe!! 😉\nDentro de la clase, con la etiqueta @Inject inyectaremos la clase LocaleController, la cual utilizaremos para interactuar con la base de datos.\nAhora vamos a explicar, una a una las diferentes funciones de esta clase.\n  Funcion findAllLocales  @GET @Produces(MediaType.APPLICATION_JSON) public Response findAllLocales() { logger.log(Level.INFO, \"Buscando todas las locales\"); return Response.ok(localeController.findAll()).build(); } Ahora definimos nuestra primera función que nos devolverá todos los Locales (países) disponibles en nuestra base de datos. Como se ve, ponemos la etiqueta @GET para especificar que debe ser llamada solo en peticiones HTTP tipo GET, y después añadimos la etiqueta\n@Produces(MediaType.APPLICATION_JSON), para especificar que devuelve un resultado en formato JSON.\nDentro de la función ponemos usamos la clase javax.ws.rs.core.Response que a través de su metodo ok, al que debemos pasar el objeto que debe construir en formato JSON, cuando invoquemos a la función build. En este caso el objeto pasado a la función ok  es una colección de clases de tipo Locales. Es decir, le pasamos esto: Collection, al llamar a la función findAll de la clase LocaleController \nComo se puede ver en el pantallazo, usando el excelente programa postman, podemos ver el resultado de la llamada a esta función:\n  Función findLocale  @GET @Path(\"/{locale}\") @Produces(MediaType.APPLICATION_JSON) public Response findLocale(@PathParam(\"locale\") String locCodi) { Locales l= localeController.findById(locCodi); try { l.getNombre(); } catch (javax.persistence.EntityNotFoundException k) { return Response.status(Response.Status.NOT_FOUND).build(); } return Response.ok(l).build(); } Aquí devolveremos el registro que indicamos en el parámetro mandado. Utilizaremos una vez más la etiqueta @GET y despues añadiremos la etiqueta @Path(\u0026#8220;/{locale}\u0026#8221;) de tal manera que a esta función se le llamara cuando se haga una peticion HTTP tipo GET y que tenga un unico parametro\nEn la declaración de la función vemos la anotación @PathParam, con la cual indicamos que a la variable \u0026lt;em\u0026gt;locCodi\u0026lt;/em\u0026gt;, se le debe asignar el valor del parámetro \u0026#8220;locale\u0026#8221;, que anteriormente hemos especificado en la anotación @Path.\nLa función como tal no tiene muchos misterios. Llamamos a la funcion findByID para buscar en la base de datos el codigo mandado. En caso de que no exista, al intentar recoger el nombre, con la linea l.getNombre()se lanzara una excepción tipo EntityNotFoundException, en cuyo caso devolveremos una respuesta tipo NOT_FOUND. En caso contrario devolveremos el objeto tipo Locales devuelto.\nY por hoy ya vale\u0026#8230; otro dia continuare con las funciones que añaden, actualizan y borran los registros.\nHasta pronto !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/4-angular/aplicacion/backend/",
	"title": "Backend",
	"tags": [],
	"description": "",
	"content": "Aquí encontrareis los entradas describiendo como crear la parte backend de esta aplicación.\n Backend I  En Anjelica, el ERP desarrollado por mi hace unos años, hay un programa que saca un comparativo de ventas, entre dos años, mostrando mes a mes, los kilos, importes y ganancias. La idea es realizar esta misma consulta pero usando Spring con REST en el backend y como frontend usar Angular. Para ello se realizaran los siguientes pasos: Crear tablas y cargar datos de prueba en la base de datos.\n Backend (II)  En esta segunda parte voy a empezar a explicar como hacer la parte del servidor, usando, como dije en la primera parte de este articulo utilizare JAVA 8, apoyándome en el framework Spring, versión 5. Esta aplicación la he realizado con NetBeans 9, usando Tomcat 9 como servidor de aplicaciones. La podía haber realizado usando Spring Boot, lo que habría realizado más fácilmente y con menos configuración pero he querido hacerlo con Tomcat como ejercicio.\n Backend (III)  En esta entrada, continuare con la parte servidor, que ya comencé en el articulo anterior. Voy a desarrollar la parte donde se responden a las peticiones REST. Para el que no sepa que es eso de REST, podéis empezar leyendo este articulo de la wikipedia, pero os podeis quedar con la idea de que es como una petición web normal, solo que en vez de trabajar con paginas HTML enteras, se trabaja con intercambio de datos más o menos en crudo.\n Backend (IV)  Continuo con la serie de artículos explicando una aplicación donde la parte de servidor esta creada con Java, apoyándose en el framework Spring y la parte del cliente usara Angular. Para la comunicación entre la aplicación usare peticiones REST, por supuesto utilizando el protocolo JSON. En la anterior entrada empece a explicar como se desplegaría la aplicación y en que URLs se procesarían las diferentes peticiones. Ahora explicare como funcionan las diferentes peticiones.\n Backend (V)  En esta ultima parte de la parte servidor hablare de como se crean los objetos que en el anterior articulo se devolvían. Estos objetos eran del tipo _VentasAnoBean _y un ArrayList de _VentasSemanaBean. _Para conseguirlos se llamaban a sendas funciones en la clase YagesBussines, que eran las que construían esos objetos. Empezare describiendo la clase @Component public class YagesBussines { @Autowired CalendarioRepositorioService calendarioRepositorio; @Autowired HistVentasRepository histVentasRepository; @Autowired DataSource dataSource; @Autowired private JdbcOperations jdbc; @Bean public JdbcTemplate jdbcTemplate() { return new JdbcTemplate(dataSource); } .\n "
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/23/kotlin-vs-java/",
	"title": "Kotlin vs Java",
	"tags": ["java", "kotlin"],
	"description": "",
	"content": "Ultimamente se habla mucho de Kotlin, que si Google lo ha marcado como lenguaje preferente en la IO 2017, que si es un lenguaje muy mega-guay para programar en Android, que si soluciona los problemas de Null Pointer Exception.\nEn esta entrada voy a dar mi opinión (sin que nadie me pague 😉 ) comparando ambos lenguajes y diciendo, en mi opinión si es tan guay Kotlin, o es mas humo e intereses comerciales.\nEn primer lugar, decir que Kotlin es compatible con Java, es decir, utiliza la máquina virtual de Java y ademas es compatible con este, vamos que tu puedes tener tu programita en Kotlin y ejecutar código Java ya creado, con lo cual todas las librerias de Java funcionan en Kotlin. Ahora voy a enumerar las ventajas de Kotlin y ver si realmente son tan trascendentes.\n Kotlin soluciona el problema de los Null Pointer Exception.  A este tema se le ha dado mucha publicidad. En Kotlin, efectivamente, cuando defines una variable tienes que especificarle un valor y si no, marcar la variable como que va a aceptar nulos, Si la marcas como que acepta nulos, no te deja juntarla con otras variables que no han sido marcadas como posibles nulables (vamos, que pueden ser null ).Bueno, realmente si te deja, pero te obliga a marcar el resultado como posible null.\nEl problema es que al final, si usas librerias Java externas (como es lo normal), no tienes ningun control sobre si las funciones Java puras devuelven valores Null o no, con lo cual, lo mas probable es que tengas Null Pointers Exception como antes. Es decir, cuando solo uses Kotlin y todas las librerias externas sean Kotlin, pues igual a este tema le sacas algun provecho pero actualmente se queda cojo.\n Kotlin tiene expresiones lambda.  Vale, Java 8.0 (que ya tiene un tiempo) tambien lo tiene. Otro tema es que se utilize mas o menos, pero vamos que no es una ventaja sobre Java.\n Kotlin soporta variables genericas.  En Kotlin, cuando defines una variable no tienes porque especificar de que tipo es. O sea, puedes crear una variable tal que asi:\nvar s=\u0026quot;hola\u0026quot;  Esto esta muy guay y evita tener que andar poniendo el tipo de variable, pero\u0026#8230;. en Java 10, tambien lo tenemos disponible, usando, ademas, la misma sintaxis. (var n=1;). La unica diferencia es que en Kotlin, las lineas no tienen porque ir terminadas con el punto y coma.\n Extensiones a Funciones.  Kotlin, sobre todo programando en Android, tiene ciertas extensiones, por ejemplo la que hace que puedas acceder a las variables de tu entorno grafico directamente. Otra extension es que tu defines un POJO y no hace falta poner los setters y getters de siempre. Directamente Kotlin los crea por ti. Eso esta muy bien, pero\u0026#8230; en Java tenemos el proyecto Lombok que hace lo mismo, es decir crear al vuelo, las sentencias setters , getters y alguna otra cosa más (echarle un vistazo, esta fenomenal).\nBueno, por no extenderme demasiado, Kotlin es un gran lenguaje y tiene cosas muy chulas, como por ejemplo, el hecho de definir en las funciones valores por defecto, de tal manera que en una funcion puede estar definida algo asi como esto:\nfun multi(x:Int =0,y:Int=0) De tal manera que a esta funcion la podremos llamar con un parametro, con dos o con ninguno, con lo cual te evitas el crear 3 funciones como tendrias que crear en Java, y que una llame a otra (es decir, es un ahorro de código sin mas).\nMi opinión: Si vais a programar en Android, aprender Kotlin, la curva de aprendizaje es muy rapida y esta claro que Google le va a dar mucho soporte y añadirle más cosas que ayudaran. Es obvio que Android no quiere depender de Java (entre otras cosas por los problemas de licencias que esta teniendo con Oracle) y por eso, al final, Kotlin sera el lenguaje que mandara en Android.\nSi usais Java, pero programando, por ejemplo, servicios Web, yo no me molestaria demasiado en aprender Kotlin: las mejoras que te ofrece no son tan grandes y las que valen la pena, las tienes en las ultimas versiones de Java. Pero claro, esto es solo mi opinión 😉\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/1-java/",
	"title": "Java",
	"tags": [],
	"description": "",
	"content": "Este es un cajón de sastre con artículos sobre diferentes temas.\n Kotlin  Articulos relacionados con el lenguaje de programación Kotlin:\n Usando Lambdas  En esta breve entrada explicare como mejorar el ejemplo anterior, con el uso de lambdas.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/",
	"title": "Spring",
	"tags": [],
	"description": "",
	"content": "Artículos sobre temas básicos y algunos más avanzados\nAquí tienes un listado de los artículos disponibles:\n Testing  Estos son los artículos disponibles sobre testing:\n Seguridad  Aquí tienes un listado de entradas sobre seguridad en Spring:\n MVC  Aunque ya no se utiliza tanto aquí encontraras artículos sobre Spring MVC.\n Database  Entradas sobre como acceder a bases de datos, con JPA y JDBC\n Cloud  Entradas relacionas con el desarrollo de aplicaciones Spring en la nube.\n Webflow  Entradas sobre el paquete WebFlow de Spring. Actualmente esta en un poco en desuso pero ha sido ampliamente utilizado en entornos empresariales.\n Base  Explicaciones sobre el core de Spring\n Restful  Anotaciones sobre aplicaciones Restful en Spring\n Mensajería con Kafka y Spring Boot  Kafka es un programa de mensajería pensado para comunicaciones asíncronas. Básicamente la idea es que los clientes o consumidores se subscriben a un tipo de noticia o topic y cuando un emisor o broker manda un mensaje sobre ese topic Kafka lo distribuye a los consumidores suscritos.\n Instalar plugin Spring Boot en NetBeans  En esta entrada explicare como crear un aplicación con el framework Spring Boot, usando el IDE NetBeans 9.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/12/05/crear-pagina-web-gratuita-en-github/",
	"title": "Crear pagina web gratuita en GitHub",
	"tags": ["html", "web"],
	"description": "",
	"content": "En esta entrada explicare como crear una página web gratuita en GitHub\nEstas páginas deben ser estáticas pero no hay limitaciones de ancho de banda, numero de ficheros y por supuesto no meterán publicidad en vuestra pagina web. Ademas, utilizara https y podreis usar un dominio propio, si lo habeis comprado con anterioridad. Aclarar que un dominio se puede registrar por solo un euro al año 😉\nAdemás podéis usar Hugo como explicaba en una anterior entrada para hacer vuestro sitio web estático, más dinámico.\nEso sí, para usar GitHub debéis tener al menos ciertas nociones basicas de Git pues se utilizara esta herramienta para subir los ficheros que formaran la pagina web.\nLo primero es crear nuestro proyecto en GitHub, para lo cual deberemos estar registrados.\nTenéis muchos videos y manuales que explican como trabajar con GitHub, uno donde se explica incluso como crear una página web lo podreis ver en devCode.la\nPor si os sirve de ayuda he creado un proyecto en https://github.com/chuchip/web que genera la pagina web https://chuchip.github.io/web/\nAclarar que una vez tengamos creado nuestro proyecto, deberemos hacer al menos un push. Es decir subir a GitHub al menos un fichero.\nAhora, para especificar que queremos tener una pagina web para nuestro proyecto, iremos a \u0026#8220;Settings\u0026#8220;\ny bajaremos hasta que veamos la sección: GitHub Pages\nAhora eligiéremos el branch (es decir, la rama) donde estará nuestra pagina web. Para empezar simplemente usar el valor que aparece por defecto: master branch. El tema de \u0026#8216;ramas\u0026#8217; es ampliamente utilizado en GIT pero si solo queremos hacer una pagina web no necesitamos crear ninguna, por lo cual tendremos la rama \u0026#8216;master\u0026#8217; (que sera la única que exista)\nAhora deberemos elegir que tema vamos a utilizar para nuestra pagina web. Aunque tenemos la opción de no utilizarlo como explico más adelante, es obligatorio elegir un tema.\nTambien tenemos la opción de tener un dominio propio tipo www.midominio.com, el cual, logicamente, deberemos tener registrado previamente. Si no tenemos un dominio propio nuestra pagina web sera visible bajo el dominio: http://USUARIO.github.com/PROYECTO\nElegimos una de las formas de crear nuestra pagina web\n Utilizando un tema Sin tema para lo cual usaremos un fichero index.html.  * Trabajando con un tema Si elegimos usar un tema lo que se mostrara sera el fichero readme.md que tengamos en nuestro proyecto, maquetado según el tema elegido. En este fichero readme.md podremos usar el lenguaje de maquetado MarkDown con el que podremos poner imagenes, formatear nuestro texto con negritas, cursiva, etc, poner enlaces, etc.\nPara poner enlaces a las imagenes se podra usar el formato: ./IMAGEN_A_ENLAZAR\n* Pagina web estatica Si hemos creado un fichero index.html, este fichero se utilizara como página inicial de nuestra página web.\nTodas las referencias a imagenes queramos poner deberan ser con el formato:\nhttps://raw.githubusercontent.com/USUARIO/web/master/IMAGEN_A_MOSTRAR\nEs decir si el usuario es \u0026#8216;chuchip\u0026#8216; y el proyecto se llama \u0026#8216;web\u0026#8217;, todas las referencias a imagenes deberan ser con la URL:\nhttps://raw.githubusercontent.com/chuchip/web/master/\nPara las referencias a paginas web, CSS y ficheros javascript podremos usar el formato \u0026#8220;./PAGINA_XX.html\u0026#8221;\n* Notas Aclarar que si tenemos el fichero index.html no utilizara el tema ni se vera el fichero readme.md\nOtra cosa a tener en cuenta que a GitHub le cuesta un poco (menos de un minuto), refrescar la pagina web desde el ultimo push\nY con esto ya tendreis vuestra pagina web alojada gratuitamente.\n¡¡ Hasta otra!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/2-seguridad/",
	"title": "Seguridad",
	"tags": [],
	"description": "",
	"content": "Aquí tienes un listado de entradas sobre seguridad en Spring:\n Securizando servicios REST con Oauth2 en SpringBoot  En esta entrada explicare como podemos dotar de seguridad a servicios REST en Spring Boot. La aplicación de ejemplo es la misma que la entrada de seguridad WEB anterior, así que el código fuente lo tenéis en: https://github.com/chuchip/OAuthServer. Explicando la tecnologia Oauth2 Como he dicho, utilizaremos el protocolo OAuth2, así que lo primero sera explicar como funciona este protocolo. OAuth2 tiene algunas variantes pero yo os voy a explicar la que utilizare en el programa y, para ello, voy a poneros un ejemplo para que entendáis lo que pretendemos hacer.\n Seguridad WEB en Spring Boot  En esta entrada voy a explicar como gestiona Spring la seguridad. No todo, por supuesto, que el tema de la seguridad daría para un libro muy gordote, pero al menos aprender a securizar una pagina web. En una próxima entrada hablare de como securizar un servicio REST. Como siempre, comienzo diciendo que el código fuente de lo que explico lo tenéis en mi pagina de GITHUB, en https://github.com/chuchip/OAuthServer. El programa esta realizado en Java, usando Spring Boot.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/07/aplicacion-rest-en-javaee-2a-parte/",
	"title": "Aplicación CRUD usando REST en JavaEE  (II)",
	"tags": ["glassfish", "java", "javaee", "jpa", "rest"],
	"description": "",
	"content": "En esta ocasión continuo explicando la aplicación CRUD, utilizando peticiones REST, con JavaEE.\nRecordar que tenéis el código fuente en https://github.com/chuchip/crudJavaEE\nEn la anterior entrada, que podéis ver en en http://www.profesor-p.com/2018/10/06/aplicacion-rest-en-javaee/ habíamos visto como consultar los lenguajes disponibles. Ahora vamos a ver como añadir nuevos, modificarlos y borrarlos.\n Funcion create  @POST @Consumes(MediaType.APPLICATION_JSON) public Response create(Locales locale) { if ( localeController.exists(locale.getCodigo())) { return Response.status(Response.Status.CONFLICT).build(); } localeController.create(locale); URI location = UriBuilder.fromResource(LocaleResource.class) .path(\"/{locale}\") .resolveTemplate(\"locale\", locale.getCodigo()) .build(); return Response.created(location).build(); } Como podéis observar lo primero es especificar el tipo de petición HTTP que se va a aceptar, en este caso POST. Especificamos que queremos tratar solo peticiones tipo JSON y ya declaramos la función, que recibe un objeto tipo Locales\nDespués comprobamos si ese Locale no exista en la base de datos , devolviendo una respuesta tipo CONFLICT en caso de que ya exista.\nEn caso contrario, insertamos en la base de datos con la función create de la clase LocaleController, para despues devolver una respuesta tipo created (código 201) con la dirección donde se podría consultar el registro recién creado.\nY como siempre, una imagen mejor que cien palabras 😉\n)\nEn este pantallazo podéis ver como se hace la petición POST, mandando en el cuerpo el objeto JSON, donde se especifica el código y el nombre. La aplicación devuelve un 201 como estado y Location vemos que tenemos \u0026#8220;http://localhost:8080/restExample/api/locale/es-BO\u0026amp;#8221; que seria donde podemos consultar el registro recién creado.\n Funcion update  @PUT @Path(\"/{codigo}\") public Response update(@PathParam(\"locale\") String codigo, Locales locales) { if (!Objects.equals(codigo, locales.getCodigo())) { throw new BadRequestException(\"Propiedad 'codigo' de Objeto Locale debe coincidir con el parámetro mandado.\"); } localeController.update(locales); return Response.ok().build(); }  Con esta función se actualizara el registro mandado. Mirar como se solicita el código del país, ademas del objeto tipo locales . Esto es para comprobar que el objeto a modificar coincida con el código del país mandado. En caso contrario devolverá una excepción tipo BadRequestException la cual devolverá un código 400 (Bad Request).\nSi todo va bien, devolvemos un código 200 (OK).\nAquí tenéis un pantallazo actualizando el registro anteriormente insertado.\n Funcion delete   @DELETE @Path(\"/{codigo}\") public Response delete(@PathParam(\"codigo\") String codigo) { logger.log(Level.INFO, \"Borrando Locale: \"+codigo); if ( ! localeController.exists(codigo)) { return Response.status(Response.Status.NOT_FOUND).build(); } localeController.delete(codigo); return Response.ok().build(); } Esta función sera tratada cuando la petición HTTP sea del tipo DELETE ya que así esta especificado en la etiqueta @DELETE y deberá recibir un parámetro con el código del país a borrar. Si el país en cuestión no existe devolverá un código error tipo NOT_FOUND y si es borrado correctamente, un 200 (OK).\nY con esto ya tendremos nuestra maravillosa aplicación CRUD, a través de peticiones REST.\nLa lógica de acceso a la base de datos no es diferente a como se haría en Spring o con cualquier otro framework, así que si tenéis curiosidad de lo que hay detrás, podéis bajaros el código fuente de mi página de GitHub.\n¡¡ Hasta la próxima !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/4-angular/aplicacion/frontend/",
	"title": "Frontend",
	"tags": [],
	"description": "",
	"content": "Aquí encontrareis los entradas describiendo como crear la parte frontend de esta aplicación. Es decir lo creado en Angular\n Frontend en Angular  En anteriores entradas se creo la parte del servidor de nuestra aplicación . Para la parte cliente o frontend usaremos Angular 6. El código fuente del programa lo tenéis, como siempre, en mi página de GitHub. Lo primero sera instalar Angular, para ello tenemos un excelente manual de como hacerlo en la página web de Angular. Básicamente es instalar el servidor de aplicaciones Node.js. y su aplicación incluida npm (es un solo ejecutable) de https://nodejs.\n Angular - Inicializando  Continuando con la entrada donde instalaba Angular, seguimos desarrollando la aplicación que detallo en esta página. Una vez tenemos creado el esqueleto de nuestro programa, con el comando \u0026#8220;ng new\u0026#8221; , entraremos al directorio src. En este directorio es donde realmente vamos a trabajar. Los demás directorios son donde están las librerías y utilidades que nuestra aplicación usara pero que son propias de Angular y nosotros no las tocaremos (al menos en este ejemplo).\n Angular – Rutas  Una vez he explicado en la anterior entrada como inicializa Angular la aplicación, voy a explicar como hacer para que esta pueda aceptar parámetros a través de la URL introducida en el navegador. Básicamente, lo que deseo hacer es que, suponiendo que nuestra aplicación este corriendo en http://localhost:4200/ (es la dirección por defecto en la que escucha Node.js cuando lo lanzamos con el comando ng serve ), si vamos a la dirección http://localhost:4200/2018 nos muestre las ventas del ejercicio 2018.\n "
},
{
	"uri": "http://ww2.profesor-p.com/3-hugo/",
	"title": "Hugo",
	"tags": [],
	"description": "",
	"content": "Articulos sobre HUGO y como crear paginas web estaticas dinámicamente.\n Generar paginas Web estáticas dinámicamente  Vamos a hablar de Hugo. Este un software permite crear sitios web estáticos pero trabajando casi como si fueran dinámicos. Para ello podremos usar diferentes plantillas que configuraremos, para luego añadir entradas y contenido dinámico fácilmente.\n Crear pagina web gratuita en GitHub  En esta entrada explicare como crear una página web gratuita en GitHub\nEstas páginas deben ser estáticas pero no hay limitaciones de ancho de banda, numero de ficheros y por supuesto no meterán publicidad en vuestra pagina web. Ademas, utilizara https y podreis usar un dominio propio, si lo habeis comprado con anterioridad. Aclarar que un dominio se puede registrar por solo un euro al año 😉\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/08/aplicacion-crud-en-angular/",
	"title": "Aplicación CRUD en Angular",
	"tags": ["angular", "frontend", "json", "rest"],
	"description": "",
	"content": "En esta ocasión os traigo un programa realizado en Angular, el cual a través de peticiones REST, da de alta, modifica, borra y consulta los diferentes países disponibles en una base de datos. Lo que se viene diciendo una aplicacion CRUD.\nPor supuesto el protocolo para las comunicaciones es JSON.\nEl código fuente lo tenéis en: https://github.com/chuchip/crud-rest-angular\nEste programa es el frontend del realizado en JavaEE, y que explico como funciona en las entradas: http://www.profesor-p.com/2018/10/06/aplicacion-rest-en-javaee/ y http://www.profesor-p.com/2018/10/07/aplicacion-rest-en-javaee-2a-parte/\nEs decir, este programa realizara sera el cliente que correrá en el navegador de los usuarios y el anterior programa estará corriendo en un servidor y tendrá acceso a la base de datos correspondiente, para actualizarla según las peticiones REST realizadas por el cliente.\nEsto es un pantallazo de como queda en modo consulta.\nY este otro, un pantallazo del alta:\nOs invito a que echéis un vistazo al programa, sobre todo al fichero datosserver.service.ts que es donde se se hacen las diferentes peticiones GET, POST, PUT y DELETE para interactuar con el servidor .\nSi veo interés ya explicare con detalle como funciona.\nEspero vuestros comentarios y sugerencias.\n¡¡ Hasta pronto!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/3-mvc/",
	"title": "MVC",
	"tags": [],
	"description": "",
	"content": "Aunque ya no se utiliza tanto aquí encontraras artículos sobre Spring MVC.\n Ejemplo aplicación MVC con Spring Boot usando NetBeans 9  En una entrada anterior explique como instalar NetBeans 9, añadiendole el plugin para usar Spring Boot. Ahora vamos a crear nuestro primer proyecto en este entorno. Pulsaremos New Project, lo cual nos mostrara una pantalla como la siguiente. y en el campo Filter pondremos spring, para después eligir Spring Boot Inititilizr project. Pulsaremos Next y nos pedirá una serie de datos sobre nuestro proyecto. Para este ejemplo podemos dejar los campos como aparecen por defecto.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/4-database/",
	"title": "Database",
	"tags": [],
	"description": "",
	"content": "Entradas sobre como acceder a bases de datos, con JPA y JDBC\n Lambdas en JDBC Data  En una entrada anterior, puse un ejemplo de como usar expresiones Lambas, como me parece que es un tema interesante, este de la programación funcional, voy a insistir en este tema. Una cosa muy común en Java es tener que pesarle como argumento a una función externa, una objeto que implemente una función donde nosotros pondremos el código a ejecutar en nuestra aplicación. Un ejemplo practico es en el uso de la clase JdbcOperations, que es utilizada por Spring para poder realizar operaciones JDBC, la cual tiene la función:\n Optimizando relaciones entre entidades en Hibernate  En esta entrada, siguiendo el proyecto de ejemplo que teneis en https://github.com/chuchip/jpajoins explicando como optimizar las consultas a la base de datos usando JPA. Se verán diferentes tipos de consultas, explicando como realizar uniones entre tablas de modo perezoso (lazy) o agresivo (eager). Se unirán tablas por un solo campo, por varios e incluso por uno pero añadiendo una condición estática. EL proyecto de ejemplo esta desarrollado en Spring Boot con Hibernate, usando como base de datos H2.\n Accediendo facilmente a los datos con Spring Rest Data  Spring Boot ofrece un fantástico soporte para acceder a los datos con JPA a través de sus interfaces, del tipo Repository. Si a esto le añadimos la facilidad con que se crean servicios REST, como explicaba en la entrada [http://www.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-con-springboot/][2] podremos hacer una aplicación ofreciendo una API para acceder a nuestra base de datos preferida muy facilmente. Pero si queremos implementar HATEOAS en nuestro proyecto o si hay muchos criterios sobre los que debemos acceder a los datos, deberemos escribir bastante código.\n Querys avanzadas con JPA en Spring Boot  Hay veces en que las campos sobre los que restringir una consulta pueden variar en tiempo de ejecución. En ese caso si queremos usar JPA no podemos usar una sentencia @Query definida en nuestro repositorio pues no sabemos los campos sobre los que se aplicaran condiciones en la consulta. Además es bastante común que el usuario pueda elegir el criterio de búsqueda sobre un campo, deseando que el valor de un campo deba ser igual, mayor o menor, respecto al valor introducido .\n JPA \u0026#43; Hibernate en Spring  En un entrada anterior, explique como crear nuestra conexión a la base de datos, usando JNDI. En esta entrada explicare como usar esa conexión con JPA. Recordar que el código fuente de de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat Importante recalcar que este ejemplo solo funciona con Java 1.8 o superior. Lo primero explicar un poco de que va esto de JPA. JPA son las siglas de Java Persistence API. Es decir la API de persistencia en Java.\n JPA con Lombok, simplificando.  En un entrada anterior, explique que para usar JPA hay que tener nuestros objetos POJO definidos . En esta entrada hablare de como mejorar la la definicion de nuestro objeto POJO, con la libreria Lombok. Recordar que el código fuente de de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat Anteriormente teniamos definido nuestro objeto de esta manera: @Entity @Table(name = \u0026quot;usuario\u0026quot;, uniqueConstraints = { @UniqueConstraint(columnNames = {\u0026quot;login\u0026quot;})}) public class Usuario implements Serializable { @Id String login; @Column String nombre; public Usuario() { } public String getLogin() { return login; } public void setLogin(String login) { this.\n Acceso a Base de Datos con Spring Data JDBC  En el anterior articulo explicaba como crear la conexion a la base de datos en un servidor de aplicaciones Tomcat . En este articulo explicare como acceder a esos datos a traves del paquete JDBC de Spring Data JDBC El código fuente de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat Creando nuestro POJO y Repositorio Ahora que ya tenemos nuestro acceso a la base de datos configurado y disponible, vamos a utilizarlo (por eso de que no se aburra 😉 )\n"
},
{
	"uri": "http://ww2.profesor-p.com/4-angular/",
	"title": "Angular",
	"tags": [],
	"description": "",
	"content": "Artículos diversos sobre el framework Angular\n Curso de Angular 6  En esta página iré poniendo las sucesivas entradas donde intentare dar un curso básico sobre Angular 6 En el curso se desarrollara una aplicación que usando peticiones RESTFUL, realizara una consulta mostrando un histórico de ventas. En la aplicación se usara Boostrap y se explicara como utilizar rultas. La aplicación backend, en el servidor, esta hecho en Java, usando Spring Framework, y se puede ver en su desarrollo en la pagina: http://www.\n Aplicación usando Java y Angular  A continuación detallo las entradas donde voy explicando, paso a paso, como crear un aplicación, que es una migración de una consulta realizada en el ERP Anjelica, el cual es software libre . Esta es la pantalla original de la aplicación en Anjelica. Esta aplicación es una consulta donde la parte del servidor se realiza en Java, usando Spring como Framework y la parte del cliente se realiza en Angular.\n Aplicación CRUD en Angular  En esta ocasión os traigo un programa realizado en Angular, el cual a través de peticiones REST, da de alta, modifica, borra y consulta los diferentes países disponibles en una base de datos. Lo que se viene diciendo una aplicacion CRUD. Por supuesto el protocolo para las comunicaciones es JSON. El código fuente lo tenéis en: https://github.com/chuchip/crud-rest-angular Este programa es el frontend del realizado en JavaEE, y que explico como funciona en las entradas: http://www.\n Angular – Hablando español  Angular si no se le dice lo contrario, es ingles del bueno. Las fechas las pondrá en su formato de mes/dia/año . Los números serán con las comas con separadores de miles y los decimales con puntos. Vamos, muy ingles todo. El problema es que no todo el mundo es ingles (aunque les pene a los ingleses ;- )) . Así que en esta entrada voy a explicar como hacer que Angular se nos vuelva español.\n Angular 6 – Añadir Bootstrap 4 con JQuery  Recordar lo primero que para utilizar toda la potencia de BootStrap, necesitamos tener instaladas las librerias de JQuery y Popper Hay varias maneras de instalar estas librerías. Localmente usando npm Una vez estemos situados el directorio principal del proyecto, desde tu terminal preferido ejecutar las instrucciones siguientes: npm install bootstrap@4 jquery popper.js --save Esto nos instalara los archivos necesarios bajo el directorio node-modules. Ahora debemos incluir el fichero de estilos (css) de BootStrap y las librerías JavaScript de BootStrap, JQuery y Pooper.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/5-cloud/",
	"title": "Cloud",
	"tags": [],
	"description": "",
	"content": "Entradas relacionas con el desarrollo de aplicaciones Spring en la nube.\n Microservicios distribuidos con Eureka  En esta clase hablare de como crear microservicios distribuidos en Spring Boot utilizando las facilidades que nos da el paquete Spring Cloud NetFlix. Cualquier microservicio debe poder localizar las diferentes instancias de otro servicio del que dependa sin tener sus direcciones definidas en el código. En el caso de que un microservicio deba acceder a otro lo ideal seria que de alguna manera pudiera saber en que direcciones esta las instancias de ese otro microservicio funcionando, pues lo más común es que se levanten diferentes instancias dependiendo de la carga.\n Servidor configuraciones usando Spring Cloud  En esta ocasión vamos a usar el paquete Spring Cloud Config para poder tener configuraciones remotas para nuestras aplicaciones. La idea es que nuestro programa o programas puedan ir a buscar sus parámetros de configuración a un lugar externo, de tal manera que nuestra aplicación sea fácilmente parametrizable e incluso se puedan cambiar sus configuraciones en caliente. Esto se utiliza ampliamente en microservicios pues una mismo servicio o aplicación puede estar lanzada muchas veces en diferentes contenedores y es interesante tener un lugar central desde donde se puedan aplicar las configuraciones a estos servicios.\n ⁠⁠⁠"
},
{
	"uri": "http://ww2.profesor-p.com/5-dba/",
	"title": "DBA",
	"tags": [],
	"description": "",
	"content": "Enlaces disponibles:\n Conectando a una base de datos usando JNDI y Spring en Tomcat  En este ejemplo veremos como conecta a Postgresql usando JPA + Hibernate y Spring JDBC. Para ello uso como servidor de aplicaciones Tomcat. La configuración esta realizada con anotaciones y XML y utilizo el pool de conexiones de Tomcat recogido a través de JNDI, para que la aplicación no deba saber realmente ni donde se conecta.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/6-webflow/",
	"title": "Webflow",
	"tags": [],
	"description": "",
	"content": "Entradas sobre el paquete WebFlow de Spring. Actualmente esta en un poco en desuso pero ha sido ampliamente utilizado en entornos empresariales.\n Spring WebFlow con JSP – Configuración  Voy a intentar explicar como funciona Spring WebFlow y para ello, como siempre, lo haré desarrollando un programa que podéis descargar de https://github.com/chuchip/webflowExample El programa simulara que entras a la página de un banco donde puedes realizar una transferencia de tus cuentas personales a otra. Para ello, primero deberás identificarte y según el usuario con el que te identifiques tendrás acceso a unas cuentas que a su vez disponen de un saldo establecido.\n Spring WebFlow con JSP  En el articulo anterior http://www.profesor-p.com/2018/10/29/spring-webflow-con-jsp-configuracion/ explicaba como configurar el programa para que Spring WebFlow funcionara. En este articulo explicare como hacer el flujo en si. La página principal del programa no esta dentro de ningún flujo y sus peticiones son respondidas por Spring MVC, en la clase MyController, la cual podemos encontrar en el paquete profesorp.webflow.controller. Esta clase anotada con la etiqueta @Controller responde en la función indice1 a las peticiones de los recursos \u0026#8220;/\u0026#8221; e \u0026#8220;index\u0026#8221;\n ⁠⁠⁠"
},
{
	"uri": "http://ww2.profesor-p.com/6-javaee/",
	"title": "J2EE",
	"tags": [],
	"description": "",
	"content": "Ejemplos usando java EE. (La competencia de Spring 😄 )\n Aplicación CRUD usando REST en JavaEE  Explicaré como hacer una aplicación CRUD, que sirva peticiones REST con el protocolo JSON, usando JavaEE y Glasfish como servidor de aplicaciones. En esta aplicación actualizaremos y consultaremos una pequeña tabla a través de diferentes peticiones REST.\n Aplicación CRUD usando REST en JavaEE (II)  En esta ocasión continuo explicando la aplicación CRUD, utilizando peticiones REST, con JavaEE.\n Desarrollando aplicaciones Java EE en NetBeans 9  El recién salido NetBeans 9, es un excelente IDE, con soporte para Java 10 y 11, y con otra serie de características muy interesantes. Sin embargo, por temas de licencias con Oracle que es el dueño del antiguo NetBeans, solo tiene soporte para Java Standard Edition, no pudiendo, en teoría, hacer aplicaciones para Java EE.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/7-base/",
	"title": "Base",
	"tags": [],
	"description": "",
	"content": "Explicaciones sobre el core de Spring\n Perfiles en Spring Boot  Cuando se hacen aplicaciones empresariales, lo normal es que, como mínimo, primero se desplieguen en un entorno de pruebas y después en el entorno de producción. Cada entorno de pruebas tendrá diferentes bases de datos, diferentes URLs y toda una serie de parámetros específicos, con el fin de que una aplicación en desarrollo no acceda nunca a datos reales.\n Cacheando resultados con Spring Boot  Vamos a imaginar una aplicación web, donde por cada petición recibida, debe leer ciertos datos de configuración desde una base de datos. Esos datos no cambiaran normalmente pero nuestra aplicación, en cada petición, debe conectarse, ejecutar las sentencias adecuadas para leer los datos, traerlos por la red, etc. Imaginemos, además, que la base de datos a la que nos conectamos esta saturada o la conexión de red que nos une a la base de datos es inestable.\n Beans avanzados  En esta ocasión he cogido un proyecto de SimpleProgramming el cual tiene un video en Youtube donde explica como cargar Beans dinámicamente usando Spring (en Ingles). Imaginemos que tenemos un programa que dependiendo de unos parámetros deba cargar un clase u otra, donde está definida la lógica a seguir. Por supuesto podemos anidar condiciones e instanciar las clases debidas, pero eso tiene un problema y es que si mañana debemos añadir una lógica nueva, deberemos incluir una condición más para cargar la nueva clase, y podríamos introducir errores en el código.\n ⁠⁠⁠"
},
{
	"uri": "http://ww2.profesor-p.com/2-spring/8-restful/",
	"title": "Restful",
	"tags": [],
	"description": "",
	"content": "Anotaciones sobre aplicaciones Restful en Spring\n Estableciendo filtros en Spring  En esta entrada voy a hablar de como implementar filtros en Spring. Los filtros son de los que se pueden establecer cuando se recibe una petición HTTP. Es decir, suponiendo que tenemos un programa escuchando en unas URI, poder especificar que deseamos ejecutar algo antes de que las peticiones sea procesadas por el controlador. Esto es muy útil si queremos que todas las peticiones cumplan un requisito, por ejemplo incluir una cabecera especifica.\n Usando Zuul para redirigir peticiones REST  En este articulo explicare como crear una pasarela para peticiones REST (una gateway) utilizando Zuul. Zuul es parte del paquete Spring Cloud NetFlix y permite redirigir peticiones REST, realizando diversos tipos de filtros. En casi cualquier proyecto donde haya microservicios, es deseable que todas las comunicaciones entre esos microservicios pasen por un lugar común, de tal manera que se registren las entradas y salidas, se pueda implementar seguridad o se puedan redirigir las peticiones dependiendo de diversos parámetros.\n Personalizar salidas de códigos HTTP en Spring Boot  En esta articulo os voy a explicar como devolver errores HTTP personalizados. Para ello crearemos un proyecto llamado httpErrorPersonalizado. Teneis el código fuente de este proyecto en mi página de GitHub Cuando realizamos una petición HTTP a un recurso en Spring Boot, es común que esa petición tenga que considerar la opción de devolver un error. Es el caso típico de que realizamos una petición RESTful para solicitar un registro, pero ese registro no existe.\n ⁠⁠⁠"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/29/spring-webflow-con-jsp-configuracion/",
	"title": "Spring WebFlow con JSP – Configuración",
	"tags": ["bootstrap", "java", "jdbc", "jquery", "jstl", "l", "mvc", "security", "seguridad", "spring", "tomcat", "webflow"],
	"description": "",
	"content": "Voy a intentar explicar como funciona Spring WebFlow y para ello, como siempre, lo haré desarrollando un programa que podéis descargar de https://github.com/chuchip/webflowExample\nEl programa simulara que entras a la página de un banco donde puedes realizar una transferencia de tus cuentas personales a otra. Para ello, primero deberás identificarte y según el usuario con el que te identifiques tendrás acceso a unas cuentas que a su vez disponen de un saldo establecido. Para realizar todo esto utilizo H2 como base de datos y la autentificación se realiza con el paquete de seguridad de Spring, utilizando JDBC . Por hacer la página mas funcional utilizo Bootstrap y JQuery.\nEl programa esta realizado para que funcione bajo Tomcat, en el contexto: webflow. Por lo que deberemos ir a la dirección http://localhost:8080/webflow  para probar nuestra aplicación:\nEn esta imagen se puede ver la definición del flujo de trabajo.\nSpring WebFlow es un paquete con el cual podemos definir el flujo de nuestra aplicación. Es decir, definimos las acciones a realizar cuando se pulse un enlace, se cumpla cierta condición, etc. Estos flujos son definidos en ficheros XML, de tal manera que ahí es donde definimos que de la PAGINA_X, al pulsar el BOTON1, vaya a la PAGINA_XY, siempre y cuando la CONDICION_Z se cumpla. Esto nos permite separar la lógica del programa de las vistas (los ficheros JSP), ademas de ser más fácil el reutilizar código.\n\u0026#8211; Estructura\nLa estructura del programa es la que se ve en la imagen siguiente:\nDentro del directorio WEB-INF esta la carpeta flows, que a su vez tiene la carpeta traspaso y time donde definimos los dos flujos de trabajo que se usan en la aplicación. Observar que los ficheros xml con la definición del flujo de trabajo también se aloja en las mismas carpetas donde estan los JSP de su flujo. Es decir el flujo de trabajo \u0026#8220;traspaso\u0026#8221; se define en el fichero \u0026#8220;traspaso.xml\u0026#8221; y utiliza los ficheros: cuentaOrigen.jsp, importe.jsp, confirmar.jsp, _include.jsp y _navegador.jsp.\nDentro del directorio WEB-INF también se alojan las carpetas css y img donde se guardan respectivamente las plantillas css y las imágenes de la aplicación. \n Configurando la Base de Datos y Persistencia  Empezare mostrando las tablas usadas en la aplicación:\ncreate TABLE clientes ( id int NOT NULL, login varchar(45) not null, nombre varchar(100) not null, dni varchar(15) not null, unique key(login) ); create table cuentas( cuenta varchar(50) not null, importe double not null, unique key(cuenta) ); create table cuentas_clientes( id int not null, cuenta varchar(50) not null, unique key(id,cuenta) ); alter table cuentas_clientes add CONSTRAINT fk_cuentas FOREIGN KEY (cuenta) REFERENCES cuentas (cuenta); create table users( username varchar(45) not null, password varchar(100) not null, enabled smallint not null default 1, unique key (username) ); CREATE TABLE user_roles ( user_role_id int(11) NOT NULL AUTO_INCREMENT, username varchar(45) NOT NULL, role varchar(45) NOT NULL, PRIMARY KEY (user_role_id), UNIQUE KEY uni_username_role (role,username) ); alter table user_roles add CONSTRAINT fk_username FOREIGN KEY (username) REFERENCES users (username) La tabla clientes, cuentas y cuentas_clientes son usadas por la lógica del programa, mientras que users y user_roles son usadas por el modulo de seguridad de spring.\nLa persistencia esta definida en la clase JpaConfig. Podéis ver una explicación de esta clase en la parte de la configuración de JPA de esta entrada: http://www.profesor-p.com/2018/09/03/aplicacion-en-spring-rest-y-angular-2-parte/#jpa\n Dependencias  Necesitaremos tener el paquete de JPA, JDBC, Hibernate, soporte de transaciones y por supuesto de H2.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.data\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-data-jpa\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.0.9.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-jdbc\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.0.10.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.197\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-agroal\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.5.Final\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!-- Paquete para dar soporte a transaciones --\u0026gt; \u0026lt;groupId\u0026gt;org.springframework\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-tx\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt;  Configurando MVC y WEB-FLOW   Clase WebConfig \n   En ella se configura la parte MVC de la aplicación. Así en la función addResourceHandlers especifico que los recursos de las peticiones a \u0026#8220;webjars\u0026#8221; deberán ser buscadas en el directorio /webjars y que los recursos de las peticiones a resources deberán ser buscadas en el directorio /WEB-INF/resources/. Es decir que cuando vayamos a http://localhost:8080/webflow/resources/XX deberá traer el fichero /WEB-INF/resources/XX\n@Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry .addResourceHandler(\"/webjars/**\") .addResourceLocations(\"/webjars/\"); registry .addResourceHandler(\"/resources/**\") .addResourceLocations(\"/WEB-INF/resources/\"); } La función viewResolver establece que se usara la JSTL (que no es sino una extensión de JSP), especificando en que directorio y que extensiones debe resolver.\n@Bean public ViewResolver viewResolver() { InternalResourceViewResolver viewResolver = new InternalResourceViewResolver(); viewResolver.setViewClass(JstlView.class); viewResolver.setPrefix(\"/WEB-INF/jsp/\"); viewResolver.setSuffix(\".jsp\"); return viewResolver; } Las funciones FlowHandlerMapping y FlowHandlerAdapter especificaran los identificadores o registros de webflow y sus correspondiente ejecutores. Ahora explicare que es eso 😉\n Clase WebFlowConfig   En esta clase configuramos webflow como tal, para ello lo primero es extender de la clase AbstractFlowConfiguration y definir las funciones que detallo a continuación:\n@Bean public FlowDefinitionRegistry flowRegistry() { return getFlowDefinitionRegistryBuilder() .addFlowLocation(\"/WEB-INF/flows/traspaso/traspaso.xml\",\"traspaso\") .addFlowLocation(\"/WEB-INF/flows/traspaso/time/traspaso_time.xml\",\"traspaso_time\") .build(); } En esta función se declaran los diferentes identificadores de los flujos a usar.Así tenemos que el identificador \u0026#8220;traspaso\u0026#8221; estará definido en el directorio \u0026#8220;/WEB-INF/flows/traspaso/traspaso.xml\u0026#8220;. Esto lo que significa es que cuando vayamos a la dirección: http://localhost:8080/webflow/traspaso entraremos en el flujo que tenemos definido en el fichero indicado. A su vez, cuando vayamos a http://localhost:8080/webflow/traspaso_time entraremos al flujo declarado en \u0026#8220;/WEB-INF/flows/traspaso/time/traspaso_time.xml\u0026#8220;.\nEn este caso yo defino individualmente los dos flujos, pero se pueden utilizar comodines para que Spring busque dentro de un directorio todos los ficheros que cumplan ciertos criterios. Así, la sentencia: .addFlowLocationPattern(\u0026lt;span class=\u0026quot;hl-string\u0026quot;\u0026gt;\u0026quot;/WEB-INF/flows/**/*-flow.xml\u0026quot;\u0026lt;/span\u0026gt;)especificaría que añadiera todos los flujos que encontrara en el directorio /WEB-INF/flows cuyo nombre terminara en \u0026#8220;flow.xml\u0026#8221;. Los identificadores en este caso serian los nombres de los ficheros sin la extensión xml. Es decir si tenemos el fichero: \u0026lt;span class=\u0026quot;hl-string\u0026quot;\u0026gt;/WEB-INF/flows/consulta-flow.xml\u0026lt;/span\u0026gt; el identificador seria \u0026#8220;consulta-flow\u0026#8221;\nLa siguiente función simplemente llama a la anterior para especificar los ejecutores de los registros anteriormente definidos.\n@Bean public FlowExecutor flowExecutor() { return getFlowExecutorBuilder(flowRegistry()).build(); } Aclarar que el trabajo del FlowExecutor es crear y ejecutar los flujos de trabajo que anteriormente hayamos definido en los registros.\nLas siguientes funciones unen las vistas (ficheros JSP) con el paquete webflow. Como se puede observar crea dos objetos en los cuales se definen las uniones entre el paquete MVC de Spring y el paquete WebFlow. Esto es así porque el paquete WebFlow también funciona con otros MVC como JavaServer Faces de JavaEE\n @Bean public FlowBuilderServices flowBuilderServices() { return getFlowBuilderServicesBuilder() .setViewFactoryCreator(mvcViewFactoryCreator()) .setDevelopmentMode(true).build(); } @Bean public MvcViewFactoryCreator mvcViewFactoryCreator() { MvcViewFactoryCreator factoryCreator = new MvcViewFactoryCreator(); factoryCreator.setViewResolvers( Collections.singletonList(this.webMvcConfig.viewResolver())); factoryCreator.setUseSpringBeanBinding(true); return factoryCreator; }  Dependencias  Ademas del paquete JSTL, también usamos el paquete spring-security-taglibs que es una extensión de JSTL que nos permite trabajar con el paquete de seguridad de Spring dentro de nuestros ficheros JSP. Por supuesto también debemos incluir el paquete spring-webflow\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;jstl\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jstl\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-taglibs\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.webflow\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-webflow\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.5.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026#8211; Configurando la seguridad\nNo es mi intención el volver a explicar como funciona la seguridad en Spring, pues aunque en anteriores ejemplos (http://www.profesor-p.com/2018/10/17/seguridad-web-en-spring-boot/) los usuarios los guardaba en memoria en vez en una base de datos como en esta ocasión, realmente lo único que cambia es que se incluye la función: \u0026lt;strong\u0026gt;configure(AuthenticationManagerBuilder auth)\u0026lt;/strong\u0026gt;y se quita la función UserDetailsService de la clase SecurityWebConfig.\n@Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth .jdbcAuthentication() .dataSource(dataSource) .usersByUsernameQuery( \"select username,password, enabled from users where username=?\") .authoritiesByUsernameQuery( \"select username, role from user_roles where username=?\") .passwordEncoder(passwordEncoder()); } En esta función se configura la autentificación por jdbc de la clase AuthenticationManagerBuilder especificándole el DataSource a usar, así como las sentencias SQL a ejecutar para validar los usuarios y los roles de estos.\nLa clase configure(HttpSecurity http) configura la seguridad no teniendo nada en particular, solo resaltar que no deshabilito el modulo de seguridad CRSF por lo cual todas las peticiones POST deben incluir nuestro identificador CRSF. Lo veremos más tarde al explicar los ficheros JSP.\n@Override protected void configure(HttpSecurity http) throws Exception { http .authorizeRequests() .antMatchers(\"/\", \"/index\", \"/webjars/**\", \"/resources/**\").permitAll() .antMatchers(\"/**\").authenticated() .anyRequest().denyAll().and() .formLogin() .loginPage(\"/login\") .defaultSuccessUrl(\"/user\") // Para que registremos el usuario .permitAll() .and() .logout().logoutSuccessUrl(\"/index\") .permitAll(); } La clase SecurityWebApplicationInitializer que extiende de AbstractSecurityWebApplicationInitializer debe estar definida pues esta aplicación al no ser Spring Boot, sino Spring a secas la necesita para implementar la seguridad web. La configuración, simplemente es inexistente. Con que exista la clase es suficiente 😉\n Dependencias  Definimos los paquetes de seguridad de Spring, incluyendo el de seguridad web.\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-web\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-config\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.1.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; En la próxima entrada explicare el programa paso a paso 😉\n¡¡ Nos vemos!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-con-springboot/",
	"title": "Aplicacion CRUD con REST en Kotlin y SpringBoot",
	"tags": ["crud", "jpa", "kotlin", "rest", "spring boot"],
	"description": "",
	"content": "Buenas chavales,\nEn esta nueva entrada os enseñare como realizar un programa CRUD, que sirva peticiones REST, usando Spring Boot y como lenguaje de programación usar Kotlin.\nCreo que no hará falta aclarar que una aplicación CRUD es la típica aplicación que permite consultar, insertar, modificar y borrar los datos de una tabla. Vamos, lo que se suele ir llamando un mantenimiento de una tabla.\nEsta aplicación seria una variación del que explique en la entrada http://www.profesor-p.com/2018/10/06/aplicacion-rest-en-javaee/ , donde se utilizaba JavaEE. Como frontend para este programa podéis usar el realizado en Angular, que explico en esta entrada http://www.profesor-p.com/2018/10/08/aplicacion-crud-en-angular/ ya que lo he hecho totalmente compatible.\nEl código fuente lo tenéis en mi repositorio de GitHub, en: https://github.com/chuchip/restKotlin\nBueno, !!manos a la obra!!\nLo primero sera cambiar de IDE, ya que mi querido NetBeans no soporta el lenguaje Kotlin. Por ello utilizaremos Eclipse, habiéndole instalado el plugin de Kotlin y de Spring Boot. Tampoco os voy a explicar como instalar estos plugins pues tenéis unos 600 manuales por la web y tampoco es cuestión de alargarme demasiado 😉\nUtilizando el magnifico asistente de \u0026#8220;Spring Starter Project\u0026#8221; crearemos un proyecto Spring Boot, al que le tendremos que añadir los paquetes \u0026#8220;H2\u0026#8243;,\u0026#8221;JPA\u0026#8221; y \u0026#8220;WEB\u0026#8221;. ¡¡ Acordaros de elegir Kotlin como lenguaje de programación !!\nUna vez tenemos nuestro proyecto creado, debemos comprobar la configuración del compilador de Kotlin, para ello nos iremos a las Propiedades del proyecto y elegiremos la pestaña \u0026#8220;Kotlin Compiler\u0026#8221;. Ahí deberemos especificar que que la versión de java para la que debe compilar es la 1.8 y deberemos incluir los plugins Spring y JPA. La pantalla deberá quedar como esta:\nAhora ya podemos ponernos a teclear 😉\nEclipse nos habrá creado la clase de entrada , que sera algo como esto:\nimport org.springframework.boot.autoconfigure.SpringBootApplication import org.springframework.boot.runApplication @SpringBootApplication class RestKotlinApplication fun main(args: Array\u0026amp;lt;String\u0026amp;gt;) { runApplication\u0026amp;lt;RestKotlinApplication\u0026amp;gt;(*args) }  Esta clase la dejaremos sin tocar, pues nos sirve perfectamente.\nDeberemos configurar el fichero application.properties de Spring Boot, para especificarle que queremos usar una base de datos H2 y ponerle los parámetros de conexión. Quedara algo como esto:\n# H2 spring.h2.console.enabled=true spring.h2.console.path=/h2 # Datasource spring.datasource.url=jdbc:h2:file:~/test spring.datasource.username=sa spring.datasource.password= spring.datasource.driver-class-name=org.h2.Driver  Observar las anotaciones: spring.h2.console.enabled=true y spring.h2.console.path=/h2 que nos permitira acceder a la consola de H2. Podremos acceder yendo a la URL: http://localhost:8080/h2\nTambién he creado un fichero llamado data.sql que Spring Boot ejecutara para precargar la base de datos con algunos valores, porque, como veis, la base de datos se crea solo en memoria.\nEl fichero deberá estar en el directorio resources y es algo parecido a esto:\ninsert into locales values('es_ES', 'español (España)'); insert into locales values('fr', 'frances'); insert into locales values('fr_BE', 'francés (Bélgica)'); insert into locales values('ca_ES', 'catalán (España)'); insert into locales values('es_AR', 'español (Argentina)');  La aplicación actualmente ya es ejecutable, aunque solo podríamos acceder a la consola de H2. !! Podéis jugar con ella, que esta muy bien hecha y tiene mucha potencia!!\nAhora pasamos a crear nuestra entidad de Idiomas, a la que yo he llamado locales.kt\nimport com.fasterxml.jackson.annotation.JsonProperty import javax.persistence.Basic import javax.persistence.Column import javax.persistence.Entity import javax.persistence.Id import javax.persistence.Table import javax.validation.constraints.NotNull import javax.validation.constraints.Size @Entity @Table(name = \u0026quot;locales\u0026quot;) data class Locales ( @Id @Basic(optional = false) @NotNull @Size(min = 1, max = 5) @JsonProperty(value = \u0026quot;codigo\u0026quot;) @Column(name = \u0026quot;loc_codi\u0026quot;) val codigo: String, @JsonProperty(value = \u0026quot;nombre\u0026quot;) @Column(name = \u0026quot;nombre\u0026quot;) val nombre: String ) { }  Como veis es una clase muy normalita. Aclarar que he puesto algunas etiquetas que no son necesarias para que veáis como podriais usarlas. Así las etiquetas: @Table(name = \u0026#8220;locales\u0026#8221;), @JsonProperty(value = \u0026#8220;codigo\u0026#8221;) y @ColumName no son necesarias pues los nombres de las clases y variables coinciden con los de la base de datos.\nObservar como se define la clase con la etiqueta data class y lo fácil que es crear una entidad en Kotlin al no tener que definir setters, getters y definir las propias variables globales en el constructor. Vamos, que si os fijais, la clase como tal no tiene nada ;-).\nAhora definimos la clase que hara de repositorio, a la que yo he llamado: LocaleRepository.kt\nimport org.springframework.data.jpa.repository.Query import org.springframework.data.repository.CrudRepository import profesorp.kotlin.entity.Locales interface LocaleRepository : CrudRepository\u0026amp;lt;Locales,String\u0026amp;gt; { @Query(\u0026quot;SELECT l FROM Locales l where l.codigo like ?1 and upper(l.nombre) like ?2\u0026quot;) fun findLike(codigo:String, nombre:String):Iterable\u0026amp;lt;Locales\u0026amp;gt;; }  Otra clase super compleja 😉\n¿Hay que explicar algo ?. Bueno, quizas que he creado una nueva función que usaremos para poder filtrar los países por nombre y/o código. Sí, esa funcion que he llamado findLike\nBueno, y por ahora ya vale. En la próxima entrada detallare la clase que sirve las peticiones REST.\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/13/aplicacion-en-angular-instalacion-y-configuracion-basica/",
	"title": "Frontend en Angular",
	"tags": ["angular", "rest"],
	"description": "",
	"content": "En anteriores entradas se creo la parte del servidor de nuestra aplicación . Para la parte cliente o frontend usaremos Angular 6.\nEl código fuente del programa lo tenéis, como siempre, en mi página de GitHub.\nLo primero sera instalar Angular, para ello tenemos un excelente manual de como hacerlo en la página web de Angular. Básicamente es instalar el servidor de aplicaciones Node.js. y su aplicación incluida npm (es un solo ejecutable) de https://nodejs.org/en/download/ y luego, en una shell (cmd en windows), ejecutar:\nnpm install -g @angular/cli lo cual nos instalara Angular, bajando de Internet todos los ficheros necesarios (que son bastantes).\nAhora crearemos nuestro proyecto a través del interprete de comandos (shell) de Angular (Angular CLI) que acabamos de instalar.\nPara ello abriremos un terminal en nuestro sistema operativo (Windows con CMD y Linux con una shell), nos posicionaremos en la carpeta donde vamos a crear nuestro proyecto y ejecutaremos el siguiente comando:\nng new yagesclient Este comando creara la estructura básica (o template que dirían los ingleses) para el proyecto. Es normal que le cueste un rato, ya que descarga muchos ficheros de internet .\nEsta es una salida típica del comando ng new en una ventana windows:\nY podemos ver que nos ha creado el directorio yagesclient, debajo del directorio donde estábamos:\nAhora mismo ya podríamos ver esa aplicación mínima que hemos creado en nuestro navegador. Para ello, lanzamos nuestro servidor web con el comando:\nng serve --open  Este comando nos mostrara la siguiente salida:\nCambien abrirá una ventana de nuestro navegador donde podremos ver nuestra aplicación.\nPulse encima de la imagen para ampliarla\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\nFácil, ¿ verdad ?. Como se puede observar con muy poco esfuerzo se ha creado una aplicación en Angular, totalmente funcional que el servidor de Node que hemos instalado sirve.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/31/aplicacion-en-spring-y-angular/",
	"title": "Backend I",
	"tags": ["angular", "java", "spring"],
	"description": "",
	"content": "En Anjelica, el ERP desarrollado por mi hace unos años, hay un programa que saca un comparativo de ventas, entre dos años, mostrando mes a mes, los kilos, importes y ganancias.\nLa idea es realizar esta misma consulta pero usando Spring con REST en el backend y como frontend usar Angular.\nPara ello se realizaran los siguientes pasos:\n  Crear tablas y cargar datos de prueba en la base de datos. Usare H2 embebido, en vez de postgresql, que es la base de datos que usa Anjelica. Crear aplicación servidor, bajo TOMCAT 9, usando Spring 5. No usare Spring Boot para este ejemplo, aunque podría hacerlo perfectamente y de hecho haría la aplicación más sencilla. Crear aplicación cliente, para lo cual usare Angular 6.  La aplicación, como se ve en el anterior pantallazo, nos mostrara las ventas por meses, haciendo un comparativo del ejercicio introducido contra el anterior. Pulsando en cada mes, veremos las ventas por semanas.\nPara empezar vamos a definir las tablas que usaremos en esta consulta:\n-- -- Tabla calendarios -- create table calendario ( cal_ano int, -- Año cal_mes int, -- Mes cal_fecini date, -- Fecha Inicial cal_fecfin date, -- Fecha Final. constraint ix_calendario primary key (cal_ano,cal_mes) ); create table histventas ( hve_fecini date not null, -- Fecha Inicial hve_fecfin date not null, -- Fecha Final hve_kilven float, -- Kilos Venta (Total) hve_impven float, -- Importe Ventas (Total) hve_impgan float, -- Importe ganancia div_codi int not null default 1, -- Divisa constraint ix_histventas primary key (hve_fecini ,hve_fecfin,div_codi ) ); Como se ve, tenemos una tabla calendario donde definimos, para cada mes, cual es la fecha inicial y fecha final. Esto es porque nosotros definimos cuando empieza un mes y cuando termina, la razón de hacerlo así es porque, en muchas empresas se vende por semanas enteras y como queremos hacer comparativos nos puede interesar especificar que semanas consideramos que son de un mes.\nAsí, en los datos que cargaremos, el mes de enero del 2018, empieza el día 1\u0026frasl;1 (lunes) y termina el día 27\u0026frasl;1 sábado, y el mes de febrero empieza el 28\u0026frasl;1 y termina el 24\u0026frasl;2. Es decir en nuestra empresa ficticia la semana comienza el domingo y termina el sábado siguiente (ambos inclusive). Excepto al principio del año, que empieza siempre el 1\u0026frasl;1 y termina el 31\u0026frasl;12.\nEn la tabla histventas tenemos una serie de acumulados para los periodos marcados por hve_fecini (fecha Inicio) y hve_fecfin (Fecha Final) y para una divisa dada.Esta tabla no tiene un indice único, pero buscaremos por los datos por esos 3 campos\nEsta tabla la llena un proceso automático del ERP, a través de las tablas de ventas, pero en este ejemplo no explicare como se llenan esos datos, sino que precargare unos datos en la propia aplicación, cuando se instancie la base de datos.\nEn la siguiente entrada, empezare con el programa de la parte del servidor, pero podéis echarle un vistazo al código en https://github.com/chuchip/yagesserver.git\n\u0026nbsp;\n¡¡ Nos vemos pronto!!\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/27/testeando-las-aplicaciones/",
	"title": "Testeando las aplicaciones",
	"tags": ["java", "junit", "mvc", "test"],
	"description": "",
	"content": "En una próxima entrada hablare sobre como testear las aplicaciones con pruebas unitarias. Bueno, mostrare como lo hago en mi código.\nDe momento, viendo que alguien ya la ha hecho antes (y seguramente mejor) dejo este enlace como aperitivo.\nhttps://platzi.com/jee/tutoriales/pruebas-usando-junit-mockito-y-mockmvc/\nEsta serie de videos hablando de JUnit de Makigas también servirán aclarar ideas y conocer lo básico de JUNIT, el cual es practicamente imprescindible para testear las aplicaciones.\n\nNos vemos en la siguiente entrada.\n"
},
{
	"uri": "http://ww2.profesor-p.com/contacto/experiencia_laboral/",
	"title": "Experiencia Laboral",
	"tags": ["experiencia"],
	"description": "Experiencia laboral",
	"content": "Tengo más de 30 años de experiencia en el mundo de la informática. Empece en los años 80 como freelance, realizando videojuegos, usando ensamblador como lenguaje de programación. A partir de ahí he trabajado de analista, administrador de sistemas y DBA.\nSoy miembro de grupos como AULIR (Asociacion Usuarios de Linux de La Rioja), y GDG (Google Developer Group). La informática es mi trabajo y, ademas, mi pasión, por lo cual siempre he estado y estoy aprendiendo múltiples lenguajes y tecnologías de forma autodidacta.\nTengo amplia experiencia como programador, administrador de sistemas y administrador de bases de datos. En está pagina pueden ver un resumen de los lenguajes en los que he programado y en esta otra, mi experiencia como administrador de sistemas. Para terminar,estas son las bases de datos que he administrado.\nEste es un resumen de mi curriculum en orden cronológico:\n 1989-1992  Programación de un ERP completo en Informix 4GL, migrando la solución ya existente en Cobol. 1992-1996 Desarrollo de una gestión completa en Dbase compuesta de almacén, facturación, control de comerciales y caja. Al cabo de 2 años se migra el programa a Visual Dbase 5\nEn VisualBasic realizo una serie de programas de control de presencia.\n 1996 \u0026#8211; 1999 Migración y mejora del antiguo ERP de Informix 4GL a Java, usando Swing. Se diseña todo un framework propio.\n 1999 \u0026#8211; 2003 Realizar labores de administrador de Unix (Solaris) y base datos Informix.\nAnalista-Programador en Java, utilizando tanto entorno Web (JSP) como Swing para entorno gráfico.\nAdministrar servidores de correo (sendmail y qmail), DNS (bind), radius, firewall,etc.\n 2004 \u0026#8211; 2010 Administrador de un cluster en HP-UX. Administrador de sistemas Linux (CENTOS y Suse)\nMantenimiento y configuración de los servicios Web (Apache), Tomcat, Postfix, Antivirus,\nAntiSpam, DNS y el Firewall\nAdministrador de la base de datos principal del Hospital de Calahorra implementada en Informix, ademas de bases de datos Oracle\n(versión 9 y 10), Postgres y Mysql, que se utilizan en diferentes áreas del hospital.\n 2010 – 2016 Teniendo como cliente final al servicio riojano de Salud (SERIS), mi labor es de administrador de Sistemas, dedicándome especialmente al mundo Linux y base de datos\nrelacionales (Informix, Oracle, SQLServer, etc.). Trabajo con VMWARE como entorno de virtualización.\nConfiguración e instalación de diversos servicios (Servidores Web, Samba, LDAP, Tomcat, SVN, etc).\nConfiguración entorno de escritorios remotos usando Citrix.\nConfiguración y mantenimiento de sistemas de almacenamientos (EVAS y 3PAR) así como su correspondiente electrónica de red.\n 2016 \u0026#8211; 2018 Analista/ Programador, en Java. Realización de un ERP completo, enfocado a la trazabilidad. Administrador de sistemas.\n 2018 \u0026#8211; Actual Analista / Programador de Java en GFI España.\n  "
},
{
	"uri": "http://ww2.profesor-p.com/2019/03/01/uso-de-perfiles-en-testing-en-spring-boot/",
	"title": "Uso de perfiles para testear en Spring Boot",
	"tags": ["java", "profiles", "spring boot"],
	"description": "",
	"content": "Como comentaba en el articulo anterior gracias al uso de perfiles es fácil personalizar las aplicaciones en Spring Boot.\nUno de los casos mas habituales del uso de perfiles es para testear la aplicación. Partiendo del mismo código fuente anterior, que os recuerdo esta en https://github.com/chuchip/profilestest vamos a ver el uso de los perfiles en testing.\nMirando el código de la clase ProfilesTestsTest.java\n@Profile(\u0026quot;test\u0026quot;) @SpringBootTest(webEnvironment= WebEnvironment.RANDOM_PORT) @ActiveProfiles(\u0026quot;test\u0026quot;) @RunWith(SpringRunner.class) public class ProfilesTestsTest { @Value(\u0026quot;${app.ID}\u0026quot;) int id; @Autowired IRead read; @Autowired Environment env; @Test public void inicio() { String name=read.readRegistry(id); assertEquals(name,\u0026quot;test\u0026quot;); String principal=env.getProperty(\u0026quot;app.principal\u0026quot;,\u0026quot;NULL\u0026quot;); assertNotEquals(principal,\u0026quot;profe\u0026quot;); String test=env.getProperty(\u0026quot;app.test\u0026quot;,\u0026quot;NULL\u0026quot;); assertEquals(test,\u0026quot;test\u0026quot;); } }  nos debemos de fijar en la etiqueta @ActiveProfiles(\u0026#8220;test\u0026#8221;) con ella indicamos a Spring que active el perfil test con lo cual ahora solo se procesaran las clases que tengan la etiqueta @Profile(\u0026#8220;test\u0026#8221;) o no tengan ninguna etiqueta @Profile.\nComo se puede ver en el directorio de test, también incluimos la clase ReadTestImpl.java que es exactamente igual que la existente en el paquete com.profesorp.profiletest.impl.def pero con la etiqueta @Profile(\u0026#8220;test\u0026#8221;).\nEn el directorio resources de test (profilestest/src/test/resources/) encontramos el fichero application.properties que usara Spring Boot  cuando se lance el test, pues como hemos comentado ese fichero se ejecuta siempre, sin importar el perfil activo. Sin embargo no procesara el fichero application.properties general.\nPara demostrarlo en el fichero \u0026#8220;/profilestest/src/main/resources/application.properties\u0026#8221; se ha incluido la linea\napp.principal=principal Y en \u0026#8220;/profilestest/src/test/resources/application.properties\u0026#8221; están las siguientes lineas\napp.ID=3 app.test=test En el test podemos ver como no encuentra la variable de entorno app.principal pero si que encuentra la variable app.test\nY esto es todo por esta entrada. Espero que haya servidor para aclarar un poco más el uso de perfiles (profiles) en Spring Boot.\n¡¡ Hasta la próxima !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/30/spring-webflow-con-jsp/",
	"title": "Spring WebFlow con JSP",
	"tags": ["bootstrap", "java", "mvc", "seguridad", "spring", "tomcat", "webflow"],
	"description": "",
	"content": "En el articulo anterior http://www.profesor-p.com/2018/10/29/spring-webflow-con-jsp-configuracion/ explicaba como configurar el programa para que Spring WebFlow funcionara. En este articulo explicare como hacer el flujo en si.\nLa página principal del programa no esta dentro de ningún flujo y sus peticiones son respondidas por Spring MVC, en la clase MyController, la cual podemos encontrar en el paquete profesorp.webflow.controller. Esta clase anotada con la etiqueta @Controller responde en la función indice1 a las peticiones de los recursos \u0026#8220;/\u0026#8221; e \u0026#8220;index\u0026#8221;\nAquí podéis ver el código:\n@RequestMapping(value = {\"/\", \"index\"}) public ModelAndView indice1(ModelAndView mod) { logger.info(\"request index\"); mod.addObject(\"cliente\", cliente); mod.setViewName(\"index\"); return mod; } Como veis devuelve un objeto ModelAndView donde guarda el objeto cliente, la cual es una @entity de la tabla Clientes, que ya vimos en la entrada anterior. La vista devuelta es \u0026#8220;index.jsp\u0026#8221; que esta en el directorio webapp/WEB-INF/jsp/\nEn \u0026#8220;index.jsp\u0026#8221; encontramos la etiqueta  que esta dentro del paquete spring-security-taglibs. Si el usuario no esta autentificado mostrara la pantalla de login, en caso contrario saludara al usuario y permitirá realizar el traspaso de dinero.\nAl usar el paquete security, y para evitar ataques CSRF, Spring solo permite realizar peticiones tipo POST, al recurso /logout. Por ello uso la librería JQuery con la cual creo esa petición en la función de javascript function post(path, parameters)\nEn todas las peticiones tipo POST debemos incluir la variable _csrf.parameterName con el valor _csrf.token para evitar estos mismos ataques CSRF. Si no las ponemos Spring Security no aceptara nuestras peticiones, pues entenderá que es un posible ataque.\n\u0026lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/\u0026gt; Esta es la pantalla de entrada , solicitando las credenciales.\nY está, la pantalla de entrada , una vez el usuario esta registrado.\nSi pulsamos el enlace \u0026#8220;Transferencia\u0026#8221; iremos al recurso \u0026#8220;traspaso\u0026#8221; que estará ubicado en la URL http://localhost:8080/webflow/traspaso. Este recurso es tratado por Spring Webflow, por lo cual se cargara el fichero WEB-INF/flows/traspaso/traspaso.xml pues así lo definimos en la clase WebFlowConfig anteriormente vista.\nTodo fichero XML que defina un webflow deberá empezar con las siguientes lineas.\n\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"\u0026gt;  A continuación defino la variable traspasoBean con una nueva instancia del objeto profesorp.webflow.controller.TraspasoBean.\n\u0026lt;var name=\"traspasoBean\" class=\"profesorp.webflow.controller.TraspasoBean\"/\u0026gt; Esta sentencia seria el equivalente al código java \u0026lt;strong\u0026gt;traspasoBean = new profesorp.webflow.controller.TraspasoBean()\u0026lt;/strong\u0026gt;\nSeguidamente. indico que al cargar el flujo de trabajo debe evaluar la expresión logicaService.getCliente() cuyo resultado debe guardar en la variable cliente, la cual sera de ámbito flow (flowScope.cliente). Una explicación de los ámbitos la tenéis en la pagina oficial de Spring (en ingles me temo). Baste decir, de momento que una variable definida dentro del ámbito flowscope es accesible en todas las paginas que estén definidas en nuestro flujo.\n\u0026lt;on-start\u0026gt; \u0026lt;evaluate expression=\"logicaService.getCliente()\" result=\"flowScope.cliente\" /\u0026gt; \u0026lt;/on-start\u0026gt; Tener en cuenta que para poder acceder al objeto logicaService lo hemos tenido que definir como un Bean en nuestro programa. En este ejemplo lo tenéis en la clase LogicaService, que muestro a continuación.\npackage profesorp.webflow.services; @Service @SessionScope public class LogicaService { .... Clientes cliente; ... public Clientes getCliente() { return cliente; } } A continuación indico la primera vista que se debe cargar, que sera el fichero cuentaOrigen.jsp\n\u0026lt;view-state id=\"cuentaOrigen\" model=\"traspasoBean\"\u0026gt; \u0026lt;on-render\u0026gt; \u0026lt;evaluate expression=\"logicaService.getCuentasByCliente()\" result=\"flowScope.cuentas\" /\u0026gt; \u0026lt;/on-render\u0026gt; \u0026lt;transition on=\"activate\" to=\"importe\"/\u0026gt; \u0026lt;/view-state\u0026gt; Con el parámetro model especifico las variables que reciba de la vista, deberán ser puestas en el objeto traspasoBean.\nComo en la vista definimos la variable cuentaOrigen (en un campo tipo select),y el bean profesorp.webflow.controller.TraspasoBean tiene a su vez la variable cuentaOrigen definida, se llamara a la función setCuentaOrigen() de esa clase, con el valor introducido , por el usuario en la vista.\nSi tuviéramos más variables en el formulario que coincidieran con sus correspondientes setters, también serian llamadas.\nLa vista, que detallo a continuación, es un formulario bastante simple donde se pide el numero de cuenta origen:\n\u0026lt;form method=\"post\" action=\"${flowExecutionUrl}\"\u0026gt; \u0026lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/\u0026gt; \u0026lt;input type=\"hidden\" name=\"_eventId\" value=\"activate\"\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"etiqueta\" for=\"Cuenta\"\u0026gt;Elija Cuenta Origen: \u0026lt;/label\u0026gt; \u0026lt;select name=\"cuentaOrigen\"\u0026gt; \u0026lt;c:forEach items=\"${cuentas}\" var=\"item\"\u0026gt; \u0026lt;option value=\"${item}\"\u0026gt;${item}\u0026lt;/option\u0026gt; \u0026lt;/c:forEach\u0026gt; \u0026lt;/select\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"col \"\u0026gt; \u0026lt;input class=\"btn btn-primary\" type=\"submit\" value=\"Siguiente\" /\u0026gt; \u0026lt;/div\u0026gt;  \u0026lt;a class=\"nav-link\" href=\"${flowExecutionUrl}\u0026_eventId=cancel\"\u0026gt;Cancelar\u0026lt;/a\u0026gt; \u0026lt;/form\u0026gt; Así se ve la vista en el navegador\n![](/img/2018/10/Captura-25.png(\nLo primero es ver como la URL a llamar por el formulario es el resultado de la variable ${flowExecutionUrl}. Esta variable es puesta automáticamente por Spring WebFlow y apuntara a la dirección donde continuara el flujo actual.\nLa variable \u0026#8220;_eventId\u0026#8221; es la que Spring WebFlow buscara para decidir que acción llevar a cabo. En este caso le asigno el valor \u0026#8220;activate\u0026#8221; que coincide con el valor de la etiqueta transition \u0026lt;transition on=\u0026quot;activate\u0026quot; to=\u0026quot;importe\u0026quot;/\u0026gt; \nCon esto lo que hacemos es configurar que cuando la variable _eventId tenga el valor \u0026#8220;activate\u0026#8221; el flujo vaya al ID importe. Por supuesto, el ID deberá existir en nuestro flujo.\nAclarar que \u0026#8220;activate\u0026#8221; es un literal libre, que igual podria ser \u0026#8216;MI_SALIDA\u0026#8216; o \u0026#8216;SEGUIR\u0026#8216;.\nLo normal, en una vista, es que pueda devolver diferentes valores. Así en la ultima linea donde declaramos un enlace () vemos como se llama a ${flowExecutionUrl} pasando el parámetro _eventId=cancel . En el caso de que pulsemos ese enlace lo que se ejecutara sera el siguiente código que esta al final del fichero traspaso.xml\n\u0026lt;global-transitions\u0026gt; \u0026lt;transition on=\"cancel\" to=\"cancel\" /\u0026gt; \u0026lt;/global-transitions\u0026gt; Esto es así porque hemos definido que cualquier evento tipo \u0026#8220;cancel\u0026#8221; dentro del flujo, llame al ID cancel del que luego hablare.\n\u0026lt;evaluate expression=\"logicaService.getCuentasByCliente()\" result=\"flowScope.cuentas\" /\u0026gt; La etiqueta  hace que lo que haya dentro se ejecute justo antes de renderizar la vista. En este caso llamara a la función logicaService.getCuentasByCliente()y el valor devuelto lo almacenara en flowScope.cuentas\npublic Iterable\u0026lt;String\u0026gt; getCuentasByCliente() { return cuentasClientesRepository.findCuentasByCliente(cliente.getId()); } Este objeto cuentas que es un Array de strings que se usa en la vista para crear el desplegable con las cuentas de origen disponibles, en el código \u0026lt;c:forEach items.....\u0026gt;\nLo siguiente define la vista con ID importe, que es donde ira el usuario cuando pulse el botón siguiente, como hemos definido con las etiquetas \u0026lt;transition on=\u0026quot;activate\u0026quot; to=\u0026quot;importe\u0026quot;/\u0026gt; anteriores.\n\u0026lt;view-state id=\"importe\" model=\"traspasoBean\"\u0026gt; \u0026lt;on-render\u0026gt; \u0026lt;evaluate expression=\"false\" result=\"traspasoBean.puestoPeriodico\" /\u0026gt; \u0026lt;/on-render\u0026gt; \u0026lt;transition on=\"salir\" to=\"comprobarImporte\"\u0026gt; \u0026lt;evaluate expression=\"logicaService.hasCredit(traspasoBean)\" /\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/view-state\u0026gt; Como en la anterior vista, los valores introducidos en el formulario serán introducidos en traspasoBean, al incluirse la etiqueta model.\nAntes de mostrar la vista se llama a la función traspasoBean.puestoPeriodico() con el valor false debido a la etiqueta on-render.\nSi el valor de la variable \u0026#8220;_eventId\u0026#8221; es \u0026#8220;salir\u0026#8221; el flujo sera dirigido al ID comprobarImporte, pero antes de ir se llamara a la función logicaService.hasCredit(traspasoBean). Si esa función devuelve true se realizara el salto a comprobarImporte en caso contrario se volvera a mostrar la vista actual, es decir importe.\nLa vista importe esta definida en el fichero importe.jsp del cual pongo un extracto a continuación\n\u0026lt;form method=\"post\" action=\"${flowExecutionUrl}\"\u0026gt; \u0026lt;input type=\"hidden\" name=\"${_csrf.parameterName}\" value=\"${_csrf.token}\"/\u0026gt; \u0026lt;input type=\"hidden\" name=\"_eventId\" value=\"salir\"\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"etiqueta\" for=\"CuentaOrigen\"\u0026gt;Cuenta Origen \u0026lt;/label\u0026gt; \u0026lt;input type=\"text\" name=\"cuentaOrigen\" value=\"${traspasoBean.cuentaOrigen}\" disabled \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"etiqueta\" for=\"Importe\"\u0026gt;Introduzca Importe \u0026lt;/label\u0026gt; \u0026lt;input type=\"text\" class=\"importe\" name=\"importe\" value=\"${traspasoBean.importe}\" placeholder=\"Importe Traspaso\" required\u0026gt; \u0026lt;c:if test=\"${traspasoBean.getMsgImporte()!=null}\"\u0026gt; \u0026lt;div class=\"alert alert-warning\"\u0026gt; \u0026lt;strong\u0026gt;Atencion!\u0026lt;/strong\u0026gt; ${traspasoBean.getMsgImporte()} \u0026lt;/div\u0026gt; \u0026lt;/c:if\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"etiqueta\" for=\"CuentaDestino\"\u0026gt;Cuenta Destino \u0026lt;/label\u0026gt; \u0026lt;input type=\"text\" name=\"cuentaFinal\" value=\"${traspasoBean.cuentaFinal}\" \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"form-group\"\u0026gt; \u0026lt;label class=\"etiqueta\" for=\"Periodico\"\u0026gt;Traspaso Periodico\u0026lt;/label\u0026gt; \u0026lt;input type=\"checkbox\" name=\"periodico\" value=\"true\" \u0026lt;c:if test=\"${traspasoBean.periodico}\"\u0026gt; checked \u0026lt;/c:if\u0026gt; \u0026gt; \u0026lt;/div\u0026gt; \u0026lt;div class=\"col\"\u0026gt; \u0026lt;input class=\"btn btn-primary\" type=\"submit\" value=\"Siguiente\" /\u0026gt;\u0026nbsp; \u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; Resaltar que como la variable periodico esta en un campo checkbox solo sera mandada cuando el usuario seleccione esa opción, por lo cual si no es marcada, la funcion setPeriodico() no sera llamada, pero no se pondrá a false la correspondiente variable en el Bean. Es por ello que antes de mostrar la vista, con la etiqueta \u0026lt;on-render\u0026gt; se pone a false una variable auxiliar que utilizara el programa para saber que no se ha seleccionado la opción \u0026#8220;Traspaso Periódico\u0026#8220;\nUna imagen de como se muestra la vista en el navegador.\nEl id comprobarImporte se define a continuación,\n\u0026lt;decision-state id=\"comprobarImporte\"\u0026gt; \u0026lt;if test=\"logicaService.checkImporte(traspasoBean)\" then=\"periocidad\" else=\"importe\"/\u0026gt; \u0026lt;/decision-state\u0026gt; En este estado que es tipo decisión, se llama a la función checkImporte(traspasoBean) del objeto logicaService en caso de que devuelva true se ira al ID periocidad, en caso contrario se volverá al ID importe . Esta función comprueba que el cliente tenga suficiente dinero en la cuenta.\nEl ID periocidad es otro estado tipo decisión que dependiendo del resultado de la función isPeriodico, la cual comprueba si se ha selecionado la opción \u0026#8220;Traspaso Periodico\u0026#8221; en la vista, ira a periodico o a confirmar\n\u0026lt;decision-state id=\"periocidad\"\u0026gt; \u0026lt;if test=\"logicaService.isPeriodico(traspasoBean)\" then=\"periodico\" else=\"confirmar\"/\u0026gt; \u0026lt;/decision-state\u0026gt; \u0026lt;subflow-state id=\"periodico\" subflow=\"traspaso_time\"\u0026gt; \u0026lt;input name=\"traspasoBean\" /\u0026gt; \u0026lt;transition on=\"salir\" to=\"confirmar\"\u0026gt; \u0026lt;/transition\u0026gt; \u0026lt;/subflow-state\u0026gt; El ID periodico es una llamada al flujo traspaso_time, al cual se saltara pasándole el objeto traspasoBean debido a la etiqueta input.\nSi ese flujo sale con el ID salir se saltara al ID confirmar\nA continuación detallo el contenido del flujo traspaso_time que esta definido en el fichero traspaso_time.xml\n\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;flow xmlns=\"http://www.springframework.org/schema/webflow\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/webflow http://www.springframework.org/schema/webflow/spring-webflow.xsd\"\u0026gt; \u0026lt;input name=\"traspasoBean\" required=\"true\" /\u0026gt; \u0026lt;view-state id=\"tiempo\" model=\"traspasoBean\"\u0026gt; \u0026lt;transition on=\"salir\" to=\"salir\"/\u0026gt; \u0026lt;transition on=\"cancelar\" to=\"cancel\" /\u0026gt; \u0026lt;/view-state\u0026gt; \u0026lt;end-state id=\"salir\" /\u0026gt; \u0026lt;end-state id=\"cancel\" /\u0026gt; \u0026lt;/flow\u0026gt; Lo primero que declaramos es que debemos recibir un objeto traspasoBean . Si no lo recibieramos el programa fallara.\nEs decir el flujo lo podríamos llamar con la URL: http://localhost:8080/webflow/traspaso_time pero si lo hacemos al no recibir el objeto traspasoBean  fallara.\nEn el flujo mostramos la vista tiempo y si el _eventid es salir se saltara al ID salir.\nEste ID es tipo end-state por lo cual se volverá al anterior flujo con el ID salir. En el flujo traspaso entonces se saltara al ID confirmar, como esta definido por la etiqueta: \u0026lt;transition on=\u0026quot;salir\u0026quot; to=\u0026quot;confirmar\u0026quot;\u0026gt; \nSi el _eventid es cancelar también volverá al flujo anterior, pero a través del ID cancel y por lo tanto se saltara al ID cancel , como se definió con las etiquetas anteriormente mostradas.\n\u0026lt;global-transitions\u0026gt; \u0026lt;transition on=\"cancel\" to=\"cancel\" /\u0026gt; \u0026lt;/global-transitions\u0026gt; La vista tiempo se muestra así en el navegador.\nPor último la vista confirmar, muestra todos los datos introducidos y solicita la confirmación. En caso de darla se ira al ID salir con lo cual saldremos del flujo redirigiendonos al recurso index pasando la variable transferencia  con el valor \u0026#8220;1\u0026#8221;. En caso de que en algún momento hayamos cancelado la transferencia se saldrá del flujo dirigiéndonos a index pero la variable transferencia tendrá el valor \u0026#8220;0\u0026#8221;\n\u0026lt;view-state id=\"confirmar\"\u0026gt; \u0026lt;transition on=\"salir\" to=\"salir\"/\u0026gt; \u0026lt;/view-state\u0026gt; \u0026lt;end-state id=\"salir\" view=\"externalRedirect:./index?transferencia=1\" /\u0026gt; \u0026lt;end-state id=\"cancel\" view=\"externalRedirect:./index?transferencia=0\" /\u0026gt; Esto se nos mostrara en pantalla una vez hayamos confirmado la transferencia\nY con esto termino esta entrada tan larga, pero donde creo que he explicado bastantes conceptos de WebFlow.\nComo siempre, espero vuestros comentarios y mejoras, con la esperanza de haberme explicado bien.\n¡¡ Hasta otra, alumnos!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/14/aplicacion-en-angular-inicializando/",
	"title": "Angular - Inicializando",
	"tags": ["angular", "angular 6", "frontend", "html"],
	"description": "",
	"content": "Continuando con la entrada donde instalaba Angular, seguimos desarrollando la aplicación que detallo en esta página.\nUna vez tenemos creado el esqueleto de nuestro programa, con el comando \u0026#8220;ng new\u0026#8221; ,  entraremos al directorio src. En este directorio es donde realmente vamos a trabajar.\nLos demás directorios son donde están las librerías y utilidades que nuestra aplicación usara pero que son propias de Angular y nosotros no las tocaremos (al menos en este ejemplo).\nPrimero vamos a explicar los pasos que sigue Angular para ejecutar nuestra recién creada aplicación.\nCuando ejecutamos el comando \u0026#8220;ng serve \u0026#8211;open\u0026#8221; desde nuestro directorio yagesclient,Angular, una vez que ha compilado, comprobado dependencias y otra serie de tareas, en las que no voy a entrar, lee el fichero src/main.ts, el cual detallo a continuación.\nsrc/main.ts\nimport { enableProdMode } from '@angular/core'; import { platformBrowserDynamic } from '@angular/platform-browser-dynamic'; import { AppModule } from './app/app.module'; import { environment } from './environments/environment'; if (environment.production) { enableProdMode(); } platformBrowserDynamic().bootstrapModule(AppModule) .catch(err =\u0026gt; console.log(err)); En este fichero se importan (import) es decir, se cargan una serie de ficheros para después arrancar nuestra aplicación. con la ultima linea:\nplatformBrowserDynamic().bootstrapModule(AppModule) .catch(err =\u0026gt; console.log(err)); Como se puede intuir este comando ejecuta una función, a la que se le pasa el parámetro AppModule. No voy a entrar a explicar los detalles , pues se escapa al ámbito de este curso, lo que voy a explicar es donde definimos ese parámetro AppModule .\nLa clave esta en la linea:\nimport { AppModule } from './app/app.module'; Ahí importamos ese parámetro, especificando que lo debe cargar del fichero \u0026#8220;./app/app.module.ts\u0026#8221;. La extensión ts (TypeScript) la pone Angular pues busca un fichero de ese tipo, pero nosotros no debemos ponerlo.\nEn este fichero están definidos los módulos de nuestra aplicación.\nEl contenido del fichero es el siguiente:\nsrc/app/app.module.ts\nimport { BrowserModule } from '@angular/platform-browser'; import { NgModule } from '@angular/core'; import { AppComponent } from './app.component'; @NgModule({ declarations: [ AppComponent ], imports: [ BrowserModule, ], providers: [], bootstrap: [AppComponent] }) export class AppModule { } Este fichero define un modulo, porque así se lo especificamos a Angular con la etiqueta @NgModule. El modulo se llamara AppModule, que no deja de ser una clase u objeto, que exportamos a la vez que creamos, con la sentencia:\nexport class AppModule { } Esta clase AppModule es el objeto que importábamos en nuestro anterior fichero con la linea import { AppModule } from \u0026#8216;./app/app.module\u0026#8217; \nEl nombre de la clase podría haber sido perfectamente miMaravillosaClase con lo cual habríamos puesto:\nexport class miMaravillosaClase { } Y en el import seria **import { miMaravillosaClase } from \u0026#8216;./app/app.module\u0026#8217;\n**\nLo que quiero resaltar es que el nombre de la clase no debe coincidir con el del fichero ni tiene porque acabar en Module, sin embargo, por claridad en el código y buenas practicas los módulos siempre se terminan con Module y coincide el nombre del modulo con la del fichero.\nVolviendo al fichero /app/app.module.ts, centrémonos en el siguiente import.\nimport { AppComponent } from './app.component'; Donde importamos el componente AppComponent . Este componente esta definido en el fichero \u0026#8216;./app.component.ts\u0026#8217;\nsrc/app/app.component.ts\nimport { Component } from '@angular/core'; @Component({  selector: 'app-root',  templateUrl: './app.component.html', styleUrls: ['./app.component.css'] }) export class AppComponent { title = 'Cliente de Aplicacion de prueba'; } Aquí definimos un componente (obsérvese la etiqueta @Component) que sera una clase llamada AppComponent anteriormente importada.\nCon la etiqueta selector indicamos como llamaremos a este componente en nuestros fichero HTML (en la parte de la vista, vamos). Es decir, se llamara app-root.\nCon templateUrl indicaremos el fichero html a cargar cuando pongamos la etiqueta app-root en algun otro fichero html que Angular ya haya cargado (index.html en nuestro ejemplo). Con styleUrls indicaremos la hoja de estilo a cargar para el anterior fichero html.\nUn componente en angular no es sino una objeto que nosotros definimos. Ese objeto tendrá un código HTML, su hoja de estilos (CSS) y por supuesto JavaScript.\n¿ JavaScript ?. Sí, porque aunque en angular nosotros usamos TypeScript, a la hora de compilar el programa, ese código se convertirá en JavaScript, que es el lenguaje que entienden los navegadores (Chrome, Firefox, Opera, IE, etc).  Nuestra aplicación, como vemos, ya tiene su primer _componente _creado, el objeto AppComponent, y este componente es usado por el fichero index.html, del cual enseñamos una versión simplificada a continuación.\n/src/index.html\n\u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\"en\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\"utf-8\"\u0026gt; \u0026lt;title\u0026gt;Yagesclient\u0026lt;/title\u0026gt; \u0026lt;base href=\"/\"\u0026gt; \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1\"\u0026gt; \u0026lt;link rel=\"icon\" type=\"image/x-icon\" href=\"favicon.ico\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;app-root\u0026gt;\u0026lt;/app-root\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Como se puede ver es un fichero HTML casi normal. Lo único que nos debe llamar la atención es la etiqueta:\n . ¿ Os suenan ?. Exacto, son las que hemos definido con el parámetro selector: \u0026#8216;app-root\u0026#8217;.\nResumiendo, cuando Angular ejecute nuestra aplicación cargara el fichero index.html y cuando encuentre las etiqueta  sabrá que debe incluir el componente definido en el fichero src/app/app.component.ts.\nLo que incrustara sera el contenido del fichero html definido en la anteriormente citada etiqueta templateUrl, ademas de instanciar (crear) el objeto AppComponent.\nSin entrar en detalles, para ver la relación entre la clase y el fichero HTML, o dicho de otra manera, la relación vista / controlador, obsérvese que dentro de la clase AppComponent se crea la variable title asignándole el valor \u0026#8221;Cliente de Aplicacion de prueba\u0026#8216;. Como en el fichero src/app.component.html tenemos solo la siguiente linea\nEsto es el titulo {{ title }} El código  del fichero index.html sera sustituido por:\nEsto es el titulo Cliente de Aplicacion de prueba Y con esto termino esta entrada, en la próxima hablare de las rutas. Espero haberme explicado bien. En caso contrario no dudéis en realizar todas las preguntas necesarias.\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/03/aplicacion-en-spring-rest-y-angular-2-parte/",
	"title": "Backend (II)",
	"tags": ["java", "jndi", "json", "rest", "spring", "spring boot", "tomcat"],
	"description": "",
	"content": "En esta segunda parte voy a empezar a explicar como hacer la parte del servidor, usando, como dije en la primera parte de este articulo utilizare JAVA 8, apoyándome en el framework Spring, versión 5.\nEsta aplicación la he realizado con NetBeans 9, usando Tomcat 9 como servidor de aplicaciones. La podía haber realizado usando Spring Boot, lo que habría realizado más fácilmente y con menos configuración pero he querido hacerlo con Tomcat como ejercicio.\nEsta el código fuente en: https://github.com/chuchip/yagesserver\nEstos serán los archivos usados en mi aplicación:\nLas dependencias, aparte de las básicas de Spring, son tener las siguientes librerías , de H2 Database e Hibernate.\ndependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;!-- Jackson (JSON) --\u0026gt; \u0026lt;artifactId\u0026gt;jackson-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.core\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;jackson-databind\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.9.6\u0026lt;/version\u0026gt; \u0026lt;/dependedncy\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!-- H2 DATABASE --\u0026gt; \u0026lt;groupId\u0026gt;com.h2database\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;h2\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.197\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!-- LOMBOK --\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.2\u0026lt;/version\u0026gt; \u0026lt;scope\u0026gt;provided\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;!-- HIBERNATE --\u0026gt; \u0026lt;groupId\u0026gt;org.hibernate\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;hibernate-agroal\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;5.3.5.Final\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;/dependency\u0026gt; Para más detalles y otras librerías menores, mirar el fichero pom.xml del proyecto.\nEn este ejemplo no uso anotaciones XML, , todo se hace con anotaciones Java. Esta es el fichero con que se configura la base de datos.\n@Configuration @EnableJpaRepositories(\"yages.yagesserver\") @EnableTransactionManagement public class JpaConfig { @Bean public DataSource dataSource() { EmbeddedDatabaseBuilder builder = new EmbeddedDatabaseBuilder(); EmbeddedDatabase db = builder .setType(EmbeddedDatabaseType.H2) .setName(\"yagesh2\") .ignoreFailedDrops(true) .addScript(\"db/sql/create-db.sql\") .addScript(\"db/sql/insert-data.sql\") .generateUniqueName(false) .build(); return db; } @Bean public HibernateExceptionTranslator hibernateExceptionTranslator() { return new HibernateExceptionTranslator(); } @Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory(DataSource dataSource) throws NamingException { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(dataSource()); em.setPackagesToScan(new String[]{\"yages.yagesserver\", \"yages.yagesserver.dao\"}); em.setPersistenceUnitName(\"yages-server\"); em.setJpaVendorAdapter(jpaVendorAdapter()); em.afterPropertiesSet(); return em; } @Bean public JpaVendorAdapter jpaVendorAdapter() { HibernateJpaVendorAdapter jpaVendorAdapter = new HibernateJpaVendorAdapter(); jpaVendorAdapter.setGenerateDdl(false); jpaVendorAdapter.setDatabase(Database.H2); jpaVendorAdapter.setShowSql(false); return jpaVendorAdapter; } @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory emf) { JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(emf); return transactionManager; } } La configuración es una típica para cualquier base de de datos. Lo único destacable es el uso de la clase EmbeddedDatabaseBuilder , en la función dataSource. Esta clase es muy útil para crear una base de datos embebida del tipo H2, HSQL o incluso DERBY. Como se ve en el código el uso es tan simple como especificar el tipo de base de datos, y después añadir los scripts necesarios (en este caso el de creación de las tablas y el de carga de datos). Esto nos creara un objeto EmbeddedDatabase que implementa el interface DataSource. Observerse que los ficheros create-db.sql e insert-db.sql, contienen sentencias SQL puras.**\n**\ncreate table calendario ( cal_ano int, -- Año cal_mes int, -- Mes cal_fecini date, -- Fecha Inicial cal_fecfin date, -- Fecha Final. constraint ix_calendario primary key (cal_ano,cal_mes) ); ...... NSERT INTO calendario (cal_ano,cal_mes,cal_fecini,cal_fecfin) VALUES (2018,1,{d '2018-01-01'},{d '2018-01-27'}); INSERT INTO calendario (cal_ano,cal_mes,cal_fecini,cal_fecfin) VALUES (2018,2,{d '2018-01-28'},{d '2018-02-24'}); ....... Estos dos ficheros, deberán estar ubicados en la carpeta de resources (es decir, en el classpath)\nUna vez que tenemos nuestro objeto DataSource ya solo resta crear nuestro EntityManager en la función entityManagerFactory, apoyándonos en las demás funciones de la clase.\nAhora creare las clases que representan los objetos de la base de datos, estos objetos están en la carpeta:\n ### Implementando nuestras tablas **como objetos.   **\nEn el paquete yages.yagesserver.model tendremos las siguientes clases:\nCalendario.java \n@Entity @Table(name=\"calendario\") @NoArgsConstructor @Data public class Calendario implements Serializable{ private static final long serialVersionUID = 1L; @Column(name = \"cal_fecini\",nullable = false) @Temporal(javax.persistence.TemporalType.DATE) private Date fechaInicio; @Column(name = \"cal_fecfin\",nullable = false) @Temporal(javax.persistence.TemporalType.DATE) private Date fechaFinal; @Transient private Date fechaFinalSemana; @EmbeddedId private CalendarioKey calendarioKey; public Calendario(int ano,int mes,Date fecInicio,Date fecFinal) { calendarioKey = new CalendarioKey(ano,mes); setFechaInicio(fecInicio); setFechaFinal(fecFinal); } } CalendarioKey.java\n@Embeddable @Data @AllArgsConstructor @NoArgsConstructor public class CalendarioKey implements Serializable { private static final long serialVersionUID = 2L; @Column (name=\"cal_mes\", nullable=false) private int mes; @Column (name=\"cal_ano\", nullable=false) private int ano; }  Como se puede ver son dos simples POJOS, con una serie de anotaciones para su uso con JPA.\nSolo destacar el uso de que como la tabla Calendario tiene un indice multiple, haremos uso de la anotación EmbebedId de tal manera que la clase Calendario sera una @Entity y la clase CalendarioKey , que tendra los campos mes y ano (año 😀 ) sera la que tenga el indice y estara marcada como @Embeddable.\nEn el paquete yages.yagesserver.dao creare mi repositoio crud con el siguiente interface:\npublic interface CalendarioRepository extends CrudRepository\u0026lt;yages.yagesserver.model.Calendario, yages.yagesserver.model.CalendarioKey\u0026gt; { } Para mas datos sobre este interface que nos hace la vida tan fácil, podéis mirar el siguiente articulo de mi página.\nEn la clase CalendarioRepositorioService creo mi clase auxiliar que hace uso del repositorio.\n@Service @Transactional public class CalendarioRepositorioService { @Autowired CalendarioRepository calendarioRepository; public Optional\u0026lt;Calendario\u0026gt; getCalendario(CalendarioKey calendarioKey) { return calendarioRepository.findById(calendarioKey); } public Iterable\u0026lt;Calendario\u0026gt; getAllCalendarios() { return calendarioRepository.findAll(); } } Observese como anoto la clase con la etiqueta @Service y @Transacional. Despues inyectamos el interface CalendarioRepository que es el que usare en las dos unicas funciones que tiene esta clase.\nLa tabla histVentas es prácticamente igual que la tabla calendario, también con un indice múltiple y la configuración es básicamente la misma, por lo cual no creo necesario explicarla.\nY por hoy ya vale. En la próxima entrada, veremos como implementar las peticiones REST\n¡¡ Hasta pronto!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/16/aplicacion-en-angular-rutas/",
	"title": "Angular – Rutas",
	"tags": ["angular", "angular6", "curso", "routes"],
	"description": "",
	"content": "Una vez he explicado en la anterior entrada como inicializa Angular la aplicación, voy a explicar como hacer para que esta pueda aceptar parámetros a través de la URL introducida en el navegador. Básicamente, lo que deseo hacer es que, suponiendo que nuestra aplicación este corriendo en http://localhost:4200/ (es la dirección por defecto en la que escucha Node.js cuando lo lanzamos con el comando ng serve ), si vamos a la dirección http://localhost:4200/2018  nos muestre las ventas del ejercicio 2018. A su vez, si vamos a la dirección http://localhost:4200/2018/3 nos deberá mostrara los datos del ejercicio 2018 y en el detalle los datos del mes 3. Es decir, el primer número sera el ejercicio y el segundo el mes. Si no se pone el segundo parámetro iremos al mes 1 del ejercicio mandado. En el caso de no poner ningún parámetro, el programa nos preguntara el ejercicio con el correspondiente formulario.\nEn Angular, las rutas se definen creando un fichero TypeScript, al que las buenas normas, nos aconsejan llamar app-routing.module.ts. Este fichero se dejara en el directorio src/app/.\nVeamos el fichero creado en nuestra aplicación:\n import { NgModule } from '@angular/core'; import { CommonModule } from '@angular/common'; import { RouterModule, Routes } from '@angular/router'; import {DatosEjercicioComponent} from './datos-ejercicio/datos-ejercicio.component'; const routes: Routes = [ {path: ':year', component: DatosEjercicioComponent }, {path: ':year/:month', component: DatosEjercicioComponent } ]; @NgModule({ imports: [ CommonModule, RouterModule.forRoot(routes) ], exports: [ RouterModule ], declarations: [] }) export class AppRoutingModule { }  Como se ve, lo primero tenemos una serie de imports que necesitaremos. A continuación declaramos una variable, a la que llamamos routes  (le podriamos haber llamado mis_rutitas_chulis pero es por ser serios 😛 ) y que es un array de objetos tipo Routes . En esa variable es donde vamos a definir nuestras rutas.\nAsí, el primer elemento del array tiene el elemento path cuyo valor es \u0026#8220;year\u0026#8221;, y el elemento component cuyo valor es: DatosEjercicioComponent. Esto, Angular lo traducirá por: cuando la URL tenga un único parámetro (year) carga el componente DatosEjercicioComponent. El especificar que es un parámetro lo hacemos con los dos puntos (\u0026#8220;:\u0026#8221;) antes de la palabra :year. Y el nombre de esa variable podremos capturarla y utilizarla en nuestro componente DatosEjercicioComponent.\nEn el caso de que la linea fuera:\n{path: '/paco', component: DatosEjercicioComponent }, Angular cargaría el componente indicado cuando fuéramos a la ruta http://localhost:4200/paco . Ojo, si la dirección fuera, otra, como http://localhost:4200/paco/el_guapo no funcionaria.\nAclarar, ademas, que DatosEjercicioComponent es el componente que hemos definido en la linea import {DatosEjercicioComponent} from \u0026#8216;./datos-ejercicio/datos-ejercicio.component\u0026#8217;. Si no tuvieramos ese import Angular nos daría un error.\nLa carga de la variable route, en el modulo de rutas de Angular se hace con la linea: RouterModule.forRoot(routes)\nHay maneras de cargar diferentes rutas para una misma aplicación, pero no vamos a hablar de ello en este curso.\nPara especificar que debe cargar el componente marcado por la ruta, debemos incluir en el código HTML la siguiente etiqueta: . Esa etiqueta incrustara el correspondiente componente de la ruta, como hacia la etiqueta  con el componente AppComponent en la anterior entrada.\nAhora veamos parte de nuestra clase datos-ejercicio.component.ts\nimport { ActivatedRoute, Router} from '@angular/router'; @Component({ selector: 'app-datos-ejercicio', templateUrl: './datos-ejercicio.component.html', styleUrls: ['./datos-ejercicio.component.css'] }) export class DatosEjercicioComponent { constructor( private route: ActivatedRoute, private router: Router, private _datosserver: DatosserverService) { } ngOnInit() { this.year = +this.route.snapshot.paramMap.get('year'); .... Como vemos, lo primero es importar los componentes para tratar rutas. Después especificamos que nuestra clase es del tipo componente con la etiqueta @Component para después definirla.\nLo primero que encontramos es la palabra constructor, con esa palabra definimos un tipo de función especial dentro de nuestra clase que sera llamada cuando el objeto sea creado. En nuestro ejemplo, cuando Angular encuentre la etiqueta  y deba cargar nuestra clase, lo primero que hará sera ejecutar el código existente en esa función.\nEn este caso, como veis, no hay nada dentro de la función, sin embargo si que recibe una serie de parámetros. Esas variables estarán disponibles dentro de nuestra clase, a nivel global. Eso es una característica de TypeScript, las variables recibidas en un constructor estarán disponibles para toda la clase y no solo dentro del constructor como ocurre en todos los demás tipos de funciones.\nEn la función ngOnInit, se le asigna a la variable global year el valor recibido por el componente de la ruta. Observése el símbolo más (+) . Esto convertirá el texto recibido en un número.\nLa función ngOnInit es una función especial de Angular y sera llamada una vez el componente a sido construido (o sea, después de llamar al constructor), pero antes de incrustarlo (por así decirlo) en la pantalla dentro del código HTML. Hay otra serie de funciones especiales que podéis consultar en la pagina oficial de Angular.\nY con esto termino esta entrada hablando sobre las rutas en Angular. Podéis profundizar más en este tema en la documentación oficial de Angular o visitando este otro excelente manual https://academia-binaria.com/paginas-y-rutas-angular-spa/\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/05/desarrollando-aplicaciones-java-ee-en-netbeans-9/",
	"title": "Desarrollando aplicaciones Java EE en NetBeans 9",
	"tags": ["java", "Java ee", "netbeans9", "tomcat"],
	"description": "",
	"content": "El recién salido NetBeans 9, es un excelente IDE, con soporte para Java 10 y 11, y con otra serie de características muy interesantes. Sin embargo, por temas de licencias con Oracle que es el dueño del antiguo NetBeans, solo tiene soporte para Java Standard Edition, no pudiendo, en teoría, hacer aplicaciones para Java EE.\nPero es solo en teoria, pues NetBeans 9, mantiene la compatibilidad con la versión 8.2, incluso a nivel de plugins. Así que podemos añadir las fuentes de la versión anterior y podremos crear aplicaciones Java EE.\nEso es tan simple como ir al menú Tools y elegir la opción Plugins. En la ventana de plugins, iremos a la pestaña settings y pulsaremos el botón Add. El cual nos mostrara la siguiente ventana:\nAhí pondremos rellenaremos los 2 campos, de esta manera:\n Name: NetBeans 8.2\nURL: http://updates.netbeans.org/netbeans/updates/8.2/uc/final/distribution/catalog.xml.gz\n Después, volveremos de darle al botón OK, volveremos a añadir una nueva entrada con estos datos:\n Name: Plugin Portal\nURL: http://plugins.netbeans.org/nbpluginportal/updates/9.0/catalog.xml.gz\n La pagina debe quedar como la siguiente.\nA partir de ahí, ya veremos que nos aparecen como disponibles muchos más plugins, entre los que veremos Java EE Base. Una vez instalado este plugin ya podremos realizar nuestras aplicaciones Java EE.\n¡¡¡ A seguir estudiando!!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/04/aplicacion-en-spring-rest-y-angular-3a-parte/",
	"title": "Backend  (III)",
	"tags": ["java", "rest", "spring", "tomcat"],
	"description": "",
	"content": "En esta entrada, continuare con la parte servidor, que ya comencé en el articulo anterior.\nVoy a desarrollar la parte donde se responden a las peticiones REST. Para el que no sepa que es eso de REST, podéis empezar leyendo este articulo de la wikipedia, pero os podeis quedar con la idea de que es como una petición web normal, solo que en vez de trabajar con paginas HTML enteras, se trabaja con intercambio de datos más o menos en crudo.\nEn este ejemplo, el codigo que trata esas peticiones esta en la clase: YagesController\n@RestController @RequestMapping(\"/rest\") public class YagesController { @Autowired private YagesBussines yagesBussines; @RequestMapping(value = \"/{anoId}\", method=RequestMethod.GET, produces=\"application/json\") public VentasAnoBean getAno(@PathVariable int anoId) { System.out.println(\"getAno.Año: \"+anoId); return yagesBussines.getVentasAno(anoId); } @RequestMapping(value =\"/{anoId}/{mesId}\", method=RequestMethod.GET,produces=\"application/json\") public ArrayList\u0026lt;VentasSemanaBean\u0026gt; getSemanas(@PathVariable int anoId,@PathVariable int mesId) { System.out.println(\"GetSemanas. Mes \"+mesId+\" Año: \"+anoId); return yagesBussines.getDatosSemana(mesId, anoId); } } Con solo este código vamos a ser capaces de responder a las peticiones.\nLo primero es anotar la clase como del tipo @RestContoller. Después especificamos la ruta que este controlador debe responder. Eso lo hago con la anotación @RequestMapping(\u0026#8220;/rest\u0026#8221;). Eso hará que todas las peticiones que vayan a la URL MIDOMINIO/MICONTEXTO/rest sean tratadas por esta clase.\nComo dije anteriormente un servidor REST, atiende peticiones HTTP, como son las que se utilizan habitualmente en un navegador web, y como cualquier petición web, siempre debe haber una URL (o dirección) de la página que debemos visitar. Así, cuando visitamos Google, en nuestro navegador ponemos la dirección: http://www.google.com. Pues bien, si nuestro servicio REST responde, por ejemplo en la pagina www.profesor-p.com, para interactuar con él deberíamos hacer una petición web (es decir visitar la pagina web) : http://www.profesor-p.com/rest/LO_QUE_SEA\n¿ Y que es entonces eso de MI_CONTEXTO ? . Bueno, es muy común que en un servidor de aplicaciones (Tomcat, por ejemplo) haya varias aplicaciones corriendo al mismo tiempo, sobre todo, para optimizar recursos. De esta manera si tenemos un servidor de Tomcat corriendo en la dirección www.servidor-profesorp.com, cuando queramos acceder a la aplicación de contabilidad pondremos: www.servidor-profesorp.com/contabilidad y si queremos acceder a la aplicación de nominas iremos a www.servidor-profesorp.com/nominas y así con las diferentes aplicaciones. Es decir todas las peticiones de la aplicación web de contabilidad responderán bajo el contexto de www.servidor-profesorp.com/contabilidad y todas las peticiones de la aplicación nominas responderán bajo el contexto de www.servidor-profesorp.com/nominas. A todos los efectos, la idea es como cuando se ejecuta una aplicación de escritorio en Windows, como puede ser Word, Excel o el Bloc de Notas, cada aplicación del escritorio tiene su propia ventana, pues en una aplicación web, cada una tiene su contexto o directorio donde responde a las peticiones.\nAclarar, que hay veces, que el contexto puede no existir en el caso de que solo tengamos una aplicación corriendo en esta dirección web o bien, porque es la dirección principal y no haga falta ponerla. En esos casos las peticiones REST serán respondidas en MIDOMINIO/rest.\nPara el resto del articulo vamos a suponer que nuestra aplicación esta respondiendo en la URL http://localhost:8080/yagesserver que es donde normalmente se realizan las pruebas. Localhost, como todo el mundo sabe, es la dirección interna del servidor (que sera probablemente tu ordenador personal en este ejemplo) donde se esta corriendo el programa. Y yaggesserver es el contexto donde responderá la aplicación.\nY como un ejemplo, vale más que mil palabras, aquí vemos un ejemplo de la una petición REST, haciendo uso de la función getAno() de la clase YagesController.\nY como esta entrada me esta quedando un poco larga, continuare con ella en un próximo articulo.\n¡¡ A seguir estudiando !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/05/aplicacion-en-spring-rest-y-angular-4a-parte/",
	"title": "Backend (IV)",
	"tags": ["java", "json", "rest", "spring", "tomcat"],
	"description": "",
	"content": " Continuo con la serie de artículos explicando una aplicación donde la parte de servidor esta creada con Java, apoyándose en el framework Spring y la parte del cliente usara Angular. Para la comunicación entre la aplicación usare peticiones REST, por supuesto utilizando el protocolo JSON.\nEn la anterior entrada empece a explicar como se desplegaría la aplicación y en que URLs se procesarían las diferentes peticiones. Ahora explicare como funcionan las diferentes peticiones.\nEn la clase YagesController es donde se hace toda la magia 😉\n@RestController @RequestMapping(\"/rest\") public class YagesController { @Autowired private YagesBussines yagesBussines; @RequestMapping(value = \"/{anoId}\", method=RequestMethod.GET, produces=\"application/json\") public VentasAnoBean getAno(@PathVariable int anoId) { System.out.println(\"getAno.Año: \"+anoId); return yagesBussines.getVentasAno(anoId); } @RequestMapping(value =\"/{anoId}/{mesId}\", method=RequestMethod.GET,produces=\"application/json\") public ArrayList\u0026lt;VentasSemanaBean\u0026gt; getSemanas(@PathVariable int anoId,@PathVariable int mesId) { System.out.println(\"GetSemanas. Mes \"+mesId+\" Año: \"+anoId); return yagesBussines.getDatosSemana(mesId, anoId); } } Como ya comente, lo primero es la anotación @RestController, que le dice a Spring que nuestra clase va a procesar peticiones tipo REST. A continuación, la anotación @RequestMapping(\u0026#8220;/rest\u0026#8221;) especifica que debe responder a las peticiones que vayan a la URL /rest \nComo dije en la entrada anterior, por claridad en los ejemplos vamos a suponer que nuestra aplicación responde en la dirección (URL) : http://localhost:8080/yagesserver . Aclarar, que el 8080 es el puerto donde escuchara y yagesserver es el directorio o contexto base donde estará nuestra aplicación.\nLa clase define un único objeto tipo YagesBussines a través del sistema de inyección de Spring y tiene dos funciones, que explico a continuación:\nFunción: getAno @RequestMapping(value = \"/{anoId}\", method=RequestMethod.GET, produces=\"application/json\") public VentasAnoBean getAno(@PathVariable int anoId) { System.out.println(\"getAno.Año: \"+anoId); return yagesBussines.getVentasAno(anoId); } Como se ve, la función esta anotada con la directiva @RequestMapping. Con esta directiva vamos a especificar que dirección (dentro de /rest/ ) vamos a tratar en esta función. Así, en este caso le decimos que vamos a procesar aquellas peticiones que tengan un solo parámetro y, que ademas, la petición sea del tipo GET. También especificamos que la respuesta a la petición sera del tipo application/json.\nEs decir, el esta función sera llamada ( y su código ejecutado ) cuando hagamos una petición del tipo http://localhost:8080/yagesserver/rest/2018 . Aclarar que no sera llamada si el numero de parámetros no es exactamente uno. Por ejemplo esta petición http://localhost:8080/yagesserver/rest/2018/2 no sera tratada ya que recibe dos parámetros (2018 y 2).\nCuando definimos la función, se añade la anotación @PathVariable que indica que la variable puesta a continuación deberá contener el parámetro de la URL. Así en la petición http://localhost:8080/yagesserver/rest/2018 nuestra variable anoId tendrá el valor 2018. Lógicamente, esto obliga a que el parámetro sea del tipo entero, pues hemos definido que nuestra variable anoId es del tipo int.\nEsta función, devuelve un objeto VentasAnoBean que esta definida en la siguiente clase:\n@Data public class VentasAnoBean { private ArrayList\u0026lt;VentasMesBean\u0026gt; ventasMes = new ArrayList(); private double kilosVentaAct, impVentaAct, kilosVentaAnt, impVentaAnt,gananciaAct,gananciaAnt; .... } Como se ve, la clase es una simple clase POJO, con unas variables, accesibles a través de sus correspondientes métodos getter, que la librería Lombok, a través de la anotación @Data creara. Teneis mas detalles de la librería Lombok en otra entrada de mi pagina.\nAl haber especificado que debe devolver un objeto con la codificación _json, _Spring, apoyándose en las librerías de jackson, devolverá la correspondiente cadena de texto, formateada adecuadamente. No voy a hablar de como se codifica o descodifica una cadena JSON en esta entrada y realmente tampoco nos importa. De eso ya se encargaran las correspondientes librerías. Lo que importa es que esta función un objeto del tipo _VentasAnoBean_ en un formato que luego una aplicación cliente va a saber reconstruir.\nAquí se ve una captura de pantalla de como accediendo a la URL:\nhttp://localhost:8080/yagesserver/rest/2018 es devuelto un objeto VentasAnoBean, que incluye un array de objetos tipo _ventasMes, _y las variables kilosVentaAct, impVentaAct, kilosVentaAnt, impVentaAnt,gananciaAct y gananciaAnt.\nSi usamos el comando curl, para hacer la petición HTTP, veremos que la salida, en crudo, seria la siguiente:\nFunción: getSemanas @RequestMapping(value =\"/{anoId}/{mesId}\", method=RequestMethod.GET, produces=\"application/json\") public ArrayList\u0026lt;VentasSemanaBean\u0026gt; getSemanas(@PathVariable int anoId,@PathVariable int mesId) { System.out.println(\"GetSemanas. Mes \"+mesId+\" Año: \"+anoId); return yagesBussines.getDatosSemana(mesId, anoId); } En esta función se van a tratar todas aquellas peticiones como la siguiente localhost:8080/yagessever/rest/2018/2 es decir, aquellas que tengan dos parametros.\nEsto se especifica por la anotación @RequestMapping donde especificamos que el valor debe ser _\u0026#8220;/{anoId}/{mesId}\u0026#8221;, _despues, en la declaración de nuestra función, especificamos en que variables deben ser introducidos los parámetros de la URL. Así, el primer parámetro sera introducido en la variable anoId y el segundo, en la variable mesId.\nEsta función devuelve un Array de objetos tipo VentasSemanaBean, que no es sino un simple POJO definido en la siguiente clase:\n@Data public class VentasMesBean { private int ano, mes; private double kilosVentaAct, impVentaAct, kilosVentaAnt, impVentaAnt; private double gananAct, gananAnt; .... } Si realizamos una petición, usando curl, obtendremos la siguiente salida:\nEn la ultima entrada de la parte servidor, explicare como se consiguen los objetos VentasMesBean y VentasAnoBean.\n¡¡ Hasta pronto !!\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/06/aplicacion-en-spring-rest-y-angular-5a-parte/",
	"title": "Backend (V)",
	"tags": [],
	"description": "",
	"content": "En esta ultima parte de la parte servidor hablare de como se crean los objetos que en el anterior articulo se devolvían.\nEstos objetos eran del tipo _VentasAnoBean _y un ArrayList de _VentasSemanaBean. _Para conseguirlos se llamaban a sendas funciones en la clase YagesBussines, que eran las que construían esos objetos.\nEmpezare describiendo la clase\n@Component public class YagesBussines { @Autowired CalendarioRepositorioService calendarioRepositorio; @Autowired HistVentasRepository histVentasRepository; @Autowired DataSource dataSource; @Autowired private JdbcOperations jdbc; @Bean public JdbcTemplate jdbcTemplate() { return new JdbcTemplate(dataSource); } ..... Lo primero, marcamos nuestra clase como @Component para que Spring la cree y este disponible para inyectarla en otras clases. De otra manera nuestra clase YagesController  no podría usarla.\nAhora inyectamos los diferentes objetos que vamos a usar, incluyendo el objeto jdbc que es de tipo JdbcOperations . Para que Spring pueda crear ese objeto debemos tener la función jdbcTemplate, que, usando la variable dataSource . devolverá un objeto tipo JdbcTemplate el cual implementa el interface JdbcOperations para usarlo en la variable jdbc, ya que la función esta marcarla con la anotación @Bean y eso hará que Spring sepa de donde sacar un objeto tipo JdbcOperations.\n ##### Función: getVentasAno  public VentasAnoBean getVentasAno(int ano) { List\u0026lt;VentasMesBean\u0026gt; cal = getKilosPorMes(ano); VentasAnoBean ventasAno = new VentasAnoBean(); cal.forEach((v) -\u0026gt; { ventasAno.addMes(v); }); if (ventasAno.getKilosVentaAct() == 0) { throw new VentasNotFoundException(ano); } return ventasAno; }  La función getVentasAno, simplemente llama a la función getKilosPorMes, la cual devuelve una lista de objectos tipo VentasMesBean (List), para después ir añadiéndolo al objeto tipo VentasAno.\nObsérvese que la función comprueba si el acumulado de kilos de venta, a través de la función getKilosVentaAct(), es igual a cero. Si es cero, lanza una excepción del tipo VentasNotFoundException\nEsa excepción se define en el paquete yages.yagesserver.bussines.\n@ResponseStatus(HttpStatus.NOT_FOUND) class VentasNotFoundException extends RuntimeException { private static final long serialVersionUID = 1L; public VentasNotFoundException(int ano) { this(ano, 0); } public VentasNotFoundException(int ano, int mes) { super(\"No encontradas ventas para año '\" + ano + \"'\"+ (mes\u0026gt;0?\" y Mes: \"+mes:\"\")); } public VentasNotFoundException(String msgError,int ano, int mes) { super(\"Error al buscar ventas para año '\" + ano + \"'\"+ (mes\u0026gt;0?\" y Mes: \"+mes:\"\")+\" \\n Error: \"+msgError); } } Lo destacable de esta clase es la anotación @ResponseStatus, la cual hará que cuando se lance, a través de una sentencia _throw, _sea capturada por Spring de tal manera que la respuesta a la peticion HTTP sea lo indicado, en este caso un HttpStatus.NOT_FOUND (el tipico 404: Página no encontrada). De esta manera si la consulta no devuelve ningún dato en vez de devolver un null, devolveremos un mensaje de error para que el cliente pueda tratarlo más fácilmente.\nEn otras palabras, cuando se lance una excepción del tipo VentasNotFoundException el cliente recibirá un error del tipo 404 (NOT FOUND).\nLa función getKilosPorMes, realiza una serie de consultas a través de jdbc. \npublic List\u0026lt;VentasMesBean\u0026gt; getKilosPorMes(int ano) { List\u0026lt;VentasMesBean\u0026gt; cal = jdbc.query( \"SELECT c.cal_ano,c.cal_mes , sum(hve_kilven) as kilosVenta,sum(hve_impven) as impVenta,sum(hve_impgan) as impGanancia \" + \"FROM Calendario c, histventas h \" + \" where c.cal_ano = ?\" + \" and h.hve_fecini between c.cal_fecini and c.cal_fecfin \" + \" and h.hve_fecfin between c.cal_fecini and c.cal_fecfin \" + \" group by cal_ano,cal_mes \" + \" order by c.cal_mes\", new Object[] { ano }, (rs, rowNum) -\u0026gt; new VentasMesBean(rs.getInt(\"cal_ano\"),rs.getInt(\"cal_mes\"),rs.getDouble(\"kilosVenta\"),rs.getDouble(\"impVenta\"),rs.getDouble(\"impGanancia\")) ); List\u0026lt;VentasMesBean\u0026gt; calAnt = jdbc.query( \"SELECT c.cal_ano,c.cal_mes , sum(hve_kilven) as kilosVenta,sum(hve_impven) as impVenta,sum(hve_impgan) as impGanancia \" + \"FROM Calendario c, histventas h \" + \" where c.cal_ano = ?\" + \" and h.hve_fecini between c.cal_fecini and c.cal_fecfin \" + \" and h.hve_fecfin between c.cal_fecini and c.cal_fecfin \" + \" group by cal_ano,cal_mes \" + \" order by c.cal_mes\", new Object[] { ano - 1}, (rs, rowNum) -\u0026gt; new VentasMesBean(rs.getInt(\"cal_ano\"),rs.getInt(\"cal_mes\"),rs.getDouble(\"kilosVenta\"),rs.getDouble(\"impVenta\"),rs.getDouble(\"impGanancia\")) ); cal.forEach((v) -\u0026gt; { for (VentasMesBean vAnt : calAnt) { if (v.getMes() == vAnt.getMes()) { v.setKilosVentaAnt(vAnt.getKilosVentaAct()); v.setImpVentaAnt(vAnt.getImpVentaAct()); v.setGananAnt(vAnt.getGananAct()); } } }); return cal; }  Obsérvese el uso intensivo de sentencias lamba.  Os recuerdo que tenéis un par de entradas sobre como este tema aquí y aquí\nEsta función consulta primero todas las ventas del año mandado, metiéndolas en un objeto List, después hace la misma consulta sobre el año anterior al mandado, metiendo el resultado en otro objeto List. Después recorre la primera lista a, con la función forEach, y si existe el mismo mes en el segundo objeto, establece los parámetros del año anterior en el primer objeto VentasMesBean. Por ultimo devuelve la lista de objetos (List)\n ##### Función: getDatosSemana  Esta función es la llamada cuando queremos buscar los datos de venta de un año y semana. Ofreciendo, semana por semana, los datos del periodo solicitado.\npublic ArrayList\u0026lt;VentasSemanaBean\u0026gt; getDatosSemana(int mes, int ano) { Calendario calAnterior = null; Optional\u0026lt;Calendario\u0026gt; calOpc = calendarioRepositorio.getCalendario(new CalendarioKey(mes, ano - 1)); if (calOpc.isPresent()) { calAnterior = calOpc.get(); try { ajustaFechas(calAnterior, ano - 1, mes); } catch (ParseException e) { throw new VentasNotFoundException(e.getMessage(), ano, mes); } } ...... } No es mi idea explicar paso a paso la lógica de esta función solo incidir en el uso de JPA, usando la clase CalendarioRepositorioService, que se limita a usar la clase generada automagicamente por Spring, la cual implementara el interface CalendarioRepository.\nEl código por si estáis interesados en curiosear como se buscan los datos lo tenéis en mi pagina de GitHub\nY con esto termino las entradas, explicando la parte servidor de esta aplicación.\nEspero que haya sido de utilidad y no os perdáis las siguientes sobre como hacer la parte cliente con Angular.\n¡¡ Hasta pronto !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2019/02/28/perfiles-en-spring-boot/",
	"title": "Perfiles en Spring Boot",
	"tags": ["java", "profiles", "spring boot"],
	"description": "",
	"content": "Cuando se hacen aplicaciones empresariales, lo normal es que, como mínimo, primero se desplieguen en un entorno de pruebas y después en el entorno de producción. Cada entorno de pruebas tendrá diferentes bases de datos, diferentes URLs y toda una serie de parámetros específicos, con el fin de que una aplicación en desarrollo no acceda nunca a datos reales.\nEstableciendo perfiles en la aplicación Spring provee una manera sencilla de gestionar esta situación haciendo uso de los perfiles.\nHay varias maneras de establecer el perfil a utilizar por una aplicación:\n Pasándolo como variable de entorno en JAVA. Por ejemplo: \u0026#8220;java -jar -Dspring.profiles.active=MI_PROFILE application.jar\u0026#8221; Pasándolo como un argumento al programa. \u0026#8220;java -jar application.jar \u0026#8211;spring.profiles.active=MI_PROFILE\u0026#8221; Especificarlo con una anotación en el propio programa, en la etiqueta @SpringBootTest, pasandole el parametro \u0026#8220;spring.profiles.active\u0026#8221;. Muy útil para prueba unitarias.@SpringBootTest(\u0026#8220;spring.profiles.active=test\u0026#8221;) Con la anotación @ActiveProfiles@ActiveProfiles(\u0026#8220;MI_PROFILE\u0026#8221;)  Creando Beans En el ejemplo que esta disponible en https://github.com/chuchip/profilestest se pueden ver como una aplicación saca diferentes mensajes y accede a diferentes datos según el perfil establecido.\nEl proyecto es una simple aplicación web, que accede a una base de datos H2, mostrando diferentes datos según el perfil. Para crear el proyecto simplemente hay que añadir las siguientes dependencias: JPA, H2 y WEB\nEmpezando por la clase principal veremos como definir diferentes beans dependiendo del perfil.\n@SpringBootApplication @Configuration public class ProfilesTests { @Autowired private Environment environment; public static void main(String[] args) { SpringApplication.run(ProfilesTests.class, args); } @Bean @Profile(\u0026quot;test\u0026quot;) IWrite getWriterTest() { return new WriteImpl(\u0026quot;..test.. \u0026quot;+getProfile()); } @Bean @Profile(\u0026quot;default\u0026quot;) IWrite getWriterDefault() { return new WriteImpl(\u0026quot;..default.. \u0026quot;+getProfile()); } @Bean @Profile(\u0026quot;other\u0026quot;) IWrite getWriterOther() { return new WriteImpl(\u0026quot;..other.. \u0026quot;+getProfile()); } String getProfile() { if (environment.getActiveProfiles()==null) return \u0026quot;default\u0026quot;; String[] profiles=environment.getActiveProfiles(); return profiles.length\u0026gt;0?profiles[0]:\u0026quot;default\u0026quot;; } }  En las funciones getWriterXXX, se devuelve siempre un bean que implementa el interface IWrite. La definición de este interfaz es muy simple, como se puede ver en el siguiente código:\npublic interface IWrite { public void writeLog(String log); public String getProfile(); }  Y su implementación en la clase WriteImpl es también muy sencilla:\npublic class \u0026lt;strong\u0026gt;WriteImpl\u0026lt;/strong\u0026gt; implements IWrite{ private String profile; public WriteImpl(String profile) { this.profile=profile; } public String getProfile() { return profile; } @Override public void writeLog(String log) { System.out.println(\u0026quot;Profile: \u0026quot;+profile+\u0026quot; -\u0026gt; \u0026quot;+ log); } }  Volviendo a la clase principal, se ve que la función getWriterTest() instancia un objeto WriteImpl, pasando al constructor el literal ..test.. y lo devuelto por la función getProfile(), la cual devuelve un String con el perfil activo.\nLa función getWriterDefault() hace lo mismo que la anterior pero instanciando un objeto WriteImpl al cual en el constructor se le pasa el literal ..default..y lo devuelto por la función getProfile(). Y lo mismo con la función getWriterOther() pero pasando el literal ..other..\nLo importante de estas funciones es la anotación @Bean con la cual le decimos a Spring que cuando en alguna parte del código se deba inyectar el objeto devuelto en esa función que ejecute esta función para conseguirlo.\nUn poco de teoría Cuando Spring encuentre una anotación @Autowired con un objeto tipo IWrite como ocurre en el siguiente código:\n@Autowired IWrite out;  buscara de alguna manera un objeto que implemente ese interface o que se llame igual que el objeto en si.\nAsí, para conseguir el objeto, Spring tiene dos opciones:\n Buscar dentro del proyecto una class que se llame IWrite o una clase que implemente el interfaz IWrite que este anotada con la etiqueta @Component Buscar dentro de una clase anotada con la etiqueta @Configuration una función anotada con @Bean y que devuelva un objeto de ese tipo.  Se pueden dar varios casos en este momento:\n Encuentra un objeto y lo usa. No encuentra un objeto con lo cual da un error y la aplicación no se ejecutara. Encuentra más de un objeto y como no sabe con cual quedarse da un error y la aplicación no se ejecuta.  Como se puede ver, en el código hay tres funciones que devuelven un objeto tipo IWrite, con lo cual Spring daría un error, para evitarlo añadimos la etiqueta @Profile . De esta manera si el perfil de la aplicación no coincide con el literal dentro de @Profile esa función será ignorada. Y como se puede ver, cada función tiene su propia anotación @Profile con lo cual Spring solo tratara una de ellas.\nDestacar que si lanzamos la aplicación sin especificar ningún perfil, Spring elige el perfil default.\nPor supuesto, si lanzáramos la aplicación con un perfil que no fuera default,test o other la aplicación fallaría, al no encontrar ningún objeto que implemente el interfaz IWrite\nCreando Componentes Para tener un ejemplo del caso en que Spring deba buscar una clase, en el proyecto de ejemplo se puede ver como se define el interfaz IRead el cual es implementado por la clases ReadDefImpl y ReadOtherImpl.\nObservar como ambas clases tienen las anotaciones @Component y @Profile antes de la definición de la clase. Lógicamente en una clase la etiqueta @Profile tiene el parámetro default y en otra el parámetro es other.\nEsta es la clase ReadDefImpl\n@Component @Profile(\u0026quot;default\u0026quot;) public class \u0026lt;strong\u0026gt;ReadDefImpl\u0026lt;/strong\u0026gt; implements IRead{ @Autowired ProfileRepository customerRepository; @Autowired IWrite out; public String readRegistry(int id) { out.writeLog(\u0026quot;entry in ReadImpl\u0026quot; ); Optional\u0026lt;ProfileEntity\u0026gt; registroOpc=customerRepository.findById(id); if (!registroOpc.isPresent()) { System.out.println(\u0026quot;Customer \u0026quot;+id+\u0026quot; NOT found\u0026quot;); return null; } ProfileEntity registro=registroOpc.get(); out.writeLog(\u0026quot;Name customer \u0026quot;+id+\u0026quot; is: \u0026quot;+registro.getName()); return registro.getName(); } }  Y así empieza la clase ReadOtherImpl\n@Component @Profile(\u0026quot;other\u0026quot;) public class \u0026lt;strong\u0026gt;ReadOtherImpl\u0026lt;/strong\u0026gt; implements IRead{  El cuerpo es de la clase es exactamente igual que la de la clase ReadDefImpl\nLeyendo ficheros de propiedades El código de la clase ProfilesController es el siguiente:\n@RestController public class ProfilesController { @Autowired IRead read; @Value(\u0026quot;${app.ID}\u0026quot;) int id; @Autowired IWrite write; @GetMapping(\u0026quot;/hello\u0026quot;) public String get(@RequestParam(value=\u0026quot;name\u0026quot;,required=false) String name) { return \u0026quot;Hello \u0026quot;+(name==null?\u0026quot;SIN NOMBRE\u0026quot;:name)+ \u0026quot;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; The name of the profile number:\u0026quot;+ id+\u0026quot; in the database H2 is: \u0026quot;+read.readRegistry(id)+ \u0026quot;\u0026lt;br\u0026gt; The profile used in the application is : \u0026quot;+write.getProfile(); } }  En esta clase podemos ver, la anotación @Value(\u0026#8220;${app.ID}\u0026#8221;) con ella lo que le estamos diciendo a Spring es que inicialice la variable que hay a continuación ( \u0026#8220;id\u0026#8220;) con el valor que encuentre en un fichero de properites. Como no especificamos ninguno buscara dentro de application.properties y encontrara la siguiente línea:\napp.ID=1  con lo cual la variable id tendrá el valor 1\nPero si nos fijamos en nuestro proyecto además del fichero application.properties también tenemos un fichero llamado application-other.properties, esto es porque Spring en el caso de que el perfil sea other buscara primero el fichero application-other.properties para establecer las propiedades.\nDe esta manera, cuando el perfil sea other leerá el fichero application-other.properties y encontrara la línea:\napp.ID=2  con lo cual la variable id tendrá el valor 2\nEs importante recalcar que el fichero application.properties se leerá y procesara siempre, independientemente del perfil elegido, pero luego se buscara el del perfil activo. Si no queremos que lea ese fichero, una solución seria renombrar el fichero a application-default.properties con lo cual solo se usaría con el perfil default.\nProbando la aplicación Para probar la aplicación en Eclipse podremos crear dos configuraciones. Una para el perfil default donde podemos ver que no especificamos ningún perfil con lo cual Spring asignara el perfil default y otra para el perfil other La del perfil default escuchara en el puerto 8080 y la de other en el 8081. Eso esta especificado con la línea server.port=8080 en el fichero application.properties y con la línea server.port:8081en el fichero application-other.properties\nComo se puede ver en las siguientes pantallas, la llamada a http://localhost:8080/hello?name=profesor devuelve la siguiente salida: Se puede ver como el valor de la variable id es 1 y como lee en la base de datos H2, el valor del registro correspondiente.\nEn la salida estándar veremos el siguiente texto:\nProfile: ..default.. default -\u0026gt; entry in ReadImpl Profile: ..default.. default -\u0026gt; Name customer 1 is: default  Si llamamos a http://localhost:8081/hello?name=profesor, veremos la siguiente salida en el navegador:\nEn la salida estándar veremos el siguiente texto:\nProfile: ..other.. other - entry in ReadImpl Profile: ..other.. other - Name customer 2 is: other En el articulo siguiente podéis ver el uso de los perfiles para testear la aplicación con JUnit\nHasta entonces, ¡¡ que la curiosidad no os abandone 😉 !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/22/acceso-a-base-de-datos-con-jdbc-spring/",
	"title": "Lambdas en JDBC Data",
	"tags": [],
	"description": "",
	"content": "En una entrada anterior, puse un ejemplo de como usar expresiones Lambas, como me parece que es un tema interesante, este de la programación funcional, voy a insistir en este tema.\nUna cosa muy común en Java es tener que pesarle como argumento a una función externa, una objeto que implemente una función donde nosotros pondremos el código a ejecutar en nuestra aplicación.\nUn ejemplo practico es en el uso de la clase JdbcOperations, que es utilizada por Spring para poder realizar operaciones JDBC, la cual tiene la función: \nT query(java.lang.String sql, java.lang.Object[] args, ResultSetExtractor rse) throws DataAccessException  Lo que hay que entender es que como funciona realmente esta función query . Esta función necesita tres parametros:\n sentencia SQL a ejecutar,  Argumentos de la sentencia SQL Clase ResultSetExtractor donde nuestro programa hará algo con los resultados obtenidos.  Así, voy a suponer que queremos realizar una consulta sobre una tabla, buscando el nombre de un usuario, a través de su identificador. La tabla usuarios, tendría solo estos dos campos:\n identificador, que seria un varchar de 15 caracteres (un texto para los que no conocen SQL) nombre, que seria otro de varchar de 50 caracteres (otro texto, vamos).  Es decir queremos buscar, el nombre de un usuario, sabiendo su identificador. La sentencia SQL para realizar esta búsqueda seria\nselect nombre from usuarios where identificador = ? La interrogación final hace referencia al parámetro que pasaremos, es decir el identificador del usuario.\nPor lo tanto, en nuestro programa pondremos una sentencia, como la siguiente:\njdbc.query(\u0026quot;select nombre from usuarios where identificador = ?\u0026quot;, new[] { \u0026quot;usuario1\u0026quot; }, OBJETO_RESULTSETEXTRACTOR)  El parámetro new Object[] { \u0026#8220;usuario1\u0026#8221; } simplemente crea un array de Objetos con los diferentes parámetros que necesitara nuestra sentencia SQL. En este caso solo necesita un parámetro que es el identificador del usuario. Vamos a buscar el usuario que tiene como identificador usuario1.\nY nos queda por definir el objeto del tipo ResultSetExtractor, donde interactuaremos con los resultados de nuestra sentencia SQL.\nEse tipo de objeto esta definido en el interface ResultSetExtractor el cual solo tiene una función, que detallo a continuación:\nT mapRow(java.sql.ResultSet rs, int rowNum) throws java.sql.SQLException  Antes de Java 1.8, deberíamos crear una clase que implemente el interfaz ResultSetExtractor. Esa clase seria algo así como:\nclass miResultSetExtractor implements ResultSetExtractor { @Override public T mapRow(java.sql.ResultSet rs, int rowNum) throws java.sql.SQLException { System.out.println(\u0026quot;El nombre del Usuario es: \u0026quot;+rs.getString(\u0026quot;nombre\u0026quot;)); // \u0026lt;strong\u0026gt;CODIGO A EJECUTAR\u0026lt;/strong\u0026gt; } }  Y ejecutaríamos la llamada a la función query de esta manera:\njdbc.query(\"select nombre from usuarios where identificador = ?\", new Object[] { \"usuario1\" },new miResultSetExtractor ()); También podríamos crear una clase abstracta, a la hora de llamar a la función query,  con una sentencia como esta:\njdbc.query(\"select nombre from usuarios where identificador = ?\", new Object[] { \"usuario1\" }, new ResultSetExtractor() { @Override public T mapRow(java.sql.ResultSet rs, int rowNum) throws java.sql.SQLException { System.out.println(\"El nombre del Usuario es: \"+rs.getString(\"nombre\")); // CODIGO A EJECUTAR } }); El caso es que tenemos que poner un montón de código auxiliar cuando nosotros solo quisiéramos poner nuestro System.out.println.\nY ahora es cuando viene al rescate las expresiones Lamba.\njdbc.query(\"select nombre from usuarios where identificador = ?\", new Object[] { \"usuario1\" }, (param1, param2) -\u0026gt; System.out.println(\"El nombre del Usuario es: \"+param1.getString(\"nombre\")); La expresión lambda se compone de dos partes. Los parámetros a mandar y el código a ejecutar.\nAsí, nosotros mandaremos dos parametros: param1 y param2. (le podriamos haber puesto los nombres que quisieramos)\nComo se ve, no hay que especificar de que tipo son esos parámetros, Java, se encargara de eso. Te estarás preguntado, pero, ¿ como funciona esto ?.\nBueno, en primer lugar, Java, cuando compile nuestro código buscara que que objeto debe crear, dependiendo del parámetro esperado por la función jdbc.query(). Vera que espera un objeto que implemente el interface ResultSetExtractor y comprobara que ese interface solo tiene una función, por lo cual, sabrá fácilmente que parámetros se tipo de objetos se deben pasar como objetos.\nEs por eso que solo se pueden aplicar este tipo de expresiones lambda cuando el interface implemente una única función.\nUna vez que Java, sabe que objetos debe pasar, el sustituirá nuestras variables param1 y param2 y las usara en el cuerpo de nuestra expresión Lambda. Por ello ahora nuestro código: System.out.println(\u0026#8220;El nombre del Usuario es: \u0026#8220;+param1.getString(\u0026#8220;nombre\u0026#8221;)) cogera la variable param1 y la usara sabiendo que es un objeto tipo ResultSet. Observar que aunque la variable param2, no la usamos en nuestro código, debemos definirla igualmente.\nEspero haberme explicado bien, y no dudéis en preguntar o seguirme en mi cuenta de twitter.\n¡ Hasta la próxima !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/contacto/",
	"title": "Contacto",
	"tags": [],
	"description": "",
	"content": "Mi nombre es Jesús Javier Puente, vivo en Logroño, apasionado de la informática, soy programador desde hace demasiados años, ademas de Administrador de sistemas, DBA.\nMi correo electrónico es chuchip@gmail.com y en mi cuenta de Twitter @chuchip\nEsta es mi página en Linkedin. Tengo algunos de mis provectos en GitHub\nPuedes ver mi experiencia laboral en está pagina.\n"
},
{
	"uri": "http://ww2.profesor-p.com/",
	"title": "Bienvenido a mi página",
	"tags": [],
	"description": "",
	"content": " ¡¡El profe os da la bienvenida!! En este blog intentaré ir poniendo artículos sobre temas que me parecen interesantes, que sean didácticos y con ejemplos de cómo hacer una cosa e incluso dos. 😄\nPondré artículos sobre informática, incidiendo sobre todo en el mundo Java y específicamente en Spring.\nTambién encontrarás artículos sobre JPA, Hibernate, Spring boot, Hugo (programa con el cual está hecha ésta página web), Kafka y otros temas.\nEn el menú lateral tienes un menú que agrupa los articulos por temática, creando un libro.\nPor supuesto siempre puedes utilizar el buscador encontrar artículos que contengan una palabra especifica y, ademas, podrás localizar artículos por temas, por ejemplo si quieres buscar artículos sobre Java, podrías ir a www.profesor-p/es/tags/java/\nEspero que encontréis útiles las entradas y por supuesto cualquier comentario sera bienvenido.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/06/13/estableciendo-filtros-en-spring/",
	"title": "Estableciendo filtros en Spring",
	"tags": ["filters", "java", "rest", "spring"],
	"description": "",
	"content": "En esta entrada voy a hablar de como implementar filtros en Spring. Los filtros son de los que se pueden establecer cuando se recibe una petición HTTP. Es decir, suponiendo que tenemos un programa escuchando en unas URI, poder especificar que deseamos ejecutar algo antes de que las peticiones sea procesadas por el controlador.\nEsto es muy útil si queremos que todas las peticiones cumplan un requisito, por ejemplo incluir una cabecera especifica.\nPara entender como funcionan los filtros en Spring he realizado un programa que iré explicando poco a poco.\nEl código fuente del programa lo tenéis en mi página de GITHUB\nEmpezare mostrando el controlador para peticiones REST que esta en la clase PrincipalController.java. Este será el encargado de gestionar todas las peticiones.\n@RestController public class PrincipalController { @Autowired SillyLog sillyLog; @GetMapping(\u0026quot;*\u0026quot;) public String entryOther(HttpServletRequest request,HttpServletResponse response) {\tsillyLog.debug(\u0026quot;In entryOther\u0026quot;); if (response.getHeader(\u0026quot;PROFE\u0026quot;)!=null) sillyLog.debug(\u0026quot;Header contains PROFE: \u0026quot;+response.getHeader(\u0026quot;PROFE\u0026quot;)); if (response.getHeader(\u0026quot;CAKE\u0026quot;)!=null) sillyLog.debug(\u0026quot;Header contains CAKE: \u0026quot;+response.getHeader(\u0026quot;CAKE\u0026quot;)); return \u0026quot;returning by function entryOther\\r\\n\u0026quot;+ sillyLog.getMessage(); } @GetMapping(value={\u0026quot;/\u0026quot;,\u0026quot;one\u0026quot;}) public String entryOne(HttpServletRequest request,HttpServletResponse response\t) { sillyLog.debug(\u0026quot;In entryOne\u0026quot;); if (response.getHeader(\u0026quot;PROFE\u0026quot;)!=null) { sillyLog.debug(\u0026quot;Header contains PROFE: \u0026quot;+response.getHeader(\u0026quot;PROFE\u0026quot;)); return entryTwo(response);\t} return \u0026quot;returning by function entryOne\\r\\n\u0026quot;+ sillyLog.getMessage(); } @GetMapping(\u0026quot;two\u0026quot;) public String entryTwo(HttpServletResponse response) { sillyLog.debug(\u0026quot;In entryTwo\u0026quot;); if (response.getHeader(\u0026quot;PROFE\u0026quot;)!=null) sillyLog.debug(\u0026quot;Header contains PROFE: \u0026quot;+response.getHeader(\u0026quot;PROFE\u0026quot;)); return \u0026quot;returning by function entryTwo\\r\\n\u0026quot;+ sillyLog.getMessage(); } @GetMapping(\u0026quot;three\u0026quot;) public String entryThree() { sillyLog.debug(\u0026quot;In entryThree\u0026quot;); return \u0026quot;returning by function entryThree\\n\u0026quot;+ sillyLog.getMessage(); } @GetMapping(\u0026quot;redirected\u0026quot;) public String entryRedirect(HttpServletRequest request) { sillyLog.debug(\u0026quot;In redirected\u0026quot;); return \u0026quot;returning by function entryRedirect\\n\u0026quot;+ sillyLog.getMessage(); } }  En la función entryOther se capturaran todas las peticiones tipo GET que vayan a alguna URI que no tengamos definidas explícitamente. En la función entryOne se procesaran las peticiones tipo GET que vayan a la URL http://localhost:8080/one o http://localhost:8080/ y así sucesivamente.\nLa clase sillyLog es una clase donde simplemente iremos añadiendo líneas de log para luego devolverlas en el body de la respuesta, de tal manera que podremos ver por donde ha pasado nuestra petición.\nEn esta aplicación se definen tres filtros: MyFilter.java ,OtherFilter.java y CakesFilter.java. El primero tiene preferencia sobre el segundo, por estar así establecido en el parámetro de la etiqueta @Order. Del tercero hablo al final del articulo.\nEn el fichero MyFilter.java definimos nuestro primer filtro.\n@Component @Order(1) public class MyFilter implements Filter{ @Autowired SillyLog sillyLog; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\tthrows IOException, ServletException { HttpServletRequest httpRequest = (HttpServletRequest) request; HttpServletResponse myResponse= (HttpServletResponse) response; sillyLog.debug(\u0026quot;Filter: URL\u0026quot; + \u0026quot; called: \u0026quot;+httpRequest.getRequestURL().toString()); if (httpRequest.getRequestURL().toString().endsWith(\u0026quot;/one\u0026quot;))\t{\tmyResponse.addHeader(\u0026quot;PROFE\u0026quot;, \u0026quot;FILTERED\u0026quot;);\tchain.doFilter(httpRequest, myResponse); return; } if (httpRequest.getRequestURL().toString().endsWith(\u0026quot;/none\u0026quot;))\t{ myResponse.setStatus(HttpStatus.BAD_GATEWAY.value()); myResponse.getOutputStream().flush(); myResponse.getOutputStream().println(\u0026quot;-- I don't have any to tell you --\u0026quot;); return; // No hago nada. } if (httpRequest.getRequestURL().toString().endsWith(\u0026quot;/redirect\u0026quot;))\t{\tmyResponse.addHeader(\u0026quot;PROFE\u0026quot;, \u0026quot;REDIRECTED\u0026quot;); myResponse.sendRedirect(\u0026quot;redirected\u0026quot;); chain.doFilter(httpRequest, myResponse); return; } if (httpRequest.getRequestURL().toString().endsWith(\u0026quot;/cancel\u0026quot;))\t{\tmyResponse.addHeader(\u0026quot;PROFE\u0026quot;, \u0026quot;CANCEL\u0026quot;); myResponse.setStatus(HttpStatus.BAD_REQUEST.value()); myResponse.getOutputStream().flush(); myResponse.getOutputStream().println(\u0026quot;-- Output by filter error --\u0026quot;); chain.doFilter(httpRequest, myResponse); return; } chain.doFilter(request, response); } }  La clase OtherFilter es más simple:\n@Component @Order(2) public class OtherFilter implements Filter{ @Autowired SillyLog sillyLog; @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletRequest httpRequest= (HttpServletRequest) request; HttpServletResponse myResponse= (HttpServletResponse) response; sillyLog.debug(\u0026quot;OtherFilter: URL\u0026quot; + \u0026quot; called: \u0026quot;+httpRequest.getRequestURL().toString()); if (myResponse.getHeader(\u0026quot;PROFE\u0026quot;)!=null) { sillyLog.debug(\u0026quot;OtherFilter: Header contains PROFE: \u0026quot;+myResponse.getHeader(\u0026quot;PROFE\u0026quot;)); } chain.doFilter(request, response); } }  Lo primero que tenemos que hacer para definir un filtro general es etiquetar la clase con @Component . Después deberemos implementar el interface Filter . También podríamos extender de la clase OncePerRequestFilter la cual implementa el interface Filter y añade ciertas funcionalidades para que un filtro solo se ejecute una vez por ejecución. En este ejemplo vamos a simplificarlo al máximo y directamente implementaremos el interface Filter.\nEl interface Filter tiene tres funciones.\n void init(FilterConfig filterConfig) throws ServletException\nEsta función será ejecutada por el contenedor web. En otras palabras: esta función solo es ejecutada una vez, cuando el componente es instanciado por Spring.\n void doFilter(ServletRequest request,ServletResponse response, FilterChain chain) throws IOException, ServletException\nEsta función será ejecutada cada vez que se realiza una petición HTTP. En ella es donde podremos ver el contenido de la petición HTTP, en el objeto ServletRequest y modificar la respuesta en el objeto ServletResponse . FilterChain es lo que debemos ejecutar si queremos continuar la petición.\n void destroy()\nEsta función es llamada por el contenedor web de Spring para indicarle al filtro, que va a dejar de estar activo.\n  Como he comentado anteriormente, la etiqueta @Order nos permitirá especificar el orden en que los filtros serán ejecutados. En este caso, este filtro tendrá el valor 1 y el siguiente tendrá el valor 2, por lo cual MyFilter se ejecutara antes que OtherFilter.\nLa clase MyFilter realiza diferentes acciones según la URL llamada. La clase OtherFiltersolamente añade un log cuando pasa por ella.\nEn el código del ejemplo nosotros solo utilizamos la función doFilter. En ella, lo primero, convertimos la clase ServletResponse a HttpServletResponse y la clase ServletRequest a HttpServletRequest. Esto es necesario para poder acceder a ciertas propiedades de los objetos que de otra manera no estarían disponibles.\nVoy a explicar paso a paso los diferentes casos contemplados en la clase MyFilter, dependiendo de la URL invocada.\n /one: Añadimos una cabecera PROFE con el valor FILTERED a la respuesta. Es importante recalcar que solo podremos modificar la respuesta, la petición es inalterable.\nDespués ejecutamos la función doFilterde la clase chain con lo cual se continuara el flujo de la petición. En este caso se ejecutaría el segundo filtro y después se pasaría por a la función entryOne del controlador, donde podríamos ver que existe un header con el valor PROFE, por lo cual se llama a la función entryTwo.\nUna llamada a esta URL nos devolvería lo siguiente:\n\u0026gt; curl -s http://localhost:8080/one returning by function entryTwo SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/1 Filter: URL called: http://localhost:8080/one SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/2 OtherFilter: URL called: http://localhost:8080/one SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/3 OtherFilter: Header contains PROFE: FILTERED SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/4 In entryOne SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/5 Header contains PROFE: FILTERED SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/6 In entryTwo SillyLog: 15eb34c2-cfac-4a27-9450-b3b07f44cb50/7 Header contains PROFE: FILTERED   La primera línea es devuelta por la función entryTwo. A continuación se muestran los logs añadidos.\nLo mejor es mirar el código fuente si no se tiene claro de donde salen tantas líneas 😉\n /redirect Añadimos una cabecera PROFE con el valor REDIRECTED al response. Después especificamos que se debe incluir una redirección a la URL redirected con la instrucción myResponse.sendRedirect. Finalmente ejecutamos la función doFilter por lo cual se procesara el segundo filtro y se llamara a la función entryOther ya que no tenemos ningún punto de entrada definido para /cancel.   Esta es la salida que tendremos si realizamos una petición con curl:\n\u0026gt; curl -s http://localhost:8080/redirect  Efectivamente, no hay salida. ¿Por qué?. Pues porque hemos incluido una directiva redirected y curl por defecto no sigue esas directivas, con lo cual simplemente no muestra nada.\nVeamos, que esta pasando añadiéndole a curl el parámetro -v (verbose)\n\u0026gt; curl -v -s http://localhost:8080/redirect * Trying ::1... * TCP_NODELAY set * Connected to localhost (::1) port 8080 (#0) \u0026gt; GET /redirect HTTP/1.1 \u0026gt; Host: localhost:8080 \u0026gt; User-Agent: curl/7.60.0 \u0026gt; Accept: */* \u0026gt; \u0026lt; HTTP/1.1 302 \u0026lt; PROFE: REDIRECTED \u0026lt; Location: http://localhost:8080/redirected \u0026lt; Content-Length: 0 \u0026lt; Date: Thu, 13 Jun 2019 13:57:44 GMT \u0026lt; * Connection #0 to host localhost left intact  Esto es otra cosa, ¿verdad?. Ahora muestra en la cabecera nuestro valor para PROFE Y vemos la orden de redirigir a http://localhost:8080/redirected. Observar que el código HTTP es 302, que es redirect.\nSí le decimos a curl que siga la redirección, pasándole el parámetro -L, veremos lo que esperábamos.\n \u0026gt; curl -L -s http://localhost:8080/redirect returning by function entryRedirect SillyLog: dcfc8b09-84a4-40a1-a2d6-43340abdf50c/1 Filter: URL called: http://localhost:8080/redirected SillyLog: dcfc8b09-84a4-40a1-a2d6-43340abdf50c/2 OtherFilter: URL called: http://localhost:8080/redirected SillyLog: dcfc8b09-84a4-40a1-a2d6-43340abdf50c/3 In redirected  Bueno, casi lo que esperábamos. Obsérvese que ha habido dos peticiones HTTP a nuestro servicio y solo se muestra los datos de la segunda.\n /none . Establezco el código HTTP a devolver a BAD_GATEWAY y en el cuerpo pongo el texto \u0026#8220;I don\u0026#8217;t have any to tell you\u0026#8221;. No ejecuto la función doFilter por lo cual ni será llamado el segundo filtro, ni seria pasada al controlador.\n\u0026gt; curl -s http://localhost:8080/none -- I don't have any to tell you --  /cancel . Establezco el código HTTP a devolver a BAD_REQUEST y en el cuerpo pongo el texto \u0026#8220;Output by filter error\u0026#8221;. Ejecuto la función doFilter por lo cual será ejecutado el filtro OtherFilter y se pasara por la función entryOther del controlador, ya que no tenemos ningún punto de entrada definido para /cancel\n\u0026gt; curl -s http://localhost:8080/cancel -- Output by filter error -- returning by function entryOther SillyLog: 1cf7f7f9-1a9b-46a0-9b97-b8d5caf734bd/1 Filter: URL called: http://localhost:8080/cancel SillyLog: 1cf7f7f9-1a9b-46a0-9b97-b8d5caf734bd/2 OtherFilter: URL called: http://localhost:8080/cancel SillyLog: 1cf7f7f9-1a9b-46a0-9b97-b8d5caf734bd/3 OtherFilter: Header contains PROFE: CANCEL SillyLog: 1cf7f7f9-1a9b-46a0-9b97-b8d5caf734bd/4 In entryOther SillyLog: 1cf7f7f9-1a9b-46a0-9b97-b8d5caf734bd/5 Header contains PROFE: CANCEL   Observar que el cuerpo añadido en el filtro es anterior a lo devuelto por el controlador.\n Otros En cualquier otra llamada se invocara la función doFilterde la clase chain por lo cual se pasara al siguiente filtro y después a la función del controlador adecuado.\n\u0026gt; curl -L -s http://localhost:8080/three returning by function entryThree SillyLog: a2dd979f-4779-4e34-b8f6-cae814370426/1 Filter: URL called: http://localhost:8080/three SillyLog: a2dd979f-4779-4e34-b8f6-cae814370426/2 OtherFilter: URL called: http://localhost:8080/three SillyLog: a2dd979f-4779-4e34-b8f6-cae814370426/3 In entryThree   Para especificar que un filtro solo sea activo para ciertas URL, hay que registrarlo explícitamente y no marcar la clase con la etiqueta @Component. En el proyecto de ejemplo en la clase FiltrosApplication vemos la función donde se añade un filtro:\n@Bean public FilterRegistrationBean\u0026lt;CakesFilter\u0026gt; cakesFilter() { FilterRegistrationBean\u0026lt;CakesFilter\u0026gt; registrationBean = new FilterRegistrationBean\u0026lt;\u0026gt;(); registrationBean.setFilter(new CakesFilter()); registrationBean.addUrlPatterns(\u0026quot;/cakes/*\u0026quot;); return registrationBean; }  La clase CakesFilter es la siguiente:\n@Order(3) public class CakesFilter implements Filter{ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { HttpServletResponse myResponse= (HttpServletResponse) response; myResponse.addHeader(\u0026quot;CAKE\u0026quot;, \u0026quot;EATEN\u0026quot;); chain.doFilter(request, response); } }  Al hacer una llamada a una url que empiece por /cakes/* veremos como se ejecuta el ultimo filtro.\n\u0026gt; curl -s http://localhost:8080/cakes returning by function entryOther SillyLog: 41e2c9b9-f8d2-42cc-a017-08ea6089e646/1 Filter: URL called: http://localhost:8080/cakes SillyLog: 41e2c9b9-f8d2-42cc-a017-08ea6089e646/2 OtherFilter: URL called: http://localhost:8080/cakes SillyLog: 41e2c9b9-f8d2-42cc-a017-08ea6089e646/3 In entryOther SillyLog: 41e2c9b9-f8d2-42cc-a017-08ea6089e646/4 Header contains CAKE: EATEN  Por la manera en que tiene Spring de gestionar sus variables de contexto, no es posible inyectar el objeto SillyLog con un @Autowired . Si lo inyectamos veremos como la variable tiene el valor null\nY con esto doy por finalizada esta entrada ¡¡ Hasta la próxima !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/filters/",
	"title": "filters",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/java/",
	"title": "java",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/java/",
	"title": "java",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/rest/",
	"title": "rest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/rest/",
	"title": "rest",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/spring/",
	"title": "spring",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/spring/",
	"title": "spring",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/web/",
	"title": "web",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/05/12/cacheando-datos-en-spring-boot/",
	"title": "Cacheando resultados con Spring Boot",
	"tags": ["cache", "java", "spring boot"],
	"description": "",
	"content": " Vamos a imaginar una aplicación web, donde por cada petición recibida, debe leer ciertos datos de configuración desde una base de datos. Esos datos no cambiaran normalmente pero nuestra aplicación, en cada petición, debe conectarse, ejecutar las sentencias adecuadas para leer los datos, traerlos por la red, etc. Imaginemos, además, que la base de datos a la que nos conectamos esta saturada o la conexión de red que nos une a la base de datos es inestable. ¿Qué pasaría?. Pues que tendríamos una aplicación lenta por el hecho de leer continuamente unos datos que sabemos que apenas cambian.\nPara solucionar ese problema podríamos utilizar una Cache, pero ¿ como implementarlo ?. En este articulo explicare como usar una cache básica en Spring Boot.\nUn poco de teoría La cache se aplica sobre funciones, donde para un mismo valor de entrada esperamos un mismo valor de salida. Es por ello que siempre debemos tener al menos un parámetro de entrada y una salida.\nUn ejemplo típico seria este:\n@Cacheable(cacheNames=\u0026quot;headers\u0026quot;) public int funcionCacheada(int valor) { ... calculos muy complejos y costosos .... return N; }  Y ahora supongamos que tenemos el siguiente código donde llamamos a esa función:\nint valor=funcionCacheada(1); int otroValor=funcionCacheada(2); int tercerValor=funcionCacheada(1);  Al ejecutar el programa, en la primera línea, Spring, ejecutara la función y guardara el resultado que devuelve. En la segunda línea, como no sabe el valor que se debe devolver para la entrada con valor \u0026#8220;2\u0026#8221; hará lo mismo. Sin embargo en la tercera línea Spring detectara que una función marcada con @Cacheable con el nombre de cache \u0026#8220;headers\u0026#8221; ya ha sido llamada con el valor \u0026#8220;1\u0026#8221; y no ejecutara la función, simplemente devolverá el valor que en la primera llamada guardo.\nEl nombre de la cache es importante pues, entre otras cosas, nos permite tener diferentes caches independientes, las cuales podremos, entre otras cosas limpiar, para obligar a a Spring Boot a ejecutar de nuevo las funciones.\nAsí, la idea básicamente es que en cada llamada a una función marcada como @Cacheable se guarda en una tabla interna los resultados para cada llamada, de tal manera que si ya tiene la salida para una entrada, no llama a la función.\nPractica Y ahora, vamos a la práctica:\nEl proyecto de ejemplo sobre el que esta basado este articulo esta en: https://github.com/chuchip/cacheExample\nLo primero que se necesita es incluir la siguiente dependencia en nuestro proyecto:\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-cache\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt;  Ahora ya podremos utilizar las etiquetas que nos permitirán usar Cache en nuestra aplicación.\nLa primera etiqueta a poner es @EnableCaching. Con esta etiqueta le indicamos a Spring que prepare el soporte para usar cache. Si no se la ponemos simplemente no la usara, independientemente de si indicamos posteriormente que cachee los resultados de unas funciones.\n@SpringBootApplication @EnableCaching public class CacheExampleApplication { public static void main(String[] args) { SpringApplication.run(CacheExampleApplication.class, args); } }  En este ejemplo se leerán unos datos de una base de datos a través de unas peticiones REST.\nLos datos como tal se leen en la clase CacheDataImpl.java que esta en el paquete com.profesorp.cacheexample.impl\nLa función que lee los datos es la siguiente:\n@Cacheable(cacheNames=\u0026quot;headers\u0026quot;, condition=\u0026quot;#id \u0026gt; 1\u0026quot;) public DtoResponse getDataCache(int id) {\ttry { Thread.sleep(500); } catch (InterruptedException e) { }\tDtoResponse requestResponse=new DtoResponse();\tOptional\u0026lt;Invoiceheader\u0026gt; invoice=invoiceHeaderRepository.findById(id); ..... MAS CODIGO NO IMPORTANTE ... }  Como se puede ver tenemos la etiqueta @Cacheable(cacheNames=\u0026#8221;headers\u0026#8221;, condition=\u0026#8221;#id \u0026gt; 1\u0026#8243;)\nCon ella, le estamos indicando a Spring dos cosas.\n Que deseamos que cachee el resultado de esta función. Le ponemos como condición, que solo cachee los resultados si el valor de entrada es superior a 1.  Más adelante, en la función flushCache, le ponemos la etiqueta @CacheEvict la cual limpia la cache indicada. En este caso, además, le indicamos que borre todas las entradas que tengan cacheadas.\n@CacheEvict(cacheNames=\u0026quot;headers\u0026quot;, allEntries=true) public void flushCache() { }  En la función update actualizamos la base de datos y con la etiqueta @CachePut le indicamos a Spring que actualice los datos para el valor que hay en dtoRequest.id\n@CachePut(cacheNames=\u0026quot;headers\u0026quot;, key=\u0026quot;#dtoRequest.id\u0026quot;) public DtoResponse update(DtoRequest dtoRequest) { .... ACTUALIZADA LA BASE DE DATOS ... }  Por supuesto esta función tiene que devolver un objeto del mismo tipo que el de la marcada con la etiqueta @Cacheable y debemos indicarle el valor de entrada, para el que se desea actualizar los datos.\nFuncionando Para entender mejor la aplicación vamos a arrancarla y realizarle algunas peticiones.\nLa aplicación al arrancar guarda en la tabla invoiceHeader las cabeceras de 4 facturas (podéis ver como lo hace en el fichero data.sql).\nVamos a ejecutar la función get de la clase PrincipalController, para ello escribimos:\n\u0026gt; curl -s http://localhost:8080/2  Nos devolverá lo siguiente:\n{\u0026quot;interval\u0026quot;:507,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:2,\u0026quot;activo\u0026quot;:\u0026quot;N\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:2,\u0026quot;customerId\u0026quot;:2}}  El campo interval el tiempo en milisegundos que le ha costado realizar la consulta. Como se puede ver le ha costado mas de medio segundo, pues en la función getDataCache de CacheDataImpl.javatenemos un sleep de 500 milisegundos.\nAhora ejecutamos de nuevo la llamada:\ncurl -s http://localhost:8080/2 {\u0026quot;interval\u0026quot;:1,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:2,\u0026quot;activo\u0026quot;:\u0026quot;N\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:2,\u0026quot;customerId\u0026quot;:2}}  Ahora el tiempo que ha tomado la llamada es 1 , porque realmente Spring NO ha ejecutado el código de la función y simplemente ha devuelto el valor que tenia cacheado.\nSin embargo si solicitamos el id 1 como hemos indicado que no lo cachee siempre ejecutara la función y por lo tanto tendremos un tiempo superior a 500 milisegundos:\n\u0026gt;curl -s http://localhost:8080/1 {\u0026quot;interval\u0026quot;:503,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:1,\u0026quot;activo\u0026quot;:\u0026quot;S\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:1,\u0026quot;customerId\u0026quot;:1}} \u0026gt;curl -s http://localhost:8080/1 {\u0026quot;interval\u0026quot;:502,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:1,\u0026quot;activo\u0026quot;:\u0026quot;S\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:1,\u0026quot;customerId\u0026quot;:1}} \u0026gt;curl -s http://localhost:8080/1 {\u0026quot;interval\u0026quot;:503,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:1,\u0026quot;activo\u0026quot;:\u0026quot;S\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:1,\u0026quot;customerId\u0026quot;:1}}  Si llamamos a la función flushcache limpiaremos la cache y por lo tanto la próxima llamada a la función cacheada deberá ejecutar la función:\n\u0026gt; curl -s http://localhost:8080/flushcache Cache Flushed! \u0026gt; curl -s http://localhost:8080/2 {\u0026quot;interval\u0026quot;:508,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:2,\u0026quot;activo\u0026quot;:\u0026quot;N\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:2,\u0026quot;customerId\u0026quot;:2}} \u0026gt; curl -s http://localhost:8080/2 {\u0026quot;interval\u0026quot;:0,\u0026quot;httpStatus\u0026quot;:\u0026quot;OK\u0026quot;,\u0026quot;invoiceHeader\u0026quot;:{\u0026quot;id\u0026quot;:2,\u0026quot;activo\u0026quot;:\u0026quot;N\u0026quot;,\u0026quot;yearFiscal\u0026quot;:2019,\u0026quot;numberInvoice\u0026quot;:2,\u0026quot;customerId\u0026quot;:2}}  Por ultimo veremos como si cambiamos el valor del campo activo a N , como la función que realiza el cambio esta marcada con @CacheEvict nos actualizara el valor de la cache, pero en la próxima llamada a la función getDataCache se seguirá sin ejecutar el código, devolviendo, sin embargo, el objeto actualizado.\n curl -X PUT http://localhost:8080/ -H \"Content-Type: application/json\" -d \"{\\\"id\\\": 2, \\\"active\\\": \\\"N\\\"}\" curl -s http://localhost:8080/2 {\"interval\":0,\"httpStatus\":\"OK\",\"invoiceHeader\":{\"id\":2,\"activo\":\"N\",\"yearFiscal\":2019,\"numberInvoice\":2,\"customerId\":2}}  Conclusiones Spring Boot, sin ninguna dificultad, nos permite cachear los resultados de las funciones, sin embargo hay que tener en cuenta que esa cache es muy básica y la realiza en memoria. Sin embargo Spring Boot permite usar librerías externas que nos permitirán cachear en disco, en bases de datos, etc.\nEn https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-caching.html tenéis las diferentes implementaciones de Cache que Spring Boot soporta, entre las que esta EhCache , con la cual podréis definir diferentes tipos de backend para los datos, así como especificar tiempos de validez para los datos y muchas más opciones.\nComo veis, todo un mundo para explorar.\n¡¡Nos vemos en la proxima entrada!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/cache/",
	"title": "cache",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/cache/",
	"title": "cache",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/spring-boot/",
	"title": "spring boot",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/spring-boot/",
	"title": "spring boot",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/04/18/beans-avanzados-en-spring/",
	"title": "Beans avanzados",
	"tags": ["beans", "spring"],
	"description": "",
	"content": "En esta ocasión he cogido un proyecto de SimpleProgramming el cual tiene un video en Youtube donde explica como cargar Beans dinámicamente usando Spring (en Ingles).\nImaginemos que tenemos un programa que dependiendo de unos parámetros deba cargar un clase u otra, donde está definida la lógica a seguir. Por supuesto podemos anidar condiciones e instanciar las clases debidas, pero eso tiene un problema y es que si mañana debemos añadir una lógica nueva, deberemos incluir una condición más para cargar la nueva clase, y podríamos introducir errores en el código.\nLo ideal seria que tuviéramos una interfaz, y después una serie de clases que implementaran esa interfaz. Después, de alguna manera, deberíamos cargar la clase adecuada sin tener una sola condición en el código.\nPues con Spring eso se puede hacer usando la clase ServiceLocatorFactoryBean. Esta clase definida en la siguiente URL https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/beans/factory/config/ServiceLocatorFactoryBean.html implementa una fabrica de Beans, creando un proxy de tal manera que devuelve una clase tipo BeanFactory, la cual nos permitirá crear nuestros Beans dinámicamente.\nEsto que parece bastante confuso explicado así es realmente muy fácil de realizar. Pongámonos manos a la obra.\nEn el ejemplo que tenéis en https://github.com/chuchip/springboot-servicelocatorfactorybean esta la interfaz AdapterService, cuyo código como veis a continuación es muy simple:\npublic interface AdapterService { public String process(); }  Se crean 4 clases que implementan ese interface BikeService, BusService, TruckService y CarService. A continuación tenéis el código de CarService\n@Service(\u0026quot;Car\u0026quot;) public class CarService implements AdapterService { int numberExecution=1; @Override public String process() {\treturn \u0026quot;inside car service - number of executions: \u0026quot;+(numberExecution++); } }  Lo importante de esta clase es la etiqueta @Service(\u0026quot;car\u0026quot;) pues especificamos el nombre con el que deberemos cargar la clase.\nEn las demás clases existen las etiquetas: @Service(\u0026quot;Bike\u0026quot;), @Service(\u0026quot;Bus\u0026quot;) y @Service(\u0026quot;Truck\u0026quot;)siendo su código prácticamente idéntico, solo cambiando el mensaje a devolver.\nAhora se debe crear el interface que pasaremos a la clase ServiceLocatorFactoryBean en este ejemplo es la clase ServiceRegistry\npublic interface ServiceRegistry { public AdapterService getService(String serviceName); }  En esta clase deberemos definir la función getService que es la que ServiceLocatorFactoryBean invocara. Esta función debe recibir un parámetro que será el nombre del bean (el definido con las etiquetas @service), además devolverá un objeto que implemente el interfaz adecuado (en este caso AdapterService).\nEn la clase VehicleConfig definimos la función que nos devolverá el FactoryBean\n@Configuration public class VehicleConfig { @Bean public FactoryBean\u0026amp;lt;?\u0026amp;gt; factoryBean() { final ServiceLocatorFactoryBean bean = new ServiceLocatorFactoryBean(); bean.setServiceLocatorInterface(ServiceRegistry.class); return bean; } }  En ella, instanciamos una clase tipo ServiceLocatorFactoryBean, especificando el interface que debe devolver y luego retornamos ese objeto ServiceLocatorFactoryBean que por supuesto implementa el interfaz FactoryBean\nPara ver la funcionalidad de estos beans, en el proyecto de ejemplo, hemos creado un controlador rest muy simple.\n@RestController public class VehicleController { @Autowired private ServiceRegistry serviceRegistry; @GetMapping(\u0026quot;{vehicle}\u0026quot;) public String processGet(@PathVariable String vehicle) { return serviceRegistry.getService(vehicle).process(); } }  En ella, dependiendo de la URL llamada, que será volcada en la variable vehicle se llamara a una de las clases que implementan el interfaz AdapterService y todo ello sin un solo if\nAsí si ejecutamos:\n$ curl -s http://localhost:8080/Car inside car service - number of executions: 1 $ curl -s http://localhost:8080/Car inside car service - number of executions: 2  se puede observar como es cargada la clase CarServicey como se mantiene en el contexto de Spring, pues se puede ver como el numero de ejecuciones aumenta con cada llamada.\nSi ejecutamos las siguientes sentencias:\n$ curl -s http://localhost:8080/Truck inside truck service - number of executions: 1 $ curl -s http://localhost:8080/Truck inside truck service - number of executions: 2 $ curl -s http://localhost:8080/Car inside car service - number of executions: 3  podemos observar como funciona todo correctamente.\nPor supuesto si intentamos cargar un Bean no definido dará un error:\n$ curl -s http://localhost:8080/Boat {\u0026quot;timestamp\u0026quot;:\u0026quot;2019-04-18T21:07:23.139+0000\u0026quot;,\u0026quot;status\u0026quot;:500,\u0026quot;error\u0026quot;:\u0026quot;Internal Server Error\u0026quot;,\u0026quot;message\u0026quot;:\u0026quot;No bean named 'Boat' available\u0026quot;,\u0026quot;path\u0026quot;:\u0026quot;/Boat\u0026quot;}  Y de esta manera tan simple. gracias a la magia de Spring, se pueden crear programas fácilmente ampliables y modulares.\nHasta otra y no olvidéis seguirme en Twitter para estar al tanto de nuevas entradas de este blog.\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/beans/",
	"title": "beans",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/04/05/optimizando-consultas-con-hibernate/",
	"title": "Optimizando relaciones entre entidades en Hibernate",
	"tags": ["h2", "hibernate", "java", "jpa", "spring boot"],
	"description": "",
	"content": " En esta entrada, siguiendo el proyecto de ejemplo que teneis en https://github.com/chuchip/jpajoins explicando como optimizar las consultas a la base de datos usando JPA.\nSe verán diferentes tipos de consultas, explicando como realizar uniones entre tablas de modo perezoso (lazy) o agresivo (eager). Se unirán tablas por un solo campo, por varios e incluso por uno pero añadiendo una condición estática.\nEL proyecto de ejemplo esta desarrollado en Spring Boot con Hibernate, usando como base de datos H2.\nLas tablas están definidas en el fichero schema.sql y se cargan datos para pruebas en el fichero data.sql\nEste es el esquema de la base de datos:\nEn esa ocasión no voy a explicar el código pues es muy parecido al de otros programas que he explicado detalladamente en otras entradas. Me centrare en como realizar las diferentes consultas realizadas en el programa.\n Nota aclaratoria:\nSi el nombre de la entidad o de la columna en las clases Java tiene una mayúscula en medio, JPA interpretara que su hay un guion en medio y ese será la tabla o columna que buscara en la base de datos. De esta manera si a la clase Invoiceheader.java le renombráramos a InvoiceHeader.java Hibernate, buscaría la tabla invoice_header en la base de datos y fallaría pues no la encontraría.\nComo ejemplo se puede ver el campo line_details de la tabla invoiceDetails, que en la clase Invoicedetails.java (obsérvese que la D es minúscula) es llamada con la variable lineDetails.\n Realizando una \u0026#8216;select join\u0026#8216; entre la tabla cabeceras de factura (invoiceHeader) y clientes (customer)  Enlace perezoso  @ManyToOne(fetch=FetchType.LAZY) @JoinColumn(name=\"customerid\",referencedColumnName=\"id\") Customer customer;  Al realizar la búsqueda la consulta resultante sera:\nselect invoicehea0_.id as id1_3_0_, invoicehea0_.customerid as customer2_3_0_, invoicehea0_.fiscalyear as fiscalye3_3_0_, invoicehea0_.numberinvoice as numberin4_3_0_ from invoiceheader invoicehea0_ where invoicehea0_.id=?  y cuando se realice un consulta sobre la columna customer ejecutara la sentencia select necesaria para buscar los datos del cliente:\n select customer0_.id as id1_1_0_, customer0_.active as active2_1_0_, customer0_.address as address3_1_0_, customer0_.name as name4_1_0_ from customer customer0_ where customer0_.id=?   Enlace duro\n@ManyToOne(fetch=FetchType.EDGER) @JoinColumn(name=\u0026ldquo;customerid\u0026rdquo;,referencedColumnName=\u0026ldquo;id\u0026rdquo;)\nCustomer customer;\n  Al estar el tipo de búsqueda establecido a FetchType.EDGER realizara una única select con su correspondiente left outer join\n select invoicehea0_.id as id1_3_0_, invoicehea0_.customerid as customer2_3_0_, invoicehea0_.fiscalyear as fiscalye3_3_0_, invoicehea0_.numberinvoice as numberin4_3_0_, customer1_.id as id1_1_1_, customer1_.active as active2_1_1_, customer1_.address as address3_1_1_, customer1_.name as name4_1_1_ from invoiceheader invoicehea0_ left outer join customer customer1_ on invoicehea0_.customerid=customer1_.id where invoicehea0_.id=?   Rizando el rizo.Añadiendo valores fijos  Pero, ¿y si queremos que nos enlace las dos tablas por una columna y además con un valor fijo en otra?\nEn la tabla customer se definió la columna active y queremos que solo nos muestre los datos de la factura cuando el valor de esa columna sea 1 Para ello necesitaremos la ayuda de la etiqueta @JoinColumnsOrFormulas que nos permite realizar uniones tanto entre dos columnas como estableciendo valores a la columna de la tabla destino (en este caso customer)\n@ManyToOne(fetch=FetchType.EDGER) @JoinColumnsOrFormulas({ @JoinColumnOrFormula(column=@JoinColumn(name=\u0026quot;customerid\u0026quot;, referencedColumnName =\u0026quot;id\u0026quot;) ), @JoinColumnOrFormula(formula = @JoinFormula(value=\u0026quot;1\u0026quot;,referencedColumnName = \u0026quot;active\u0026quot;)) }) Customer customer;  La select ejecutada será:\nselect invoicehea0_.id as id1_3_0_, invoicehea0_.customerid as customer2_3_0_, invoicehea0_.fiscalyear as fiscalye3_3_0_, invoicehea0_.numberinvoice as numberin4_3_0_, 1 as formula1_0_, customer1_.id as id1_1_1_, customer1_.active as active2_1_1_, customer1_.address as address3_1_1_, customer1_.name as name4_1_1_ from invoiceheader invoicehea0_ left outer join customer customer1_ on invoicehea0_.customerid=customer1_.id and 1=customer1_.active where invoicehea0_.id=?  En el caso de que no encuentre ningún registro, la variable customer tendrá un valor nulo.\nSi el tipo de enlace fuera lazy como en el caso anterior se haría primero una query sobre la tabla invoiceheader y cuando se pidiera el valor de la variable customer se realizaría sobre su correspondiente tabla.\nUniendo tabla cabeceras facturas y líneas de facturas. Para unir las dos tablas pondremos el siguiente código en la clase Invoicedetails.java\n@OneToMany @JoinColumns( { @JoinColumn(name=\"fiscalyear\",referencedColumnName=\"fiscalyear\"), @JoinColumn(name=\"numberinvoice\",referencedColumnName=\"numberinvoice\") } ) @OrderBy(\"linea desc\") List\u0026lt;Invoicedetails\u0026gt; details;  Como se ve, al ser dos campos los que unen ambas tablas haremos uso de la etiqueta @JoinColumns con sus correspondientes @JoinColumn dentro.\nComo no hemos especificado nada, la unión se hará del tipo EAGER por lo cual la consulta realizada a la base de datos será la siguiente:\n select invoicehea0_.id as id1_3_0_, invoicehea0_.customerid as customer2_3_0_, invoicehea0_.fiscalyear as fiscalye3_3_0_, invoicehea0_.numberinvoice as numberin4_3_0_, 1 as formula1_0_, details1_.fiscalyear as fiscalye2_2_1_, details1_.numberinvoice as numberin5_2_1_, details1_.id as id1_2_1_, details1_.id as id1_2_2_, details1_.articleid as articlei6_2_2_, details1_.fiscalyear as fiscalye2_2_2_, details1_.linea_details as linea_de3_2_2_, details1_.numberarticles as numberar4_2_2_, details1_.numberinvoice as numberin5_2_2_, article2_.id as id1_0_3_, article2_.description as descript2_0_3_, article2_.price as price3_0_3_ from invoiceheader invoicehea0_ left outer join invoicedetails details1_ on invoicehea0_.fiscalyear=details1_.fiscalyear and invoicehea0_.numberinvoice=details1_.numberinvoice left outer join article article2_ on details1_.articleid=article2_.id where invoicehea0_.id=?  El ultimo \u0026#8220;left outer join\u0026#8221; haciendo referencia a la tabla article lo pone Hibernate porque en la clase Invoicedetails.java tenemos el código:\n@ManyToOne(fetch=FetchType.EAGER) @JoinColumns({ @JoinColumn(name=\u0026quot;articleid\u0026quot;,referencedColumnName=\u0026quot;id\u0026quot;) }) Article articles;  para que nos muestre los datos del articulo por cada línea del articulo, y como esta marcada la unión a tipo EAGER, Hibernate es lo suficientemente listo para hacer una sola consulta a la base de datos.\nSi realizamos un llamada a http://localhost:8080/1 observaremos la siguiente salida que devuelve la clase Invoiceheader.java veremos lo siguiente:\n{ \u0026quot;id\u0026quot;: 1, \u0026quot;yearFiscal\u0026quot;: 2019, \u0026quot;numberInvoice\u0026quot;: 1, \u0026quot;customerId\u0026quot;: 1, \u0026quot;customer\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;: \u0026quot;customer 1 name\u0026quot;, \u0026quot;address\u0026quot;: \u0026quot;customer 1 address\u0026quot;, \u0026quot;active\u0026quot;: 1 }, \u0026quot;details\u0026quot;: [ { \u0026quot;id\u0026quot;: 2, \u0026quot;year\u0026quot;: 2019, \u0026quot;invoice\u0026quot;: 1, \u0026quot;linea\u0026quot;: 2, \u0026quot;numberarticles\u0026quot;: 3, \u0026quot;articles\u0026quot;: { \u0026quot;id\u0026quot;: 2, \u0026quot;description\u0026quot;: \u0026quot;article 2 description\u0026quot;, \u0026quot;price\u0026quot;: 12.3 } }, { \u0026quot;id\u0026quot;: 1, \u0026quot;year\u0026quot;: 2019, \u0026quot;invoice\u0026quot;: 1, \u0026quot;linea\u0026quot;: 1, \u0026quot;numberarticles\u0026quot;: 5, \u0026quot;articles\u0026quot;: { \u0026quot;id\u0026quot;: 1, \u0026quot;description\u0026quot;: \u0026quot;article 1 description\u0026quot;, \u0026quot;price\u0026quot;: 10.1 } } ] }  ¿ No veis algo raro ?. ¡Efectivamente!. Las lineas las saca ordenadas de mayor a menor (primero la linea 2, luego la 1). Evidentemente eso es debido a la etiqueta @OrderBy(\u0026ldquo;linea desc\u0026rdquo;) , de la cual hay que destacar dos cosas:\n El campo al que hacemos referencia es como es nombrado en la entidad. Así aunque en la base de datos se llama lineaDetails se referencia por la etiqueta linea que es como se nombra la variable  @Column (name=\"lineaDetails\") int linea; // La 'D' esta en mayuscualas adrede para que mapee el campo linea_details  En la consulta que hace a la base de datos no introduce la clausula \u0026#8216;order by\u0026#8217; . Es decir es el propio hibernate el que encarga de ordenar los resultados. Tenerlo en cuenta cuando haya miles de registros devueltos.  Y así queda demostrado la importancia de establecer el tipo de unión pues si imaginamos una factura que tenga miles de líneas (improbable lo sé), si establecemos el método de unión a lazy en vez de hacer una sola consulta a la base de datos, haría 1000 lo cual, por supuesto ralentizaría muchísimo nuestra consulta, aparte de sobrecargar innecesariamente el servidor de la base de datos\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/h2/",
	"title": "h2",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/h2/",
	"title": "h2",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/hibernate/",
	"title": "hibernate",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/hibernate/",
	"title": "hibernate",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jpa/",
	"title": "jpa",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/jpa/",
	"title": "jpa",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/03/25/accediendo-facilmente-a-los-datos-con-spring-rest-data/",
	"title": "Accediendo facilmente a los datos con Spring Rest Data",
	"tags": ["java", "jpa", "json", "rest", "spring boot"],
	"description": "",
	"content": " Spring Boot ofrece un fantástico soporte para acceder a los datos con JPA a través de sus interfaces, del tipo Repository. Si a esto le añadimos la facilidad con que se crean servicios REST, como explicaba en la entrada [http://www.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-con-springboot/][2] podremos hacer una aplicación ofreciendo una API para acceder a nuestra base de datos preferida muy facilmente.\nPero si queremos implementar HATEOAS en nuestro proyecto o si hay muchos criterios sobre los que debemos acceder a los datos, deberemos escribir bastante código. Para solucionar este problema Spring Boot provee el paquete Spring Data Rest con el cual con apenas código podremos crear una API para acceder a las tablas de nuestra base de datos.\nEn el ejemplo que tenéis disponible en mi página de GITHUB veremos como poder realizar el mantenimiento de una tabla de clientes (customers) sin escribir ni una sola línea para definir las diferentes APIS REST.\nCreando el proyecto Como siempre, podremos ir a la pagina https://start.spring.io para crear nuestro proyecto maven. Para el proyecto de ejemplo que vamos a crear, deberemos incluir las siguientes dependencias:\nSpring Data Rest, H2, JPA, Lombok como se ve en la siguiente captura de pantalla\nUna vez tengamos hayamos importado el proyecto en nuestro IDE preferido, deberemos modificar el fichero application.properties para definir ciertos parámetros:\n#H2 spring.h2.console.enabled=true spring.h2.console.path=/h2 #JPA spring.jpa.show-sql=true spring.jpa.hibernate.ddl-auto=create-drop # Datasource spring.datasource.url=jdbc:h2:file:~/test spring.datasource.username=sa spring.datasource.password= spring.datasource.driver-class-name=org.h2.Driver # Data Rest spring.data.rest.base-path: /api  De este fichero la única entrada relativa a la librería Data Rest es la última. En ella especificamos la dirección donde se deben implementar las llamadas REST para acceder a las diferentes tablas que implemente nuestra aplicación. Es decir, en nuestro caso, se accederá a través de la URL: http://localhost:8080/api\nLas demás líneas configuran la base de datos H2 que usaremos, así como ciertas propiedades de JPA. Por supuesto dejaremos a JPA que cree la estructura de la base de datos a través de las entidades definidas, gracias a la sentencia: spring.jpa.hibernate.ddl-auto=create-drop\n ### Estructura del proyecto  Nuestro proyecto final tendrá la siguiente estructura:\nComo se puede ver, definiremos dos tablas (entities) , que son: City y Customer. También definimos los correspondientes repositorios CustomerRepository y CityRepository\nLa clase CityEntity.java es la siguiente:\n@Entity @Data @RestResource(rel=\u0026quot;customers\u0026quot;, path=\u0026quot;customer\u0026quot;) public class CustomerEntity {\t@Id long id;\t@Column String name;\t@Column String address;\t@Column String telephone;\t@Column @JsonIgnore String secret; @OneToOne CityEntity city; }  Las particularidades de esta clase son las siguientes:\n la línea @RestResource donde con el parámetro rel especificamos como debe llamarse el objeto en la salida JSON. Con el parámetro path se indica donde se debe realizar la petición HTTP. La anotación @JsonIgnore aplicada a la columna secret. Con esta etiqueta ese campo será ignorado, de tal manera que ni se mostrara en las salidas, ni se actualizara, aunque se incluya, en las peticiones.  Si no pusiéramos la etiqueta @RestResource Spring presentaría el recurso para acceder a la entidad en http://localhost:8080/api/customerEntities es decir usaría el nombre de la clase, poniéndolo en plural , por lo cual le añade \u0026#8216;es\u0026#8217;.\nEl repositorio de esta entidad esta en CustomerRepository y contiene solo estas líneas:\npublic interface CustomerRepository extends CrudRepository\u0026amp;lt;CustomerEntity, Long\u0026amp;gt; {\tpublic List\u0026amp;lt;CustomerEntity\u0026amp;gt; findByNameIgnoreCaseContaining(@Param(\u0026quot;name\u0026quot;) String name); }  La función findByNameIgnoreCaseContaining que he definido permitirá buscar los clientes, ignorando mayúsculas y minúsculas, cuyo nombre contengan la cadena mandada. Más adelante explicare como poder realizar una consulta a través de esta llamada con Spring Data Rest\nTenéis más documentación sobre como crear consultas personalizadas en Spring en esta otra entrada mía.\nLa clase CityEntity.java contiene las siguientes líneas:\n@Entity @Data @RestResource(exported=false) public class CityEntity {\t@Id int id; @Column String name; @Column String province; }  En este caso la etiqueta @RestResource tiene indicada la propiedad exported igual a false para que esta entidad no sea tratada por Data Rest y no sera accesible a traves de ninguna API.\nAccediendo al API de Data Rest Los recursos que están publicados estarán disponibles en la URL: http://localhost:8080/api, como hemos definido en el fichero application.properties. Esta será la salida en este proyecto:\n\u0026gt; curl -s http://localhost:8080/api/ { \u0026quot;_links\u0026quot; : { \u0026quot;customers\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer\u0026quot; }, \u0026quot;profile\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/profile\u0026quot; } } }  El profile se refiere a lo definido en el RFC 6906, donde se incluye detalles de la aplicación, pero no tratare de ello en esta entrada.\nPara acceder al único recurso disponible en nuestro proyecto, al que hemos llamado customer, navegaremos a: http://localhost:8080/api/customer .\nPrimero añadamos un registro. Esto lo realizaremos realizando una petición tipo POST como la siguiente:\n\u0026gt; curl -s --request POST localhost:8080/api/customer -d '{\u0026quot;id\u0026quot;: 1, \u0026quot;name\u0026quot;:\u0026quot;nombre cliente 1\u0026quot;,\u0026quot;address\u0026quot;:\u0026quot;direccion cliente 1\u0026quot;,\u0026quot;telephone\u0026quot;:\u0026quot;telefono cliente 1\u0026quot;, \u0026quot;secret\u0026quot;: \u0026quot;no guardar\u0026quot;}' -H \u0026quot;Content-Type: application/json\u0026quot; { \u0026quot;name\u0026quot; : \u0026quot;nombre cliente 1\u0026quot;, \u0026quot;address\u0026quot; : \u0026quot;direccion cliente 1\u0026quot;, \u0026quot;telephone\u0026quot; : \u0026quot;telefono cliente 1\u0026quot;, \u0026quot;city\u0026quot; : null, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; }, \u0026quot;customerEntity\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; } }  Podemos comprobar que ha realizado la inserción gracias a la consola de H2. Para ello iremos a la URL http://localhost:8080/h2/ y pulsaremos el botón Connect. Una vez conectados, si realizamos una query sobre la tabla CUSTOMER_ENTITY veremos la siguiente salida:\nObservar que aunque hemos añadido el valor para el campo \u0026#8220;secret\u0026#8221; en la anterior petición POST, este no se ha guardado en la base de datos.\nComo no podemos acceder a la tabla city_entity a través de nuestra API pues así lo hemos especificado, Vamos a aprovechar que estamos en la consola y añadir un registro en la tabla, el cual asignaremos al cliente insertado.\ninsert into city_entity values(1,'Logroño','La Rioja'); update customer_entity set city_id=1;  ![Consultando datos en tabla customer_entity][/img/2019/03/consola-h2.png]\nAhora si realizamos una petición GET obtendremos la siguiente salida:\n\u0026gt; curl -s localhost:8080/api/customer { \u0026quot;_embedded\u0026quot; : { \u0026quot;customers\u0026quot; : [ { \u0026quot;name\u0026quot; : \u0026quot;nombre cliente 1\u0026quot;, \u0026quot;address\u0026quot; : \u0026quot;direccion cliente 1\u0026quot;, \u0026quot;telephone\u0026quot; : \u0026quot;telefono cliente 1\u0026quot;, \u0026quot;city\u0026quot; : { \u0026quot;name\u0026quot; : \u0026quot;Logroño\u0026quot;, \u0026quot;province\u0026quot; : \u0026quot;La Rioja\u0026quot; }, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; }, \u0026quot;customerEntity\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; } } } ] }, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer\u0026quot; }, \u0026quot;profile\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/profile/customer\u0026quot; }, \u0026quot;search\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/search\u0026quot; } } }  Observar como HATEOAS muestra los diferentes enlaces disponibles automagicamente\nPor ejemplo podríamos consultar directamente el cliente con el código 1 navegando a http://localhost:8080/api/customer/1\n\u0026gt; curl -s localhost:8080/api/customer/1 { \u0026quot;name\u0026quot; : \u0026quot;nombre cliente 1\u0026quot;, \u0026quot;address\u0026quot; : \u0026quot;direccion cliente 1\u0026quot;, \u0026quot;telephone\u0026quot; : \u0026quot;telefono cliente 1\u0026quot;, \u0026quot;city\u0026quot; : { \u0026quot;name\u0026quot; : \u0026quot;Logroño\u0026quot;, \u0026quot;province\u0026quot; : \u0026quot;La Rioja\u0026quot; }, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; }, \u0026quot;customerEntity\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; } } }  Como he explicado antes, en el repositorio de Customer he definido la función findByNameIgnoreCaseContaining. Para realizar una consulta usando esa función usaremos los enlaces tipo search\nhttp://localhost:8080/api/customer/search/findByNameIgnoreCaseContaining{?name}\n\u0026gt; curl -s http://localhost:8080/api/customer/search/findByNameIgnoreCaseContaining?name=Clien { \u0026quot;_embedded\u0026quot; : { \u0026quot;customers\u0026quot; : [ { \u0026quot;name\u0026quot; : \u0026quot;nombre cliente 1\u0026quot;, \u0026quot;address\u0026quot; : \u0026quot;direccion cliente 1\u0026quot;, \u0026quot;telephone\u0026quot; : \u0026quot;telefono cliente 1\u0026quot;, \u0026quot;city\u0026quot; : { \u0026quot;name\u0026quot; : \u0026quot;Logroño\u0026quot;, \u0026quot;province\u0026quot; : \u0026quot;La Rioja\u0026quot; }, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; }, \u0026quot;customerEntity\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/1\u0026quot; } } } ] }, \u0026quot;_links\u0026quot; : { \u0026quot;self\u0026quot; : { \u0026quot;href\u0026quot; : \u0026quot;http://localhost:8080/api/customer/search/findByNameIgnoreCaseContaining?name=Clien\u0026quot; } } }  Por no hacer más larga la entrada no explicare como actualizar un registro, con peticiones HTTP tipo PUT, borrar registros con peticiones HTTP tipo DELETE o actualizar parte de un registro con PATCH, pues creo que es obvio y lo dejo como ejercicio para el lector.\nComentar que lo mostrado en este articulo es solo un esbozo de la potencia de Spring Data Rest.\nEstas son algunas de las otras muchas características que implementa:\n Permite añadir eventos de tal manera que cuando se inserte, modifique, borre o incluso consulte un registro ese evento sea disparado y se puedan ejecutar el código deseado, el cual incluso puede modificar o anular la petición realizada. Por supuesto soporta navegación Soporta navegación entre los registros consultados. Validación de los datos insertados Los Links pueden ser totalmente personalizados.  Y esto es todo, esperando que el articulo haya resultado interesante me despido hasta el siguiente. Como siempre se agradecerá cualquier feedback.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/crud/",
	"title": "CRUD",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/json/",
	"title": "json",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/json/",
	"title": "json",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/03/16/zuul-para-redirigir-peticiones-rest-en-spring-boot/",
	"title": "Usando Zuul para redirigir peticiones REST",
	"tags": ["cloud", "gateway", "java", "spring boot", "zuul"],
	"description": "",
	"content": " En este articulo explicare como crear una pasarela para peticiones REST (una gateway) utilizando Zuul.\nZuul es parte del paquete Spring Cloud NetFlix y permite redirigir peticiones REST, realizando diversos tipos de filtros.\nEn casi cualquier proyecto donde haya microservicios, es deseable que todas las comunicaciones entre esos microservicios pasen por un lugar común, de tal manera que se registren las entradas y salidas, se pueda implementar seguridad o se puedan redirigir las peticiones dependiendo de diversos parámetros.\nCon Zuul esto es muy fácil de implementar ya que esta perfectamente integrado con Spring Boot.\nComo siempre en mi página de GitHub podéis ver los fuentes sobre los que esta basado este articulo.\nCreando el proyecto. Si tenemos instalado Eclipse con el plugin de Spring Boot (lo cual recomiendo), el crear el proyecto seria tan fácil como añadir un nuevo proyecto del tipo Spring Boot incluyendo el starter Zuul. Para poder hacer algunas pruebas también incluiremos el starter Web, como se ve en la imagen:\nTambien tenemos la opción de crear un proyecto Maven desde la página web https://start.spring.io/ que luego importaremos desde nuestro IDE preferido.\nEmpezando Partiendo que nuestro programa esta escuchando en http://localhost:8080/ , vamos a a suponer que queremos que todo lo que vaya a la URL, http://localhost:8080/google sea redirigida a https://www.google.com.\nPara ello deberemos crear el fichero application.yml dentro del directorio resources, como se ve en la imagen\nEn este fichero incluiremos las siguientes líneas:\nzuul: routes: google: path: /google/** url: https://www.google.com/  Con ellas especificaremos que todo lo que vaya a la ruta /google/ y algo más (**) sea redirigido a https://www.google.com/ , teniendo en cuenta que si por ejemplo la petición es realizada http://localhost:8080/google/search?q=profesor_p esta será redirigida a https://www.google.com/search?q=profesor_p. Es decir lo que añadamos después de /google/ será incluido en la redirección, debido a los dos asteriscos añadidos al final del path.\nPara que el programa funcione solo será necesario añadir la anotación @EnableZuulProxyen la clase de inicio, en este caso en: ZuulSpringTestApplication\nimport org.springframework.cloud.netflix.zuul.EnableZuulProxy; @SpringBootApplication @EnableZuulProxy public class ZuulSpringTestApplication { public static void main(String[] args) { SpringApplication.run(ZuulSpringTestApplication.class, args); } }  Para poder demostrar las diversas funcionalidades de ZUUL, en http://localhost:8080/api estará escuchando un servicio REST que esta implementada en la clase TestController de este proyecto. Esta clase simplemente devuelve en el cuerpo, los datos de la petición recibida.\n@RestController public class TestController { final static String SALTOLINEA=\u0026quot;\\n\u0026quot;; Logger log = LoggerFactory.getLogger(TestController.class); @RequestMapping(path=\u0026quot;/api\u0026quot;) public String test(HttpServletRequest request) { StringBuffer strLog=new StringBuffer(); strLog.append(\u0026quot;................ RECIBIDA PETICION EN /api ...... \u0026quot;+SALTOLINEA); strLog.append(\u0026quot;Metodo: \u0026quot;+request.getMethod()+SALTOLINEA); strLog.append(\u0026quot;URL: \u0026quot;+request.getRequestURL()+SALTOLINEA); strLog.append(\u0026quot;Host Remoto: \u0026quot;+request.getRemoteHost()+SALTOLINEA); strLog.append(\u0026quot;----- MAP ----\u0026quot;+SALTOLINEA); request.getParameterMap().forEach( (key,value) -\u0026amp;gt; { for (int n=0;n\u0026amp;lt;value.length;n++) { strLog.append(\u0026quot;Clave:\u0026quot;+key+ \u0026quot; Valor: \u0026quot;+value[n]+SALTOLINEA); } } ); strLog.append(SALTOLINEA+\u0026quot;----- Headers ----\u0026quot;+SALTOLINEA); Enumeration\u0026amp;lt;String\u0026amp;gt; nameHeaders=request.getHeaderNames();\twhile (nameHeaders.hasMoreElements()) { String name=nameHeaders.nextElement(); Enumeration\u0026amp;lt;String\u0026amp;gt; valueHeaders=request.getHeaders(name); while (valueHeaders.hasMoreElements()) { String value=valueHeaders.nextElement(); strLog.append(\u0026quot;Clave:\u0026quot;+name+ \u0026quot; Valor: \u0026quot;+value+SALTOLINEA); } } try { strLog.append(SALTOLINEA+\u0026quot;----- BODY ----\u0026quot;+SALTOLINEA); BufferedReader reader= request.getReader(); if (reader!=null) { char[] linea= new char[100]; int nCaracteres; while ((nCaracteres=reader.read(linea,0,100))\u0026amp;gt;0) {\tstrLog.append( linea); if (nCaracteres!=100) break; } } } catch (Throwable e) { e.printStackTrace(); } log.info(strLog.toString()); return SALTOLINEA+\u0026quot;---------- Prueba de ZUUL ------------\u0026quot;+SALTOLINEA+ strLog.toString(); } }  Filtrando: Dejando logs En esta parte vamos a ver como crear un filtro de tal manera que se deje un registro de las peticiones realizadas.\nPara ello crearemos la clase PreFilter.java la cual debe extender de ZuulFilter\npublic class PreFilter extends ZuulFilter { Logger log = LoggerFactory.getLogger(PreFilter.class); @Override public Object run() { RequestContext ctx = RequestContext.getCurrentContext(); StringBuffer strLog=new StringBuffer(); strLog.append(\u0026quot;\\n------ NUEVA PETICION ------\\n\u0026quot;); strLog.append(String.format(\u0026quot;Server: %s Metodo: %s Path: %s \\n\u0026quot;,ctx.getRequest().getServerName() ,ctx.getRequest().getMethod(), ctx.getRequest().getRequestURI())); Enumeration\u0026lt;String\u0026gt; enume= ctx.getRequest().getHeaderNames(); String header; while (enume.hasMoreElements()) { header=enume.nextElement(); strLog.append(String.format(\u0026quot;Headers: %s = %s \\n\u0026quot;,header,ctx.getRequest().getHeader(header))); }; log.info(strLog.toString()); return null; } @Override public boolean shouldFilter() { return true; } @Override public int filterOrder() { return FilterConstants.SEND_RESPONSE_FILTER_ORDER; } @Override public String filterType() { return \u0026quot;pre\u0026quot;; } }  En esta clase deberemos sobrescribir las funciones que vemos en el fuente. A continuación explico que haremos en cada de ellas\n public Object run()Aquí pondremos lo que queremos que se ejecute por cada petición recibida. En ella podremos ver el contenido de la petición y manipularla si fuera necesario. public boolean shouldFilter()Si devuelve true se ejecutara la función run . public int filterOrder()Devuelve cuando que se ejecutara este filtro, pues normalmente hay diferentes filtros, para cada tarea. Hay que tener en cuenta que ciertas redirecciones o cambios en la petición hay que hacerlas en ciertos ordenes, por la misma lógica que tiene zuul a la hora de procesar las peticiones. public String filterType() Especifica cuando se ejecutara el filtro. Si devuelve \u0026#8220;pre\u0026#8221; se ejecutara antes de que se haya realizado la redirección y por lo tanto antes de que se haya llamado al servidor final (a google en nuestro ejemplo).Si devuelve \u0026#8220;post\u0026#8221; se ejecutara después de que el servidor haya respondido a la petición.En la clase org.springframework.cloud.netflix.zuul.filters.support.FilterConstants tenemos definidos los tipos a devolver, PRE_TYPE , POST_TYPE,ERROR_TYPE o ROUTE_TYPE.  En la clase de ejemplo vemos como antes de realizar la petición al servidor final, se registran algunos datos de la petición, dejando un log con ellos.\nPor último, para que Spring Boot utilize este filtro debemos añadir la función siguiente en nuestra clase principal.\n@Bean public PreFilter preFilter() { return new PreFilter(); }  Zuul buscara beans hereden de la clase ZuulFilter y los usara.\nEn este ejemplo, también esta la clase PostFilter.java que implementa otro filtro pero que se ejecuta después de realizar la petición al servidor final. Como he comentado esto se consigue devolviendo \u0026#8220;post\u0026#8221; en la función filterType().\nPara que Zuul use esta clase deberemos crear otro bean con una función como esta:\n @Bean public PostFilter postFilter() { return new PostFilter(); }  Recordar que también hay un filtro para tratar los errores y otro para tratar justo después de la redirección (\u0026#8220;route\u0026#8221;), pero en este articulo solo hablare de los filtros tipo \u0026#8220;post\u0026#8221; y tipo \u0026#8220;pre\u0026#8221;\nAclarar que aunque no lo trato en este articulo con Zuul no solo podemos redirigir hacia URL estáticas sino también a servicios, suministrados por Eureka Server, del cual hable en un articulo articulo. Además se integra con Hystrix para tener tolerancia a fallos, de tal manera que si no puede alcanzar un servidor se puede especificar que acción tomar.\n ## Filtrando. Implementando seguridad  Añadamos una nueva redirección al fichero application.yml\n sensitiveHeaders: usuario, clave privado: path: /privado/** url: http://www.profesor-p.com  Esta redirección llevara cualquier petición tipo http://localhost:8080/privado/LO_QUE_SEA a la pagina donde esta este articulo (http://www.profesor-p.com )\nLa linea sensitiveHeaders la explicare más adelante.\nEn la clase PreRewriteFilterhe implementando otro filtro tipo pre que trata solo esta redirección. ¿ como ?. Fácil, poniendo este código en la función shouldFilter()\n@Override public boolean shouldFilter() { return RequestContext.getCurrentContext().getRequest().getRequestURI().startsWith(\u0026quot;/privado\u0026quot;); }  Ahora en la función run incluimos el siguiente código\n Logger log = LoggerFactory.getLogger(PreRewriteFilter.class); @Override public Object run() {\tRequestContext ctx = RequestContext.getCurrentContext();\tStringBuffer strLog=new StringBuffer(); strLog.append(\u0026quot;\\n------ FILTRANDO ACCESO A PRIVADO - PREREWRITE FILTER ------\\n\u0026quot;);\ttry {\tString url=UriComponentsBuilder.fromHttpUrl(\u0026quot;http://localhost:8080/\u0026quot;).path(\u0026quot;/api\u0026quot;).build().toUriString(); String usuario=ctx.getRequest().getHeader(\u0026quot;usuario\u0026quot;)==null?\u0026quot;\u0026quot;:ctx.getRequest().getHeader(\u0026quot;usuario\u0026quot;); String password=ctx.getRequest().getHeader(\u0026quot;clave\u0026quot;)==null?\u0026quot;\u0026quot;:ctx.getRequest().getHeader(\u0026quot;clave\u0026quot;); if (! usuario.equals(\u0026quot;\u0026quot;)) { if (!usuario.equals(\u0026quot;profesorp\u0026quot;) || !password.equals(\u0026quot;profe\u0026quot;)) { String msgError=\u0026quot;Usuario y/o contraseña invalidos\u0026quot;; strLog.append(\u0026quot;\\n\u0026quot;+msgError+\u0026quot;\\n\u0026quot;);\tctx.setResponseBody(msgError); ctx.setResponseStatusCode(HttpStatus.FORBIDDEN.value()); ctx.setSendZuulResponse(false); log.info(strLog.toString());\treturn null; } ctx.setRouteHost(new URL(url)); }\t} catch ( IOException e) { // TODO Auto-generated catch block e.printStackTrace(); } log.info(strLog.toString()); return null; }  Esta función busca en las cabeceras de la petición (headers) si existe la cabecera usuario, en caso de no encontrarla no hace nada con lo cual redireccionara a http://www.profesor-p.com como se indica en el filtro. En el caso de que exista la cabecera usuario con el valor profesorpy que la variable clave tenga el valor profe, se redirigirá a http://localhost:8080/api. En caso contrario devolverá un código HTTP FORBIDEN devolviendo la cadena \u0026quot;Usuario y/o contraseña invalidos\u0026quot; en el cuerpo de la respuesta HTTP. Ademas se cancela el flujo de la petición debido a que se llama a ctx.setSendZuulResponse(false)\nDebido a la linea sensitiveHeaders del fichero application.yml que he mencionado anteriormente las cabeceras \u0026#8216;usuario\u0026#8216; y \u0026#8216;clave\u0026#8216; no serán pasadas en el flujo de la petición.\nEs muy importante que este filtro se ejecute despues del filtro de PRE_DECORATION, pues en caso contrario la llamada a ctx.setRouteHost() no tendra efecto. Por ello en la función filterOrder tenemos este código:\n@Override public int filterOrder() { return FilterConstants.PRE_DECORATION_FILTER_ORDER+1; }  Así una llamada pasando el usuario y la constraseña correctas, nos redirigira a http://localhost:8080/api\n\u0026gt; curl -s -H \u0026quot;usuario: profesorp\u0026quot; -H \u0026quot;clave: profe\u0026quot; localhost:8080/privado ---------- Prueba de ZUUL ------------ ................ RECIBIDA PETICION EN /api ...... Metodo: GET URL: http://localhost:8080/api Host Remoto: 127.0.0.1 ----- MAP ---- ----- Headers ---- Clave:user-agent Valor: curl/7.63.0 Clave:accept Valor: */* Clave:x-forwarded-host Valor: localhost:8080 Clave:x-forwarded-proto Valor: http Clave:x-forwarded-prefix Valor: /privado Clave:x-forwarded-port Valor: 8080 Clave:x-forwarded-for Valor: 0:0:0:0:0:0:0:1 Clave:accept-encoding Valor: gzip Clave:host Valor: localhost:8080 Clave:connection Valor: Keep-Alive ----- BODY ----  Si se pone mal la contraseña la salida seria esta:\n\u0026gt; curl -s -H \u0026quot;usuario: profesorp\u0026quot; -H \u0026quot;clave: ERROR\u0026quot; localhost:8080/privado Usuario y/o contraseña invalidos  ###Filtrando. Filtrado dinámico\nPara terminar incluiremos dos nuevas redirecciones en el fichero applicaction.yml\n local: path: /local/** url: http://localhost:8080/api url: path: /url/** url: http://url.com  En la primera cuando vayamos a la URL http://localhost:8080/local/LO_QUE_SEA seremos redirigidos a http://localhost:8080/api/LO_QUE_SEA. Aclarar que la etiqueta local:es arbitraria y podría poner pepe no teniendo porque coincidir con el path que deseamos redirigir.\nEn la segunda cuando vayamos a la URL http://localhost:8080/url/LO_QUE_SEA seremos redirigidos a http://localhost:8080/api/LO_QUE_SEA\nLa clase RouteURLFilter sera la encargada de realizar tratar el filtro URL. Recordar que para que Zuul utilize los filtros debemos crear su correspondiente bean.\n@Bean public RouteURLFilter routerFilter() { return new RouteURLFilter(); }  En la función shouldFilter de RouteURLFilter tendremos este código para que trate solo las peticiones a /url.\n@Override public boolean shouldFilter() { RequestContext ctx = RequestContext.getCurrentContext(); if ( ctx.getRequest().getRequestURI() == null || ! ctx.getRequest().getRequestURI().startsWith(\u0026quot;/url\u0026quot;)) return false; return ctx.getRouteHost() != null \u0026amp;\u0026amp; ctx.sendZuulResponse(); }  Este filtro será declarado del tipo pre en la función filterType por lo cual se ejecutara después de los filtros pre y antes de ejecutar la redirección y llamar al servidor final.\n @Override public String filterType() { return FilterConstants.PRE_TYPE; }  En la función run esta el código que realiza la magia. Una vez hayamos capturado la URL de destino y el path, como explico más adelante, es utilizada la función setRouteHost() del RequestContext para redirigirla adecuadamente.\n @Override public Object run() { try { RequestContext ctx = RequestContext.getCurrentContext(); URIRequest uriRequest; try { uriRequest = getURIRedirection(ctx); } catch (ParseException k) { ctx.setResponseBody(k.getMessage()); ctx.setResponseStatusCode(HttpStatus.BAD_REQUEST.value()); ctx.setSendZuulResponse(false); return null; } UriComponentsBuilder uriComponent = UriComponentsBuilder.fromHttpUrl(uriRequest.getUrl()); if (uriRequest.getPath() == null) uriRequest.setPath(\u0026quot;/\u0026quot;); uriComponent.path(uriRequest.getPath()); String uri = uriComponent.build().toUriString(); ctx.setRouteHost(new URL(uri)); } catch (IOException k) { k.printStackTrace(); } return null; }  Si encuentra en el header la variable hostDestino será donde mandara la petición recibida. También buscara en la cabecera de la petición la variables pathDestino para añadirla al hostDestino.\nPor ejemplo, supongamos una petición como esta:\n\u0026gt; curl --header \u0026quot;hostDestino: http://localhost:8080\u0026quot; --header \u0026quot;pathDestino: api\u0026quot; \\ localhost:8080/url?nombre=profesorp  La llamada será redirigida a http://localhost:8080/api?q=profesor-p y mostrara la siguiente salida:\n---------- Prueba de ZUUL ------------ ................ RECIBIDA PETICION EN /api ...... Metodo: GET URL: http://localhost:8080/api Host Remoto: 127.0.0.1 ----- MAP ---- Clave:nombre Valor: profesorp ----- Headers ---- Clave:user-agent Valor: curl/7.60.0 Clave:accept Valor: */* Clave:hostdestino Valor: http://localhost:8080 Clave:pathdestino Valor: api Clave:x-forwarded-host Valor: localhost:8080 Clave:x-forwarded-proto Valor: http Clave:x-forwarded-prefix Valor: /url Clave:x-forwarded-port Valor: 8080 Clave:x-forwarded-for Valor: 0:0:0:0:0:0:0:1 Clave:accept-encoding Valor: gzip Clave:host Valor: localhost:8080 Clave:connection Valor: Keep-Alive ----- BODY ----  También puede recibir la URL a redireccionar en el cuerpo de la petición. El objeto JSON recibido debe tener el formato definido por la clase GatewayRequest que a su vez contiene un objeto URIRequest\npublic class GatewayRequest { URIRequest uri; String body; } public class URIRequest { String url; String path; byte[] body=null;  Este es un ejemplo de una redirección poniendo la URL destino en el body:\ncurl -X POST \\ 'http://localhost:8080/url?nombre=profesorp' \\ -H 'Content-Type: application/json' \\ -d '{ \u0026quot;body\u0026quot;: \u0026quot;El body chuli\u0026quot;, \u0026quot;uri\u0026quot;: { \u0026quot;url\u0026quot;:\u0026quot;http://localhost:8080\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;api\u0026quot; } }'  URL: \u0026#8220;http://localhost:8080/url?nombre=profesorp\u0026#8221;\nCuerpo de la petición:\n{ \"body\": \"El body chuli\", \"uri\": { \"url\":\"http://localhost:8080\", \"path\": \"api\" } }  La salida recibida será:\n---------- Prueba de ZUUL ------------ ................ RECIBIDA PETICION EN /api ...... Metodo: POST URL: http://localhost:8080/api Host Remoto: 127.0.0.1 ----- MAP ---- Clave:nombre Valor: profesorp ----- Headers ---- Clave:user-agent Valor: curl/7.60.0 Clave:accept Valor: */* Clave:content-type Valor: application/json Clave:x-forwarded-host Valor: localhost:8080 Clave:x-forwarded-proto Valor: http Clave:x-forwarded-prefix Valor: /url Clave:x-forwarded-port Valor: 8080 Clave:x-forwarded-for Valor: 0:0:0:0:0:0:0:1 Clave:accept-encoding Valor: gzip Clave:content-length Valor: 91 Clave:host Valor: localhost:8080 Clave:connection Valor: Keep-Alive ----- BODY ---- El body chuli  Como se ve el cuerpo es tratado y al servidor final solo es mandado lo que se envía en el parámetro body de la petición JSON\nComo se ve, Zuul tiene mucha potencia y es una excelente herramienta para realizar redirecciones. En este articulo solo he arañado las principales características de esta fantástica herramienta, pero espero que haya servido para ver las posibilidades que ofrece.\n¡¡Nos vemos en la próxima entrada!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/cloud/",
	"title": "cloud",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/cloud/",
	"title": "cloud",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/gateway/",
	"title": "gateway",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/seguridad/",
	"title": "seguridad",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/zuul/",
	"title": "zuul",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/zuul/",
	"title": "zuul",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/profiles/",
	"title": "profiles",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/profiles/",
	"title": "profiles",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/02/14/querys-avanzadas-con-jpa-en-spring-boot/",
	"title": "Querys avanzadas con JPA en Spring Boot",
	"tags": ["hibernate", "java", "jpa", "spring boot"],
	"description": "",
	"content": "Hay veces en que las campos sobre los que restringir una consulta pueden variar en tiempo de ejecución. En ese caso si queremos usar JPA no podemos usar una sentencia @Query definida en nuestro repositorio pues no sabemos los campos sobre los que se aplicaran condiciones en la consulta. Además es bastante común que el usuario pueda elegir el criterio de búsqueda sobre un campo, deseando que el valor de un campo deba ser igual, mayor o menor, respecto al valor introducido .\nEn Spring Boot podemos dar una solución a este problema usando un la clase CriteriaBuilder de nuestro EntityManager . En esta entrada os mostrare como hacerlo fácilmente.\nPara ello he creado un proyecto que he dejado en https://github.com/chuchip/CustomJpaQuery\nEn este programa podremos hacer una petición REST a la URL http://localhost:8080/get donde podremos pasar los siguientes parámetros, todos ellos opcionales:\n Identificador del cliente: idCustomer Nombre del Cliente: nameCustomer Dirección del cliente: addressCustomer Fecha creación del registro: createdDate. La fecha se debera mandar en formato español, es decir: \u0026#8220;dd-MM-yyyy\u0026#8221;. Por ejemplo: 31-01-2018. Condición del campo anterior: dateCondition. Tiene que ser una de estas tres cadenas de texto: \u0026#8220;greater\u0026#8221;,\u0026#8221;less\u0026#8221;, \u0026#8220;equal\u0026#8221; En caso de no poner ninguna condición o poner una condición no valida se usara greater  URLs de búsqueda podrían ser:\nhttp://localhost:8080/get?createdDate=21-01-2018\u0026amp;dateCondition=equal http://localhost:8080/get?createdDate=21-01-2018\u0026amp;dateCondition=greater\nhttp://localhost:8080/get?nameCustomer=Smith\u0026amp;createdDate=21-01-2018\nEl programa usa una base de datos H2 para crear una tabla simple de clientes (customers) con los campos: id,name,address,email y created_date. Llena después la tabla con los datos que podemos ver en el fichero data.sql\nPara realizar nuestra QUERY personalizada, en primer lugar, se crea un interface en CustomersRepository que extiende de JpaRepository . En este interface definimos la función getData como se ve en el siguiente código:\npublic interface CustomersRepository extends JpaRepository\u0026lt;CustomersEntity, Integer\u0026gt; { public List\u0026lt;CustomersEntity\u0026gt; getData(HashMap\u0026lt;String, Object\u0026gt; conditions);\t}  La función getData recibirá un HashMap donde iremos poniendo las condiciones de búsqueda. Así si queremos buscar los clientes cuyo código de cliente sea igual a 1, añadiremos una la llave \u0026#8216;id\u0026#8217; y el valor \u0026#8216;1\u0026#8243;\nHashMap\u0026lt;String,Object\u0026gt; hm= new HashMap\u0026lt;\u0026gt;(); hm.put(\u0026quot;id\u0026quot;,1);  Si deseamos que el nombre sea como \u0026#8216;Smith\u0026#8217;, añadiríamos este elemento al HashMap:\nhm.put(\u0026quot;name\u0026quot;,\u0026quot;Smith\u0026quot;);  Y así sucesivamente con todos los campos o condiciones deseadas. Una vez definido nuestro repositorio creamos una clase a la que obligatoriamente deberemos llamar CustomersRepositoryImpl es decir se debe llamar igual que nuestro interface del repositorio pero añadiendo la terminación impl (de implementación). En esta clase deberemos tener una función igual que la definida en el repositorio pues es la función que Spring Boot ejecutara cuando llamemos a la función definida en el interface. Este es el código de la clase que permitirá personalizar nuestra query:\npublic class CustomersRepositoryImpl{ @PersistenceContext private EntityManager entityManager; public List\u0026lt;CustomersEntity\u0026gt; getData(HashMap\u0026lt;String, Object\u0026gt; conditions) { CriteriaBuilder cb = entityManager.getCriteriaBuilder(); CriteriaQuery\u0026lt;CustomersEntity\u0026gt; query= cb.createQuery(CustomersEntity.class); Root\u0026lt;CustomersEntity\u0026gt; root = query.from(CustomersEntity.class); List\u0026lt;Predicate\u0026gt; predicates = new ArrayList\u0026lt;\u0026gt;(); conditions.forEach((field,value) -\u0026gt; { switch (field) { case \u0026quot;id\u0026quot;: predicates.add(cb.equal (root.get(field), (Integer)value)); break; case \u0026quot;name\u0026quot;: predicates.add(cb.like(root.get(field),\u0026quot;%\u0026quot;+(String)value+\u0026quot;%\u0026quot;)); break; case \u0026quot;address\u0026quot;: predicates.add(cb.like(root.get(field),\u0026quot;%\u0026quot;+(String)value+\u0026quot;%\u0026quot;)); break; case \u0026quot;created\u0026quot;: String dateCondition=(String) conditions.get(\u0026quot;dateCondition\u0026quot;);\tswitch (dateCondition) { case GREATER_THAN: predicates.add(cb.greaterThan(root.\u0026lt;Date\u0026gt;get(field),(Date)value)); break; case LESS_THAN: predicates.add(cb.lessThan(root.\u0026lt;Date\u0026gt;get(field),(Date)value)); break; case EQUAL: predicates.add(cb.equal(root.\u0026lt;Date\u0026gt;get(field),(Date)value)); break; } break; } }); query.select(root).where(predicates.toArray(new Predicate[predicates.size()])); return entityManager.createQuery(query).getResultList(); } }  Como se ve, lo primero es inyectar una referencia al objeto EntityManager con la etiqueta @PersistenceContext. En la función sobre el EntityManager crearemos un objeto CriteriaBuilder y sobre este objeto creamos un CriteriaQuery donde iremos poniendo las diferentes condiciones de nuestra Query. Para poder buscar las columnas sobre las que queremos realizar la consulta necesitaremos un objeto Root , que crearemos a partir del anterior objeto CriteriaQuery\nAhora creamos una lista de objeto Predicate . En esa lista irán todos los Predicate que no son sino las condiciones de nuestra query.\nUtilizando Lambdas y Streams para hacer el código mas limpio y sencillo, vamos recorriendo el HashMap y añadiendo a la lista de Predicates las condiciones definidas.\nPartiendo del objeto CriteriaQuery se ira llamando a la función deseada según el criterio a aplicar. De esta manera, si queremos establecer como condición que un campo sea igual a un valor llamaremos a la función equal(), pasando como primer parámetro la Expresion que hace referencia al campo de la entidad, y después el valor deseado. El objeto Expresion se creara simplemente cogiendo del objeto Root anteriormente definido, el nombre de la columna sobre el que se establecerá la condición.\nSi deseamos añadir una condición donde un campo sea como a un texto introducido se llamara a la función like(). En caso de que deseemos que el campo tenga un valor superior al introducido se usara greaterThan() y así sucesivamente.\nSi el campo es de tipo Date, es necesario especificar el tipo de dato del campo como se muestra en el código root.get(field), pues de otra manera no sabrá parsear correctamente la fecha.\nResaltar que el nombre del campo es el definido en nuestra entity que lógicamente no tiene porque ser el de la columna en la base de datos. Por ejemplo, el campo de fecha en la entity del proyecto de ejemplo, esta creada con las siguientes sentencias:\n@Column(name=\u0026quot;created_date\u0026quot;) @Temporal(TemporalType.DATE) Date created;  De tal manera que en la base de datos la columna se llamara created_date pero todas las referencias a la entidad se harán a través del nombre created y es por ello que cuando busquemos el nombre del campo deberemos en Root deberemos buscar el campo created y no el campo created_dateque no lo encontraría y nos daría error.\nUna vez tenemos las condiciones de la consulta establecidas no tenemos más que preparar la consulta llamando a la función select a la que primero le indicaremos el Root con la entidad a consultar y después, las condiciones establecidas en el ArrayList de Predicate, el cual deberemos convertir previamente a un simple Array. Esto lo haremos con la sentencia: \u0026#8216;query.select(root).where(predicates.toArray(new Predicate[predicates.size()]));\nAhora ejecutaremos la select y recogeremos los resultados en un objeto List con el comando entityManager.createQuery(query).getResultList()\nListo, ya tendremos nuestra Query personalizada funcionado. 🙂 Como siempre no dudéis en hacer cualquier consulta o mandar feedbacks. ¡¡ Hasta otra!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/2019/01/24/mensajeria-con-kafka-y-spring-boot/",
	"title": "Mensajería con Kafka y Spring Boot",
	"tags": ["docker", "java", "kafka", "spring"],
	"description": "",
	"content": "Kafka es un programa de mensajería pensado para comunicaciones asíncronas. Básicamente la idea es que los clientes o consumidores se subscriben a un tipo de noticia o topic y cuando un emisor o broker manda un mensaje sobre ese topic Kafka lo distribuye a los consumidores suscritos.\nPara probar este programa deberemos tener un servidor funcionando con los topics ya definidos . En la página https://kafka.apache.org/quickstart hay un manual rápido y muy claro de como levantar uno en apenas 10 minutos.\nHay una extensa documentación sobre Kafka en internet, por lo cual no voy a profundizar demasiado en su funcionamiento, ni instalación. No obstante, aclarare dos conceptos básicos de Kafka.\n Siempre se trabaja sobre topics. Poniendo un símil con la prensa escrita, un topic seria el periódico al que nos hemos subscrito. Solo recibiremos las ediciones (mensajes en Kafka) de ese periódico. Por supuesto una misma persona (suscriptor) mismo puede estar subscrito a muchos periódicos.\n Los subscritores siempre forman grupos , aunque en el grupo no haya mas que una sola subscritor.Kafka se encargara que un mensaje solo sea enviado a un subscritor de un grupo.Hay que pensar que Kafka es una tecnología enfocada a la nube y lo normal es que un mismo programa (normalmente un microservicio) este ejecutándose en varios servidores, para poder tener tolerancia a fallos. Sin embargo cuando un emisor envía un mensaje de un topic solo queremos que ese mensaje sea procesado por una de las instancias del servicio y no por todas ellas.\n  De esta manera suponiendo que el mensaje implicaría realizar un apunte en una base de datos central, solo se realizaría un único apunte y no uno por cada una de las instancias. \nEn esta entrada voy a explicar como mandar y recibir mensajes usando Spring Boot a un servidor Kafka. Además usaremos Docker para realizar ciertas pruebas.\nEl fuente de esta entrada están en https://github.com/chuchip/KafkaTest Empezaremos creando un proyecto Spring Boot, con los siguientes starters. - Web - kafka\nEl starter Web lo vamos a necesitar para las pruebas que haremos, pero no lo necesitaremos en un caso real.\n1. Configuración La configuración es muy simple. Solo tendremos que poner en el fichero application.properties, la dirección del servidor Kafka con el parámetro spring.kafka.bootstrap-server\nmessage.topic.name=${topicname} message.topic.name2=${topicname2} message.group.name=${groupid} spring.kafka.bootstrap-servers=kafkaserver:9092 spring.kafka.consumer.group-id=myGroup  Si tuviéramos varios servidores Kakfa como suele ser el caso en producción, los indicaríamos separándolos por comas. (server1:9092,server2:9092, server3:9093 \u0026#8230;)\nCon el parámetro spring.kafka.consumer.group-id podemos definir el grupo al que por defecto pertenecerán los listeners pero esto es configurable en cada uno de ellos y no es necesario.\nLos demás parámetros los usaremos más adelante y son solo para poder realizar pruebas.\n2. Enviando mensajes Los mensajes los enviaremos desde la clase KafkaMessageProducer, la cual pongo a continuación.\n@Component public class KafkaMessageProducer { @Autowired private KafkaTemplate\u0026lt;String, String\u0026gt; kafkaTemplate; @Value(value = \u0026quot;${message.topic.name:profesorp}\u0026quot;) private String topicName;\tpublic void sendMessage(String topic,String message) { if (topic==null || topic.trim().equals(\u0026quot;\u0026quot;)) topic=topicName; ListenableFuture\u0026lt;SendResult\u0026lt;String, String\u0026gt;\u0026gt; future = kafkaTemplate.send(topic, message); future.addCallback(new ListenableFutureCallback\u0026lt;SendResult\u0026lt;String, String\u0026gt;\u0026gt;() { @Override public void onSuccess(SendResult\u0026lt;String, String\u0026gt; result) { System.out.println(\u0026quot;Sent message=[\u0026quot; + message + \u0026quot;] with offset=[\u0026quot; + result.getRecordMetadata().offset() + \u0026quot;]\u0026quot;); } @Override public void onFailure(Throwable ex) {System.err.println(\u0026quot;Unable to send message=[\u0026quot; + message + \u0026quot;] due to : \u0026quot; + ex.getMessage()); } }); }\tl }  Lo primero será pedir a Spring que nos inyecte un objeto tipo KafkaTemplate .\nEl topic por defecto, sobre el que enviaremos los mensajes lo definimos en la variable topicname que, por defecto, tendrá el valor de message.topic.name establecida en el fichero properties de Spring Boot\nEn la función sendMessage sobre el topic mandado mandaremos el mensaje deseado.\nPara ello crearemos un ListenableFuture a partir de kafkaTemplate. De esta manera la llamada al servidor de Kafka será asíncrona. Para hacerla simplemente usaremos la función addCallback de la clase ListenableFuture, pasándole el interface ListenableFutureCallback.\nLa función onSuccess será ejecutada si todo va bien y la función onFailure en caso de error.\n3. Recibiendo mensajes Los mensajes los recibiremos en la clase KafkaTestListener\n@Component public class KafkaTestListener { @KafkaListener(topics = \u0026quot;${message.topic.name:profesorp}\u0026quot;, groupId = \u0026quot;${message.group.name:profegroup}\u0026quot;) public void listenTopic1(String message) { System.out.println(\u0026quot;Recieved Message of topic1 in listener: \u0026quot; + message); } @KafkaListener(topics = \u0026quot;${message.topic.name2:profesorp-group}\u0026quot;, groupId = \u0026quot;${message.group.name:profegroup}\u0026quot;) public void listenTopic2(String message) { System.out.println(\u0026quot;Recieved Message of topic2 in listener \u0026quot;+message); } }  En la función listenTopic1 con la etiqueta @KafkaListener, definiremos el topics , en plural pues pueden ser varios, que queremos escuchar. En este caso escucharemos los definidos en la variable message.topic.name del fichero properties de Spring Boot. Si esa variable no estuviera definida, tendrá el valor profesorp. Además especificamos el grupo al que pertenece el listener. Recordar si no lo definimos cogerá el que hayamos configurado con el parametro spring.kafka.consumer.group-id\nEn la función listenTopic2 recibiremos los mensajes del topic message.topic.name2.\nProbando la aplicación En la clase KafkaTestControllerhe puesto un controlador REST muy sencillo que escucha en /add/{topic} . Acepta peticiones POST y lo único que hace es llamar a kafkaMessageProducer.sendMessage mandando un mensaje al servidor Kafka. Este es el código.\n@RestController public class KafkaTestController { @Autowired KafkaMessageProducer kafkaMessageProducer; @PostMapping(\u0026quot;/add/{topic}\u0026quot;) public void addIdCustomer( @PathVariable String topic,@RequestBody String body) { kafkaMessageProducer.sendMessage(topic,body); } }  Para hacer las pruebas he creado el fichero jar a través de maven (maven package) y he creado este pequeño script al que he llamado javaapp.sh que lo ejecuta:\njava -Dtopicname=$TOPICNAME -Dtopicname2=$TOPICNAME2 -Dgroupid=$GROUPID -jar ./kafkatest.jar ```` Como variables de entorno habremos definido TOPICNAME,TOPICNAME2 y GROUPID.  export TOPICNAME=\u0026ldquo;mytopic_1\u0026rdquo; export TOPICNAME2=\u0026ldquo;mytopic_2\u0026rdquo; EXPORT GROUPID=\u0026ldquo;profe_group\u0026rdquo;\n Recordar que tenemos que tener creados los topics en el servidor de kafka. Eso se puede hacer con el comando   bin/kafka-topics.sh \u0026ndash;create \u0026ndash;zookeeper localhost:2181 \u0026ndash;replication-factor 1 \u0026ndash;partitions 1 \u0026ndash;topic mytopic_1 bin/kafka-topics.sh \u0026ndash;create \u0026ndash;zookeeper localhost:2181 \u0026ndash;replication-factor 1 \u0026ndash;partitions 1 \u0026ndash;topic mytopic_2\n Para comprobar que están creados los \u0026lt;em\u0026gt;topics\u0026lt;/em\u0026gt; podemos ejecutar el comando  bin/kafka-topics.sh \u0026ndash;list \u0026ndash;zookeeper localhost:2181\n Una vez tengamos la aplicación corriendo en un terminal, abrimos otro, y ejecutamos la sentencia:  curl \u0026ndash;request POST localhost:8080/add/mytopic_1 -d \u0026ldquo;Mensaje para topic1 \u0026ldquo;\n La cual hace una petición POST a la URL \u0026lt;strong\u0026gt;localhost:8080/add/topic2\u0026lt;/strong\u0026gt; . En el cuerpo de esta petición ira el texto \u0026lt;em\u0026gt;\u0026amp;#8220;Mensaje para topic profegroup\u0026amp;#8221;\u0026lt;/em\u0026gt; La salida que veremos en nuestro programa será la siguiente  Sent message=[Mensaje+para+topic+mytopic_1=] with offset=[13] Recieved Message of mytopic_1 in listener: Mensaje+para+topic1=\n Con lo cual vemos, como se ha enviado y luego recibido correctamente en el **topic1**. Si ahora ejecutamos la sentencia:  curl \u0026ndash;request POST localhost:8080/add/mytopic_2 -d \u0026ldquo;Mensaje para topic2\u0026rdquo;\n Observaremos la siguiente salida:  Sent message=[Mensaje+para+topic+mytopic_2=] with offset=[32] Recieved Message of topic1 in listener: Mensaje+para+topic+topic2=\n ### Dockerizando la aplicación Para probar la aplicación en un entorno más real vamos a dockerizar nuestra aplicación. El fichero \u0026lt;code\u0026gt;DockerFile\u0026lt;/code\u0026gt; sera el siguiente:  FROM openjdk:8-jdk-alpine VOLUME /tmp ENV JAR_FILE kafkatest.jar ENV TOPICNAMER rofesorp ENV TOPICNAME2 profegroup ENV GROUPID profe_group COPY $JAR_FILE /tmp/kafkatest.jar COPY javaapp.sh /tmp/ EXPOSE 8080 ENTRYPOINT \u0026ldquo;/tmp/javaapp.sh\u0026rdquo;\n En el directorio donde este el fichero \u0026lt;strong\u0026gt;DockerFile\u0026lt;/strong\u0026gt; deberemos tener también \u0026lt;strong\u0026gt;javaapp.sh\u0026lt;/strong\u0026gt; y \u0026lt;strong\u0026gt;kafakatest.jar\u0026lt;/strong\u0026gt; Creamos la imagen con el comando:  docker build -t kafkatest .\n Antes de ejecutarlo debemos asegurarnos que nuestro servidor de Kafka este bien configurado. Una vez un consumidor llama al servidor, lo primero que hace este servidor es comunicarle al cliente la dirección donde esta el servidor \u0026lt;em\u0026gt;lider\u0026lt;/em\u0026gt; con el que debe comunicarse. Normalmente esto no es problema, pero cuando la red es un poco compleja, como en el caso de Docker o máquinas virtuales hay que asegurarse que el nombre del \u0026lt;em\u0026gt;lider\u0026lt;/em\u0026gt; que suministra Kafka, es accesible por el \u0026lt;em\u0026gt;consumidor\u0026lt;/em\u0026gt;. Como Docker crea siempre un interface virtual en la dirección \u0026lt;strong\u0026gt;172.17.0.1\u0026lt;/strong\u0026gt;, añadiremos esta IP al fichero \u0026lt;strong\u0026gt;/etc/hosts\u0026lt;/strong\u0026gt;, añadiéndole la línea  172.17.0.1 kafkaserver\n Y en el fichero \u0026lt;strong\u0026gt;config/server.properties\u0026lt;/strong\u0026gt; definiremos las siguientes variables:  listeners=PLAINTEXT://kafkaserver:9092 advertised.listeners=PLAINTEXT://kafkaserver:9092\n La primera línea especifica donde debe escuchar el servidor de Kafka y la segunda el nombre que mandara al \u0026lt;strong\u0026gt;consumidor\u0026lt;/strong\u0026gt; cuando pregunte por el \u0026lt;em\u0026gt;lider\u0026lt;/em\u0026gt; con el que debe conectarse. Reiniciamos el servidor de Kafka, y ejecutamos el contenedor docker con la siguiente sentencia:  docker run -i -t \u0026ndash;name=kafkatest1 -p 8880:8080 \u0026ndash;hostname kafkatest1 -e \u0026ldquo;TOPICNAME=my_topic1\u0026rdquo; -e \u0026ldquo;TOPICNAME2=my_topic2\u0026rdquo; -e \u0026ldquo;GROUPID=profe_group\u0026rdquo; \u0026ndash;add-host kafkaserver:172.17.0.1 kafkatest\n En otro terminal ejecutamos el mismo comando cambiando el nombre del contenedor y mapeando el puerto 8080 al 8881  docker run -i -t \u0026ndash;name=kafkatest2 -p 8881:8080 \u0026ndash;hostname kafkatest2 -e \u0026ldquo;TOPICNAME=my_topic2\u0026rdquo; -e \u0026ldquo;TOPICNAME2=my_topic2\u0026rdquo; -e \u0026ldquo;GROUPID=profe_group\u0026rdquo; \u0026ndash;add-host kafkaserver:172.17.0.1 kafkatest\n Si en un tercer terminal ejecutamos la sentencia  curl \u0026ndash;request POST localhost:8880/add/my_topic1 -d \u0026ldquo;Mensaje para topic numero 1\u0026rdquo;\n Observaremos que solo uno de los dos programas recibe el mensaje de Kafka pues ambos pertenecen al mismo grupo (\u0026lt;strong\u0026gt;profe_group\u0026lt;/strong\u0026gt;) Abriendo un nuevo terminal, volvemos a lanzar una nueva instancia de docker, especificando \u0026lt;strong\u0026gt;otro_grupo\u0026lt;/strong\u0026gt;.  docker run -i -t \u0026ndash;name=kafkatest3 -p 8881:8080 \u0026ndash;hostname kafkatest2 -e \u0026ldquo;TOPICNAME=my_topic1\u0026rdquo; -e \u0026ldquo;TOPICNAME2=my_topic2\u0026rdquo; -e \u0026ldquo;GROUPID=otro_grupo\u0026rdquo; \u0026ndash;add-host kafkaserver:172.17.0.1 kafkatest ```\n Veremos que la anterior petición curl hace que los mensajes sean recibidos en dos instancias en docker. En una de las dos, que tiene el grupo profe_group y en la que tiene el grupo otro_grupo\nPor supuesto este programa se puede mejorar mucho, pues no hemos utilizado serialización para recibir objetos directamente, ni hemos hablado de las particiones de Kafka, ni del tratamiento de errores, seguridad, etc, pero como una pequeña introducción al mundo de Kafka y la mensajería. Como siempre se agradecerá cualquier comentario aquí o en mi cuenta de Twitter @chuchip.\n¡¡Hasta la próxima clase!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/docker/",
	"title": "docker",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/kafka/",
	"title": "kafka",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/kafka/",
	"title": "kafka",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2019/01/03/microservicios-distribuidos-con-eureka/",
	"title": "Microservicios distribuidos con Eureka",
	"tags": ["java", "microservicios", "rest", "spring boot"],
	"description": "",
	"content": " En esta clase hablare de como crear microservicios distribuidos en Spring Boot utilizando las facilidades que nos da el paquete Spring Cloud NetFlix.\nCualquier microservicio debe poder localizar las diferentes instancias de otro servicio del que dependa sin tener sus direcciones definidas en el código.\nEn el caso de que un microservicio deba acceder a otro lo ideal seria que de alguna manera pudiera saber en que direcciones esta las instancias de ese otro microservicio funcionando, pues lo más común es que se levanten diferentes instancias dependiendo de la carga.\nPara ello en Spring se utiliza Eureka Server del paquete Spring Cloud NetFlix. Utilizando este paquete además de Ribbon y Feign conseguiremos que nuestra aplicación sea capaz de encontrar las diferentes instancias de un microservicio y balancear las peticiones de tal manera que se reparta la carga.\nEn este articulo voy a explicar como crear un servicio que al que llamaremos para solicitar la capital de un país. Este servicio a su vez llamara a otro servicio para localizar los datos solicitados, pues el solo será un punto de entrada.\nLos programas utilizados serán estos:\n Proyecto: capitals-service Puerto:: 8100 Proyecto: countries-service Puerto:: 8000 y 8001 proyecto: eureka-server Puerto: 8761  El proyecto \u0026#8216;countries-service\u0026#8216; será el que tenga la base de datos con los datos de los diferentes países. Se lanzaran dos instancias del mismo servicio para que podamos comprobar como \u0026#8216;capitals-service\u0026#8216; hace una llamada a una instancia y luego, balanceando la carga.\nEl código de ejemplo de este articulo esta en GitHub.\n Creando un servidor Eureka  Lo primero que necesitamos es tener un lugar donde todos los microservicios se registren cuando se inicialicen. Ese servicio es el que a su vez se consultara cuando queramos localizar las diferentes instancias. En esta ejemplo vamos a utilizar Eureka Server el cual es muy fácil de crear.\nPara ello crearemos un nuevo proyecto Spring Boot con tan solo el Starter Eureka Server.\nEn este proyecto cambiaremos el fichero application.properties para que incluya las siguientes líneas:\nspring.application.name=eureka-server\nserver.port=8761\n​eureka.client.register-with-eureka=false\neureka.client.fetch-registry=false Es decir especificamos el nombre del programa con la línea spring.application.name . El puerto en el que estará escuchando el servicio con server.port. Y lo más importante, pues los anteriores valores son opcionales, los parámetros del servidor Eureka.\n eureka.client.register-with-eureka=false para que el servidor no se intente registrar a si mismo. eureka.client.fetch-registry=false con este parámetro especificamos a los clientes que no se guarden en su cache local las direcciones de los diferentes instancias. Esto es para que consulte al servidor Eureka cada vez que necesite acceder a un servicio. En producción a menudo se pone a true para agilizar las peticiones. Comentar que esa cache se actualiza cada 30 segundos por defecto.  Ahora en nuestra clase principal, por donde entra Spring Boot deberemos poner las anotación EnableEurekaServer:\n@SpringBootApplication @EnableEurekaServer public class NetflixEurekaNamingServerApplication { ​ public static void main(String[] args) { SpringApplication.run(NetflixEurekaNamingServerApplication.class, args); } }  ¡Y ya esta listo!. Nuestro servidor Eureka esta creado. Para ver su estado podemos usar nuestro navegador preferido y navegar a: http://localhost:8761/ para ver las aplicaciones que se han registrado. Como se ve en la captura de pantalla todavía no hay ninguna.En la misma pantalla se muestra el estado del servidor.Observar que lo normal es que tengamos varios servidores Eureka levantados. En nuestro ejemplo solo levantaremos uno, aunque eso nos será lo normal en producción.\n2. Microservicio \u0026#8216;countries-service\u0026#8217; Ahora que tenemos nuestro servidor vamos a crear nuestro primer cliente. Para ello crearemos otro proyecto de Spring Boot con los siguientes starters\n Eureka Discovery Web Lombok H2 JPA  Como he comentado anteriormente, este microservicio es el que va a tener la base de datos y el que será consultado por \u0026#8216;capitales-service\u0026#8217; para buscar las capitales de un país.\nLo destacable de este proyecto esta en el fichero application.properties de Spring Boot\nspring.application.name=paises-service\neureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka\nserver.port=8000\n# Configuacion JPA\nspring.jpa.show-sql=true\nspring.h2.console.enabled=true Como se puede ver, con el paramero eureka.client.service-url.default-zone especificamos donde esta el servidor Eureka. Spring Boot automáticamente al ver que tiene el paquete Eureka Discovery disponible intentara registrarse en su correspondiente servidor.\nPara poder lanzar con Eclipse la segunda instancia de la aplicación paises-service en el puerto 8001, deberemos ir a la opción Run Configurations en el menú Runy copiar la que Eclipse habra creado de countries-service una vez hayamos ejecutado la aplicación por primera vez. En la pestaña Arguments deberemos añadir el parámetro --server.port=8001En la siguiente captura de pantalla se puede ver como si lanzamos dos instancias de este programa, una en el puerto 8000 y otra en el puerto 8001, en Eureka Server podemos ver como se han registrado las diferentes instancias. El nombre que se han registrado y por el que el se podrán buscar es el nombre de la aplicación como se ha declarado en la variable spring.application.name del fichero application.propertiesAsí vemos que la aplicación COUNTRIES-SERVICEtiene dos instancias, levantadas ambas en el host port-chuchiuna en el puerto 8000 y otra en el puerto 8001.\nMi ordenador se llama port-chuchi\nEsta sencilla aplicación usara H2 para la persistencia de datos teniendo una simple tabla llamada countriescon los datos de los países, a la que accederemos por JPA. La estructura de la tabla esta definida en com.profesorp.countriesservice.entities.Countries.java\nEn la clase CapitalsServiceControllerse definen los siguientes puntos de entrada.\n Petición GET. /{country}   Recibe: Código de Pais. (\u0026#8216;es\u0026#8217;,\u0026#8217;eu\u0026#8217;,\u0026#8217;en\u0026#8217;\u0026#8230;.) Devolverá un objeto CapitalsBean   Petición GET. /time/{time}  Establece el tiempo que la entrada /{country} realizara una pausa antes de devolver el resultado.\n3. Microservicio \u0026#8216;capitals-service\u0026#8217; Este servicio es el que llamara al anterior para solicitar todos los datos de un país, pero mostrara solo la capital, el puerto del servicio al que realizo la llamada y el nombre del país.\nNecesitaremos tener los siguientes starters\n Eureka Discovery Feign Lombok Web  En primer lugar, como en el anterior servicio, en el fichero application.propertiestendremos el siguiente contenido:\nspring.application.name=capitals-service\neureka.client.serviceUrl.defaultZone=http://localhost:8761/eureka\nserver.port=8100 Es decir, definimos el nombre de la aplicación, después especificamos donde esta el servidor Eureka donde nos debemos registrar y por fin el puerto donde escuchara el programa.\n Utilizando RestTemplate.  Para realizar una petición RESTFUL a countries-service la forma más simple seria usar la clase RestTemplatedel paquete org.springframework.web.client.\n@GetMapping(\u0026quot;/template/{country}\u0026quot;) public CapitalsBean getCountryUsingRestTemplate(@PathVariable String country) { Map\u0026lt;String, String\u0026gt; uriVariables = new HashMap\u0026lt;\u0026gt;(); uriVariables.put(\u0026quot;country\u0026quot;, country); ResponseEntity\u0026lt;CapitalsBean\u0026gt; responseEntity = new RestTemplate().getForEntity( \u0026quot;http://localhost:8000/{country}\u0026quot;, CapitalsBean.class, uriVariables ); CapitalsBean response = responseEntity.getBody(); return response; }  Como se ve, simplemente, metemos en un hashmap las variables que vamos a pasar en la petición, que en este caso es solo el parámetro pais, para después realizar crear un objeto ResponseEntity llamando a la función estáticaRestTemplate.getForEntity() pasando como parámetros, la URL que deseamos llamar, la clase donde debe dejar la respuesta de la petición REST y las variables pasadas en la petición.\nDespués, capturamos el objeto CapitalsBeanque tendremos en el Body del objeto ResponseEntity.\nPero usando este método tenemos el problema de que debemos tener definido en nuestro programa las URLs donde están las diferentes instancias del microservicio al que llamamos, además como se ve, tenemos que escribir mucho código para hacer una simple llamada.\n Petición FEIGN simple  Una manera más elegante de hacer esa llamada seria utilizando Feign. Feign es una herramienta de Spring que nos permite realizar llamadas usando funciones declarativas.\nPara utilizar Feign debemos incluir la etiqueta @EnableFeignClients en nuestra clase principal. En nuestro ejemplo la ponemos en la clase CapitalsServiceApplication\n@SpringBootApplication @EnableFeignClients(\u0026quot;com.profesorp.capitalsservice\u0026quot;) public class CapitalsServiceApplication { public static void main(String[] args) { SpringApplication.run(CapitalsServiceApplication.class, args); } }  Si no pasamos ningún parámetro a la etiqueta @EnableFeignClients buscara clientes Feign en nuestro paquete principal, si le ponemos un valor solo buscara clientes en el paquete mandado. Así en el ejemplo solo buscaría en el paquete com.profesorp.capitalsservice\nAhora definimos el cliente Feing con el interface CapitalsServiceProxy\n@FeignClient(name=\u0026quot;simpleFeign\u0026quot;,url=\u0026quot;http://localhost:8000/\u0026quot;) public interface CapitalsServiceProxySimple { @GetMapping(\u0026quot;/{country}\u0026quot;) public CapitalsBean getCountry(@PathVariable(\u0026quot;country\u0026quot;) String country); }  Lo primero es etiquetar la clase con @FeignClient especificando la URL donde esta el servidor REST que queremos llamar. Prestar atención al hecho de que ponemos la dirección base, en este caso solo el nombre del host y su puerto localhost:8000. El parámetro namedebe ser puesto pero no es importante su contenido.\nDespués definiremos las diferentes entradas que queremos tener disponibles. En nuestro caso solo hay una definida, pero podríamos incluir la llamada a /time/{time} .\n@Autowired private CapitalsServiceProxySimple simpleProxy; @GetMapping(\u0026quot;/feign/{country}\u0026quot;) public CapitalsBean getCountryUsingFeign(@PathVariable String country) { CapitalsBean response = simpleProxy.getCountry(country); return response; }  Usamos el inyector de dependencias de Spring para crear un objeto CapitalsServiceProxySimple y después simplemente llamamos a la función getCountry()del interface.\nMucho más limpio, ¿verdad?. Suponiendo que nuestro servidor REST tuviera muchos puntos de entrada nos ahorraríamos muchísimo de teclear, además de tener un código mucho más limpio.\nPero aún tenemos el problema de que la dirección del servidor RESTFUL esta escrita en nuestro código lo cual nos hace imposible poder llegar a las diferentes instancias del mismo servicio y nuestro microservicio no será verdaderamente escalable.\n Petición FEIGN usando el servidor Eureka  Para resolver el problema en vez de poner la dirección del servidor, pondremos el nombre de la aplicación y Spring Boot se encargara de llamar el servidor Eureka, pidiéndole la dirección donde esta ese servicio .\nPara ello crearíamos un interface Feign de esta manera\n@FeignClient(name=\u0026quot;countries-service\u0026quot;) public interface CapitalsServiceProxy { @GetMapping(\u0026quot;/{country}\u0026quot;) public CapitalsBean getCountry(@PathVariable(\u0026quot;country\u0026quot;) String country); }  Como se puede ver aquí no especificamos la dirección del servicio, simplemente ponemos el nombre. En este caso countries-service que es como esta registrada la aplicación en el servidor Eureka.\nAhora cada petición que se haga ira balanceándose de una instancia a otra. De tal manera que la primera petición ira a la del puerto 8000 y la siguiente a la del puerto 8001.De esta manera nuestra aplicación ya utilizara todas las instancias del servicio automáticamente.\n Configurando RIBBON  El paquete Feign usa el paquete Ribbon por debajo y realmente es este es el que se encarga de balancear las peticiones. Por defecto Ribbon usara la regla RoundRobinRule. Con esta regla escogerá secuencialmente cada uno de las instancias que Eureka le muestre levantadas, sin tener en cuenta el tiempo que a cada instancia le cuesta responder.\nSi deseamos que use alguna de las otras tres disponibles por defecto o incluso una regla que nosotros definamos deberemos crear una clase de configuración para Ribbon, como la siguiente:\nimport org.springframework.context.annotation.Bean;\nimport com.netflix.loadbalancer.IPing;\nimport com.netflix.loadbalancer.IRule;\nimport com.netflix.loadbalancer.NoOpPing;\nimport com.netflix.loadbalancer.WeightedResponseTimeRule;\npublic class RibbonConfiguration {\n@Bean\npublic IPing ribbonPing() {\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;return new NoOpPing();\n} @Bean public IRule ribbonRule() {\n\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp;return new WeightedResponseTimeRule();\n}\n} En la función ribbonRule()devolveremos el objeto WeightedResponseTimeRule si queremos que la lógica de balanceo tenga en cuenta el tiempo de respuesta de cada instancia.\nAhora, para especificar que queremos usar esta clase para configurar Ribbon añadiremos la etiqueta\n@RibbonClient(name=\u0026quot;countries-service\u0026quot;, configuration = RibbonConfiguration.class)en nuestra clase CapitalsServiceApplication\nimport org.springframework.context.annotation.Bean; import com.netflix.loadbalancer.IPing; import com.netflix.loadbalancer.IRule; import com.netflix.loadbalancer.NoOpPing; import com.netflix.loadbalancer.WeightedResponseTimeRule; public class RibbonConfiguration { @Bean public IPing ribbonPing() { return new NoOpPing(); } @Bean public IRule ribbonRule() { return new WeightedResponseTimeRule(); } }  Para comprobar como funciona el balanceo por peso, estableceremos una pausa de 10 milisegundos al servidor del puerto 8001 y una de 300 al servidor del puerto 8000, usando la llamada a /time/{time} del servicio countries-service\n\u0026gt; curl localhost:8001/time/10\n\u0026gt; curl localhost:8000/time/300 Suponiendo que estamos trabajando en Linux, usando Bash haremos 100 peticiones.\nCONTADOR=0; while [ $CONTADOR -lt 100 ]; do curl http://localhost:8100/es\nlet CONTADOR=CONTADOR+1\ndone Al cabo de un tiempo podremos ver las peticiones que se han realizado a cada puerto llamando a http://localhost:8100/puertosComo se puede ver hay muchas más peticiones al puerto 8001 que al puerto 8000, lo cual es normal teniendo en cuenta que el puerto 8000 tiene un retraso de 300 milisegundos, mientras que el 8001 solo de 10.\nPara terminar este articulo comentar que Ribbon se puede usar sin tener Feign, utilizando directamente RestTemplate pero el estudio de ese caso lo dejare para otra ocasión.\nMencionar, además que para realizar pruebas de balanceo he utilizado Docker por lo cual en el código fuente de GitHub, veremos que en el fichero application.propertiesdel proyecto countries-service están estas líneas:\neureka.client.serviceUrl.defaultZone:http://eurekaserver:8761/eureka\nserver.port=${SERVER_PORT} En vez de las mostradas anteriormente. Esto esta puesto así para poder definir dinámicamente cuando se lanza el contenedor docker , con la variable de entorno SERVER_PORT el puerto donde debe escuchar cada instancia.\nGracias por leer este articulo y hasta la próxima lección 😉\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/microservicios/",
	"title": "microservicios",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/12/10/servidor-configuraciones-usando-spring-cloud/",
	"title": "Servidor configuraciones usando Spring Cloud",
	"tags": ["cloud", "java", "spring boot"],
	"description": "",
	"content": " En esta ocasión vamos a usar el paquete Spring Cloud Config para poder tener configuraciones remotas para nuestras aplicaciones.\nLa idea es que nuestro programa o programas puedan ir a buscar sus parámetros de configuración a un lugar externo, de tal manera que nuestra aplicación sea fácilmente parametrizable e incluso se puedan cambiar sus configuraciones en caliente.\nEsto se utiliza ampliamente en microservicios pues una mismo servicio o aplicación puede estar lanzada muchas veces en diferentes contenedores y es interesante tener un lugar central desde donde se puedan aplicar las configuraciones a estos servicios.\nPara ello vamos a crear un servidor de configuraciones y un cliente que buscara su configuración en ese servidor.\nEl servidor de configuraciones, usara un repositorio GIT de GitHub donde estarán los ficheros de configuración.\nLos datos de las aplicaciones serán los siguientes.\n*** Servidor de configuraciones**  Proyecto: config-server Puerto: 8888 Nombre Spring : config-server Servidor GIT: https://github.com/chuchip/servercloudconfig.git  * Cliente de configuraciones  Proyecto: config-client Puerto: 8080 Nombre Spring: config-client  Los fuentes de los programas están en: https://github.com/chuchip/servercloudconfig\n Servidor de configuraciones  La única dependencia para poder crear un servidor de configuraciones es incluir este paquete en nuestro proyecto maven\n\u0026lt;dependency \u0026lt;groupIdorg.springframework.cloud\u0026lt;/groupId \u0026lt;artifactIdspring-cloud-config-server\u0026lt;/artifactId \u0026lt;/dependency  El starter de Spring seria Config Server\nEl servidor de configuraciones se compone de una sola clase, que detallo a continuación:\npackage com.profesorp.configserver; import org.springframework.boot.SpringApplication; import org.springframework.boot.autoconfigure.SpringBootApplication; import org.springframework.cloud.config.server.EnableConfigServer; @EnableConfigServer @SpringBootApplication public class ConfigServerApplication { public static void main(String[] args) { SpringApplication.run(ConfigServerApplication.class, args); } }  Como se ve, lo único destacable es la anotación @EnableConfigServer .\nEn el fichero application.properties pondremos donde debe buscar las configuraciones, con el parámetro: spring.cloud.config.server.git.uri\nspring.application.name=config-server server.port=8888 spring.cloud.config.server.git.uri=https://github.com/chuchip/servercloudconfig.git  En este caso le decimos que use un servidor Git que tenemos alojado en GitHub. También podríamos especificar que el use un repositorio GIT local de este modo:\nspring.cloud.config.server.git.uri=file://eclipe/spring-config/  Los servidores de configuración de Spring Cloud soportan los siguientes orígenes (backends):\n GIT Vault JDBC ,  Estos orígenes incluso se pueden mezclar, de tal manera que dependiendo del perfil elegido se use uno u otro. Pero esto se escapa al ámbito de este documento.\nEn el caso del servidor GIT, que es el utilizado en el ejemplo, lo importante es tener un fichero que se llame como el cliente que va a solicitar los datos, terminado en .properties. Así si queremos guardar configuración para una aplicación cliente que se llame config-client , es decir que en la variable spring.application.namesea igual a config-client, deberemos tener un fichero llamado config-client.propertiesEn este fichero pondremos los valores, de esta manera:\ndatosservidor.minimum=11 datosservidor.maximum=20 limites.minimum=-1 limites.maximum=2 valores.valor_fijo: VALORFIJO valores.valor_funcion: \"VALORDEFUNCION\";  Obsérvese que el valor puede ser asignado con : (dos puntos) o = (igual)\nNO usar comillas para delimitar los literales, a no ser que se quiera que nuestro literal (String) incluya esas comillas.\nPara ver los valores pasados a nuestros cliente, realizaremos una petición GET especificando el nombre del cliente y el perfil. \nEn este caso solicitamos la configuración para el cliente config-clienty el perfil defaultque es el perfil utilizado si no especifica ninguno.\nPara ver la configuración para el perfil production se llamaría a la URL:http://localhost:8888/config-client/production. Lo cual muestra la siguiente salida:\nComo se puede observar, muestra el contenido del fichero config-client-production.propertiesy después el contenido del ficheroconfig-client.properties.\nDe esta manera, si un cliente solicita un valor y ese valor existe en el perfil solicitado, se devolverá ese valor. En caso contrario se buscaría en el perfil default , devolviendo el valor asignado si lo tuviera.\n Cliente de configuraciones  Una vez tenemos nuestro servidor de configuraciones y levantado, pasaremos a crear el cliente.\nLa única dependencia en nuestro fichero maven será la siguiente:\n\u0026lt;dependency \u0026lt;groupIdorg.springframework.cloud\u0026lt;/groupId \u0026lt;artifactIdspring-cloud-starter-config\u0026lt;/artifactId \u0026lt;/dependency  Usando Spring Initializr seria añadir la dependencia Config Client . Además, para poder refrescar la configuración en caliente, añadiremos el starter Actuator\nAhora deberemos configurar la aplicación para especificar donde esta el servidor de configuraciones, para ello, lo primero será cambiar el fichero config.properties por bootstrap.properties. De esta manera Spring Boot sabrá que debe buscar un servidor de configuraciones\nEn este fichero añadiremos la propiedad spring.cloud.config.uriespecificando la URL de nuestro servidor de configuraciones.\nspring.application.name=config-client spring.cloud.config.uri=http://localhost:8888 #spring.profiles.active=production management.endpoints.web.exposure.include=refresh  También estableceremos la propiedad management.endpoints.web.exposure.include a refreshpara configurar el paquete actuator de tal modo que se pueda acceder a la URL http://localhost:8080/actuator/refreshque será la que obligara a refrescar las diferentes propiedades.\nRecordar que la variable spring.application.nameestablecera el nombre de la aplicación e indicara el fichero del repositorio git donde se buscaran los valores de configuración.\nCon la variable spring.profiles.activeindicariamos que perfil es el que debemos usar. Si no ponemos ninguno (como es el caso pues esta comentada la línea), se utilizara el perfil default\nEn este ejemplo uso varios métodos para leer la configuración.\n Crear un componente que incluye la etiqueta @ConfigurationProperties  En este método, que es el mas sencillo, indicamos cual es la raíz de las propiedades a leer y luego definimos las variables que Spring debe rellenar.\nEn la clase configuration.java especificamos que queremos coger las variables que empiecen por limites.\nimport org.springframework.boot.context.properties.ConfigurationProperties; import org.springframework.stereotype.Component; import lombok.Data; @Data @Component @ConfigurationProperties(\"limites\") public class Configuration { private int minimum; private int maximum; }  De este modo la variable dato1 tendrá el valor especificado en limites.dato1\nSi limites.dato1tuviera un valor que no se puede pasar a un entero nuestra aplicación fallaría, sin embargo si no encuentra el valor simplemente no lo rellena, sin dar ningún tipo de error.\nEste componente será inyectado a través de una etiqueta @Autowired\n@Autowired private Configuration configuration;  2. Crear una variable con la anotación @Value\nDe esta manera también se leerá el valor del servidor de configuraciones. La mayor diferencia es que ese valor será fijo pues será asignado al ejecutar la aplicación y no se refrescara nunca.\n@Value(\"${valores.valor_fijo}\") String valorFijo;  La variable valorFijotendra el valor asignado en la línea: valores.valor_fijo\n3. Usar la anotación @Value en el parámetro de una función\n Igualmente el valor se leerá desde el servidor de configuraciones con la ventaja de que el valor podrá ser refrescado.  @GetMapping(\"/refrescado\") public BeanConfiguration getConfiguracionRefrescada(@Value(\"${valores.valor_funcion}\") String valorFuncion) { .... }  \u0026nbsp;Funcionamiento  En nuestro ejemplo se exponen las URL /limites, refrescadoy datos.\nLa llamada a limitesnos devolverá esta salida:\n  Suponiendo que realizáramos un commit de tal manera que los valores en nuestro servidor GIT hayan cambiado, sucesivas llamadas a esta URL nos mostrarían los antiguos datos, pues el cliente solo lee la configuración al principio, a no ser que se le obligue a refrescar sus datos.\nImaginemos que cambiamos el fichero `config-client.properties\u0026#8217; de tal manera que ahora tiene estos valores\ndatosservidor.minimum=10 datosservidor.maximum=20 limites.minimum=-101 limites.maximum=201 valores.valor_fijo: OTROVALORFIJO valores.valor_funcion: \"OTROVALORDEFUNCION\"  Hacemos el correspondiente commit y push\n git commit -a -m \"cambiada configuracion\";git push  Cuando llamemos a la URL http://localhost:8080/actuator/refresh con un método POST obligaremos a Spring a llamar al servidor de configuraciones y refrescar los valores.\nComo se ve, la salida de esta petición nos devuelve las variables refrescadas.\nAhora, si llamamos a http://localhost:8080/limites veríamos que el valor de minResultados y maxResultados han cambiado. Sin embargo ni valorFijo ni valorFuncion no lo han hecho.\nSi llamamos a la URL http://localhost:8080/refrescado veremos que la variable valorFuncion se ha actualizado pues en la llamada esta puesta la etiqueta @Value de tal manera que la variable es leída en ese momento. Sin embargo la variable valorFijo no es cambiada pues se estableció al inicio del programa y su valor permanece inalterado.\nEs importante destacar que si quitamos una variable en nuestro fichero de configuración, el valor de la variable no se pondrá a null sino que mantendrá el valor anteriormente establecido. Esto es valido tanto si la variable es leída con @Value como si utilizamos un @ConfigurationProperties en un @Bean\nY eso es todo por ahora, en próximas lecciones explicare como hacer que las configuraciones se refresquen automagicamenteutilizando el componente Spring Bus Cloud\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/html/",
	"title": "html",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/html/",
	"title": "html",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/web/",
	"title": "web",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/hugo/",
	"title": "hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/hugo/",
	"title": "hugo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/11/20/personalizar-codigo-http-en-spring-boot/",
	"title": "Personalizar salidas de códigos HTTP en Spring Boot",
	"tags": ["java", "rest", "spring boot"],
	"description": "",
	"content": "En esta articulo os voy a explicar como devolver errores HTTP personalizados. Para ello crearemos un proyecto llamado httpErrorPersonalizado. Teneis el código fuente de este proyecto en mi página de GitHub\nCuando realizamos una petición HTTP a un recurso en Spring Boot, es común que esa petición tenga que considerar la opción de devolver un error.\nEs el caso típico de que realizamos una petición RESTful para solicitar un registro, pero ese registro no existe. En este caso lo normal es devolver un código HTTP tipo 404 (Not Found) lo cual se hace lanzando una excepción que hayamos anotado con la etiqueta @ResponseStatus(HttpStatus.NOT_FOUND) lo que ocurre es que el objeto JSON que acompaña a esa respuesta 404 en Spring Boot será con un formato definido de este tipo:\n{ \u0026quot;timestamp\u0026quot;: \u0026quot;2018-11-20T11:46:10.255+0000\u0026quot;, \u0026quot;status\u0026quot;: 404, \u0026quot;error\u0026quot;: \u0026quot;Not Found\u0026quot;, \u0026quot;message\u0026quot;: \u0026quot;bean: 8 not Found\u0026quot;, \u0026quot;path\u0026quot;: \u0026quot;/get/8\u0026quot; }  Si nosotros queremos que la salida sea algo así como esto:\n{ \u0026quot;timestamp\u0026quot;: \u0026quot;2018-11-20T12:51:42.699+0000\u0026quot;, \u0026quot;mensaje\u0026quot;: \u0026quot;bean: 8 not Found\u0026quot;, \u0026quot;detalles\u0026quot;: \u0026quot;uri=/get/8\u0026quot;, \u0026quot;httpCodeMessage\u0026quot;: \u0026quot;Not Found\u0026quot; }  tendremos que poner una serie de clases a nuestro proyecto. Aquí os explico como 😉\nEl código fuente lo tenéis en mi repositorio de GitHub\nPartiendo de una proyecto basico de Spring Boot, donde tenemos una simple objeto llamado MiBean con solo dos campos: codigo y valor que es el que devolveremos en las peticiones rest al recurso \u0026#8220;/get\u0026#8220;, de tal manera que una petición a: http://localhost:8080/get/1 nos devolvera un objeto JSON como este:\n{ \u0026quot;codigo\u0026quot;: 1, \u0026quot;valor\u0026quot;: \u0026quot;valor uno\u0026quot; }  Si intentamos acceder a un elemento superior al 3 nos devolverá un error pues solo 3 registros disponibles.\nAquí pong la clase ErrorResource que procesa las peticiones al recurso \u0026#8220;/get\u0026#8220;\npublic class ErrorResource { @Autowired MiBeanService service; @GetMapping(\u0026quot;/get/{id}\u0026quot;) public MiBean getBean(@PathVariable int id) { MiBean bean = null; try { bean = service.getBean(id); } catch (NoSuchElementException k) { throw new BeanNotFoundException(\u0026quot;bean: \u0026quot;+id+ \u0026quot; not Found\u0026quot; ); } return bean; } }  Como se ve en getBean() se llama a la función getBean(int id) de la clase MiBeanService, la cual pego a continuación\n@Component public class MiBeanService { private static List\u0026lt;MiBean\u0026gt; miBeans = new ArrayList\u0026lt;\u0026gt;(); static { miBeans.add(new MiBean(1, \u0026quot;valor uno\u0026quot;)); miBeans.add(new MiBean(2, \u0026quot;valor dos\u0026quot;)); miBeans.add(new MiBean(3, \u0026quot;valor tres\u0026quot;)); } public MiBean getBean(int id) { MiBean miBean = miBeans.stream() .filter(t -\u0026gt; t.getCodigo()==id) .findFirst() .get(); return miBean; } }  Observe que la función getBean(int id) lanzara una excepción tipo NoSuchElementException si no encuentra el código en la List miBeans . Esta excepción será capturada en el controlador el cual lanzara una excepción tipo BeanNotFoundException\nLa clase BeanNotFoundException es la siguiente:\n@ResponseStatus(HttpStatus.NOT_FOUND) public class BeanNotFoundException extends RuntimeException { public BeanNotFoundException(String message) { super(message); } }  Una simple clase que extiende RuntimeException y que esta anotada con al etiqueta @ResponseStatus(HttpStatus.NOT_FOUND)con lo cual al ser lanzada devolvera un código HTTP 404 (Not Found).\nSi dejáramos así el proyecto al pedir un código superior a 3, seria esta:\npero como hemos dicho queremos que el mensaje de error sea personalizado.\nPara ello vamos a crear una nueva clase donde definiremos los campos de nuestro mensaje de error. Esta clase el proyecto es ExceptionResponse la cual es un simple pojo como se puede ver en el código que adjunto:\npublic class ExceptionResponse { private Date timestamp; private String mensaje; private String detalles; private String httpCodeMessage; public ExceptionResponse(Date timestamp, String message, String details,String httpCodeMessage) { super(); this.timestamp = timestamp; this.mensaje = message; this.detalles = details; this.httpCodeMessage=httpCodeMessage; } public String getHttpCodeMessage() { return httpCodeMessage; } public Date getTimestamp() { return timestamp; } public String getMensaje() { return mensaje; } public String getDetalles() { return detalles; } }  Ahora se definirá la clase que indicara a Spring que objeto JSON debe devolver en caso de que se produzca lance una excepción del tipo BeanNotFoundException . Esa clase es: CustomizedResponseEntityExceptionHandler la cual adjunto a continuación:\n//@ControllerAdvice // @RestController @RestControllerAdvice public class CustomizedResponseEntityExceptionHandler extends ResponseEntityExceptionHandler { @ExceptionHandler(BeanNotFoundException.class) public final ResponseEntity\u0026lt;ExceptionResponse\u0026gt; handleNotFoundException(BeanNotFoundException ex, WebRequest request) { ExceptionResponse exceptionResponse = new ExceptionResponse(new Date(), ex.getMessage(), request.getDescription(false),HttpStatus.NOT_ACCEPTABLE.getReasonPhrase()); return new ResponseEntity\u0026lt;ExceptionResponse\u0026gt;(exceptionResponse, HttpStatus.NOT_ACCEPTABLE); } }  Esta clase debe heredar de ResponseEntityExceptionHandler la cual ya tratara las excepciones más comunes.\nLa deberemos anotarla con las etiquetas @ControllerAdvice y @RestControllero como me sugirió Marcelo Martins en DZone sustistuir esas dos por la etiqueta: @RestControllerAdvice\n@ControllerAdvice es una etiqueta derivada de @Component que se usara para clases que traten excepciones. Al tener la clase la etiqueta @RestContoller tratara las excepciones lanzadas en los controladores de peticiones REST.\nY crearemos la función donde especificar el objeto a utilizar cuando se produzca un tipo de excepción.\nAsí, en el ejemplo, hemos definido que cuando se se lance la excepción BeanNotFoundException será devuelto un objeto ExceptionResponse. Esto se hace creando un objeto ResponseEntityconvenientemente iniciado.\nEs importante observar que también definimos el código HTTP devuelto. En este caso devolveremos el código 406, en vez del 404. De hecho en nuestro ejemplo podríamos quitar la etiqueta @ResponseStatus(HttpStatus.NOT_FOUND)a la clase BeanNotFoundException y todo seguiría funcionando igual.\nY así tendremos una salida personalizada como se ve en la siguiente imagen:\nY esto es todo por hoy. ¡¡ Nos vemos en la próxima clase !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/bootstrap/",
	"title": "bootstrap",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/bootstrap/",
	"title": "bootstrap",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/mvc/",
	"title": "mvc",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/mvc/",
	"title": "mvc",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/seguridad/",
	"title": "seguridad",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/tomcat/",
	"title": "tomcat",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/tomcat/",
	"title": "tomcat",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/webflow/",
	"title": "webflow",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/webflow/",
	"title": "webflow",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jdbc/",
	"title": "jdbc",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/jdbc/",
	"title": "jdbc",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jquery/",
	"title": "jquery",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/jquery/",
	"title": "jquery",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jsp/",
	"title": "jsp",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jstl/",
	"title": "jstl",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/jstl/",
	"title": "jstl",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/l/",
	"title": "l",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/security/",
	"title": "security",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/security/",
	"title": "security",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/18/securizando-servicios-rest-con-oauth2-en-springboot/",
	"title": "Securizando servicios REST con Oauth2 en SpringBoot",
	"tags": ["java", "oauth2", "rest", "seguridad", "spring boot"],
	"description": "",
	"content": " En esta entrada explicare como podemos dotar de seguridad a servicios REST en Spring Boot. La aplicación de ejemplo es la misma que la entrada de seguridad WEB anterior, así que el código fuente lo tenéis en: https://github.com/chuchip/OAuthServer.\nExplicando la tecnologia Oauth2 Como he dicho, utilizaremos el protocolo OAuth2, así que lo primero sera explicar como funciona este protocolo.\nOAuth2 tiene algunas variantes pero yo os voy a explicar la que utilizare en el programa y, para ello, voy a poneros un ejemplo para que entendáis lo que pretendemos hacer.\nVoy a poner una escena cotidiana: El pago con una tarjeta de crédito en un comercio.En este caso hay tres interlocutores: La tienda, el banco y nosotros. En el protocolo Oauth2 pasa algo parecido. Estos son los pasos:\n El cliente , o sea, el comprador, solicita al banco una tarjeta de crédito, para que el banco nos la de, comprobara quienes somos, y nos otorga un crédito dependiendo de la pasta que tengamos en la cuenta o bien nos dice que no le hagamos perder el tiempo ;-). En el protocolo OAuth2 al que otorga las tarjetas se le llama Servidor de Autentificación. Si el banco nos ha dado la tarjeta, podremos ir a la tienda, es decir al servidor web, y le presentamos la tarjeta de crédito. La tienda no nos conoce de nada, pero puede preguntar al banco, a través del lector de tarjetas si puede confiar en nosotros y hasta que punto (el saldo de crédito). La tienda seria el Servidor de Recursos. La tienda dependiendo del dinero que le diga el banco que tenemos nos permitirá comprar unos productos u otros. En la analogía OAuth2, el servidor web nos permitirá acceder a unas paginas u a otras dependiendo de si somos muy ricos, ricos, medios o pobres.  Como comentario, decir, por si no os habéis dado cuenta, que se utilizan servidores de autentificación habitualmente. Cuando vais a una pagina web y os pide registraros, pero como opción os deja hacerlo a través de Facebook o Google, estáis utilizando esta tecnología. Google o Facebook se convierte en el \u0026#8216;banco\u0026#8217; que emite esa \u0026#8216;tarjeta\u0026#8217;, la pagina web que os pide registraros, la usara para comprobar que tenéis \u0026#8216;credito\u0026#8217; y dejaros entrar. Espero que se entienda el ejemplo ;-).\nAquí podéis ver la pagina web de el periódico \u0026#8220;El Pais\u0026#8217;, creando una cuenta. Si utilizamos Google o Facebook, el periódico (la tienda) confiara en lo que les digan esos proveedores de autentificaciones. En este caso lo único que necesita la pagina web es que tengáis una tarjeta de crédito, sin importar el saldo 😉\nCreando un Servidor de Autorizaciones (AuthServer) ¿ Entendido ?. OK, pues vamos a ver como crear un banco, la tienda y toda la parafernalia 😉\nLo primero, en nuestro proyecto, necesitamos tener las dependencias adecuadas, necesitaremos los inicializadores (starters en ingles) : Cloud OAuth2, Security y Web\nBien, empecemos por definir el banco, esto lo hacemos en la clase: AuthorizacionServerConfiguration\n@Configuration @EnableAuthorizationServer public class AuthorizacionServerConfiguration extends AuthorizationServerConfigurerAdapter { @Autowired @Qualifier(\u0026quot;authenticationManagerBean\u0026quot;) private AuthenticationManager authenticationManager; @Autowired private TokenStore tokenStore; @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception { clients.inMemory() .withClient(\u0026quot;cliente\u0026quot;) .authorizedGrantTypes(\u0026quot;password\u0026quot;, \u0026quot;authorization_code\u0026quot;, \u0026quot;refresh_token\u0026quot;, \u0026quot;implicit\u0026quot;) .authorities(\u0026quot;ROLE_CLIENT\u0026quot;, \u0026quot;ROLE_TRUSTED_CLIENT\u0026quot;,\u0026quot;USER\u0026quot;) .scopes(\u0026quot;read\u0026quot;,\u0026quot;write\u0026quot;) .autoApprove(true)\t.secret(passwordEncoder().encode(\u0026quot;password\u0026quot;)); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints .authenticationManager(authenticationManager)\t.tokenStore(tokenStore); } @Bean public TokenStore tokenStore() { return new InMemoryTokenStore(); }\t}  Empezamos la clase anotandola como de configuración con la etiqueta @Configuration y después usamos la etiqueta @EnableAuthorizationServer para decirle a Spring que active el servidor de autorizaciones. Para definir las propiedades del servidor especificamos que nuestra clase extiende de AuthorizationServerConfigurerAdapter , la cual implementa el interface AuthorizationServerConfigurerAdapter, por lo cual, Spring usara esta clase para parametrizar el servidor.\nDefinimos un bean tipo AuthenticationManager  que Spring provee automagicamente y que nosotros recogeremos con la etiqueta @Autowired. También definimos un objeto TokenStore, pero para poder injectarlo debemos definirlo, lo cual hacemos en la función public TokenStore tokenStore().\nEl AuthenticationManager  o Controladores de Autentificaciones, como he dicho lo provee Spring pero tenderemos que configurarlo nosotros. Más tarde explicare como se hace. El TokenStore o Almacén de Identificadores es donde se guardaran los identificadores que nuestro servidor de autentificaciones vaya suministrando, para que cuando el servidor de recursos (la tienda) le pregunte el crédito sobre una tarjeta de crédito este pueda responderle. En este caso usamos la clase InMemoryTokenStore que guardara los identificadores en memoria. En una aplicación real podríamos usar un JdbcTokenStore para guardarlos en una base de datos, para que si se cae la aplicación los clientes no tengan que renovar sus tarjetas de credito 😉\nEn la función configure(ClientDetailsServiceConfigurer clients) especificamos las credenciales del banco, digo del administrador de autentificaciones. ademas de los servicios que ofrece. Sí, hablando en plural, porque para poder acceder al banco debemos tener un usuario y contraseña para cada uno de los servicios que ofrece. Esto es un concepto muy importante: El usuario y contraseña es del banco no del cliente, para cada servicio que ofrezca el banco habrá una única autentificación, si bien podrá ser la misma para diferentes servicios.\nDetallare las lineas:\n clients.inMemory() Especifica que vamos a guardar los servicios en memoria. En una aplicación \u0026#8216;real\u0026#8217; lo guardaríamos en una base de datos, un servidor LDAP, etc. withClient(\u0026#8220;cliente\u0026#8221;) Es el usuario con el que nos identificaremos en el banco. En este caso se llamara \u0026#8216;cliente\u0026#8217;. ¿ Igual habria sido mejor llamarle \u0026#8216;user\u0026#8217; 😉 ? authorizedGrantTypes(\u0026#8220;password\u0026#8221;, \u0026#8220;authorization_code\u0026#8221;, \u0026#8220;refresh_token\u0026#8221;, \u0026#8220;implicit\u0026#8221;). Especificamos los servicios que estamos configurando para el usuario definido , para \u0026#8216;cliente\u0026#8216;. En nuestro ejemplo solo usaremos el servicio password. authorities(\u0026#8220;ROLE_CLIENT\u0026#8221;, \u0026#8220;ROLE_TRUSTED_CLIENT\u0026#8221;,\u0026#8221;USER\u0026#8221;). Especifica roles o grupos que tiene el servicio ofrecido. Tampoco lo usaremos en nuestro ejemplo asi que dejemoslo correr de momento. scopes(\u0026#8220;read\u0026#8221;,\u0026#8221;write\u0026#8221;). El ambito del servicio. Tampoco lo usaremos en nuestra aplicación. autoApprove(true). Si debe aprobar automaticamente las peticiones del cliente. Pondremos que si para hacer más sencilla la aplicación. secret(passwordEncoder().encode(\u0026#8220;password\u0026#8221;)). Contraseña del cliente. Observar que se llama la función encode que tenemos definida un poco más abajo, para especificar con que tipo de encriptación se guardara la contraseña. La función encode, esta anotada con la etiqueta @Bean porque spring, cuando le suministremos la contraseña en una petición HTTP, buscara un objeto PasswordEncoder para comprobar la validez de la contraseña entregada.  Y por último tenemos la función configure(AuthorizationServerEndpointsConfigurer endpoints) donde definimos que controlador de autentificaciones y que almacén de identificadores deben usar los puntos de salida. Aclarar que los puntos de salida son las URLs por donde \u0026#8216;hablaremos con nuestro banco\u0026#8217;, para solicitar las tarjetas de cerdito 😉\nDe acuerdo, ya tenemos nuestro servidor de autentificaciones creado pero aun nos falta la manera de que este sepa quienes somos y nos ponga en diferentes grupos, según las credenciales introducidas. Bien, para hacer esto usaremos la misma clase que en utilizamos para proteger una pagina web. Si habéis leído el articulo anterior: http://www.profesor-p.com/2018/10/17/seguridad-web-en-spring-boot/ recordareis que creábamos una clase que heredaba de WebSecurityConfigurerAdapter , donde sobrescribiamos la función UserDetailsService userDetailsService().\npublic class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { .... @Bean @Override public UserDetailsService userDetailsService() { UserDetails user=User.builder().username(\u0026quot;user\u0026quot;).password(passwordEncoder().encode(\u0026quot;secret\u0026quot;)). roles(\u0026quot;USER\u0026quot;).build(); UserDetails userAdmin=User.builder().username(\u0026quot;admin\u0026quot;).password(passwordEncoder().encode(\u0026quot;secret\u0026quot;)). roles(\u0026quot;ADMIN\u0026quot;).build(); return new InMemoryUserDetailsManager(user,userAdmin); } .... }  Pues los usuarios con sus roles o grupos se definen de la misma manera. Deberemos tener una clase que extienda WebSecurityConfigurerAdapter  y definir nuestros usuarios.\nAhora y podemos comprobar si nuestro servidor de autorizaciones funciona. Vamos a ver como, utilizando el excelente programa PostMan.\nPara hablar con el \u0026#8216;banco\u0026#8217; para solicitar nuestras credenciales, y como no hemos definido lo contrario, deberemos ir a la URI \u0026#8220;/oauth/token\u0026#8221;. Este es uno de los puntos finales de los que hablaba anteriormente. Hay más pero en nuestro ejemplo y como solo vamos a usar el servicio \u0026#8216;password\u0026#8217; no usaremos más.\nUsaremos una petición HTTP tipo POST, indicando que queremos usar validación básica, pondremos el usuario y contraseña, que serán los del \u0026#8220;banco\u0026#8221;, en nuestro ejemplo: \u0026#8216;cliente\u0026#8217; y \u0026#8216;password\u0026#8217; respectivamente.\nEn el cuerpo de la petición, en formato form-url-encoded introduciremos el servicio a solicitar, nuestro usuario y nuestra contraseña.\ny lanzamos la petición, la cual nos deberá sacar una salida como esta:\nEse \u0026#8216;access_token\u0026#8217; \u0026#8220;8279b6f2-013d-464a-b7da-33fe37ca9afb\u0026#8221; es nuestra tarjeta de crédito y es la que deberemos presentar a nuestro servidor de recursos (la tienda) para poder ver paginas (recursos) que no sean públicos.\nCreando un Servidor de Recursos (ResourceServer) Ahora que ya tenemos nuestra tarjeta de crédito vamos a crear la tienda que acepte esa tarjeta 😉\nEn nuestro ejemplo vamos a crear el servidor de recursos y de autentificación en el mismo programa, con lo cual Spring Boot, se encargara de hacer que confié una parte en otra, sin tener que configurar nada. Si, como es habitual en la vida real, el servidor de recursos esta en un sitio y el servidor de autentificaciones en otro, deberíamos indicarle al servidor de recursos, cual es nuestro \u0026#8216;banco\u0026#8217; y como debe hablar con el. Pero eso lo dejaremos para otra entrada.\nLa única clase del servidor de recursos es ResourceServerConfiguration\n@EnableResourceServer @RestController public class ResourceServerConfiguration extends ResourceServerConfigurerAdapter { ..... }  Observar la anotación @EnableResourceServer que hara que Spring active el servidor de recursos. La etiqueta @RestController es porque en esta misma clase nosotros tendremos los recursos, pero podrían estar perfectamente en otra clase.\nPor ultimo fijaros que la clase extiende de ResourceServerConfigurerAdapter esto es así porque vamos a sobrescribir metodos de esa clase para configurar nuestro servidor de recursos.\nComo he dicho antes al estar el servidor de autentificación y de recursos en el mismo programa no tenemos mas que configurar la seguridad de nuestro servidor de recursos. Esto se hace en la función:\n@Override public void configure(HttpSecurity http) throws Exception { http .authorizeRequests().antMatchers(\u0026quot;/oauth/token\u0026quot;, \u0026quot;/oauth/authorize**\u0026quot;, \u0026quot;/publica\u0026quot;).permitAll(); //\t.anyRequest().authenticated(); http.requestMatchers().antMatchers(\u0026quot;/privada\u0026quot;) // Denegamos el acceso a \u0026quot;/privada\u0026quot; .and().authorizeRequests() .antMatchers(\u0026quot;/privada\u0026quot;).access(\u0026quot;hasRole('USER')\u0026quot;) .and().requestMatchers().antMatchers(\u0026quot;/admin\u0026quot;) // Denegamos el acceso a \u0026quot;/admin\u0026quot; .and().authorizeRequests() .antMatchers(\u0026quot;/admin\u0026quot;).access(\u0026quot;hasRole('ADMIN')\u0026quot;); }  En la entrada anterior cuando definíamos la seguridad en la web, explicaba una función llamada configure(HttpSecurity http), ¿ a que se parece mucho a esta ?. Pues si básicamente es la misma, y de hecho recibe un objeto HttpSecurity que debemos configurar.\nExplico linea a linea las sentencias:\n http.authorizeRequests().antMatchers(\u0026ldquo;/oauth/token\u0026rdquo;, \u0026ldquo;/oauth/authorize\u0026rdquo;, \u0026ldquo;/publica\u0026rdquo;).permitAll() Permitimos todas las peticiones a \u0026#8220;/oauth/token\u0026#8221;, \u0026#8220;/oauth/authorize**\u0026#8221;, \u0026#8220;/publica\u0026#8221; sin ningún tipo de validación. anyRequest().authenticated() Esta linea esta comentada, si no lo estuviera todos los recursos serian accesibles solo si se el usuario ha sido validado. requestMatchers().antMatchers(\u0026ldquo;/privada\u0026rdquo;) Denegamos el acceso a la url \u0026#8220;/privada\u0026#8221; authorizeRequests().antMatchers(\u0026ldquo;/privada\u0026rdquo;).access(\u0026ldquo;hasRole(\u0026lsquo;USER\u0026rsquo;)\u0026rdquo;) Permitimos el acceso a \u0026#8220;/privada\u0026#8221; si el usuario validado tiene el role \u0026#8216;USER\u0026#8217; requestMatchers().antMatchers(\u0026ldquo;/admin\u0026rdquo;) Denegamos el acceso a la url \u0026#8220;/admin\u0026#8221; authorizeRequests().antMatchers(\u0026ldquo;/admin\u0026rdquo;).access(\u0026ldquo;hasRole(\u0026lsquo;ADMIN\u0026rsquo;)\u0026rdquo;) Permitimos el acceso a \u0026#8220;/admin\u0026#8221; si el usuario validado tiene el role \u0026#8216;ADMIN\u0026#8217;  Una vez que tenemos nuestra servidor de recursos creado solo debemos crear los servicios lo cual se hace con estas lineas:\n @RequestMapping(\u0026quot;/publica\u0026quot;) public String publico() { return \u0026quot;Pagina Publica\u0026quot;; } @RequestMapping(\u0026quot;/privada\u0026quot;) public String privada() { return \u0026quot;Pagina Privada\u0026quot;; } @RequestMapping(\u0026quot;/admin\u0026quot;) public String admin() { return \u0026quot;Pagina Administrador\u0026quot;; }  Como veis son 3 funciones basicas que solo devuelven sus correspondientes Strings.\nVeamos ahora como funciona la validación.\nPrimero comprobamos que podemos acceder a \u0026#8220;/publica\u0026#8221; sin ningún tipo de validación:\nCorrecto. ¡¡ Esto funciona!!\nSi intento acceder a la pagina \u0026#8220;/privada\u0026#8221; recibo un error \u0026#8220;401 unauthorized\u0026#8221;, lo cual nos indica que no tenemos permiso para ver esa pagina, así que vamos a usar el token emitido por nuestro servidor de autorizaciones, para el usuario \u0026#8216;user\u0026#8217;, a ver que pasa 😉\nAnda, si podemos ver nuestra pagina privada. Probemos con la pagina del administrador\u0026#8230;\nCorrecto, no podemos verla. Asi que vamos a solicitar un nuevo token al administrador de credenciales, pero identificandonos con el usuario \u0026#8216;admin\u0026#8217;.\nEl token devuelto es: \u0026#8221; \u0026#8220;ab205ca7-bb54-4d84-a24d-cad4b7aeab57\u0026#8221;. Lo usamos a ver que pasa:\nBueno, pues ya esta, ya podemos ir de compras con seguridad!!. Ahora ya solo falta montar la tienda y tener los productos 😉\nNos vemos en la próxima, estudiantes 🙂\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/oauth2/",
	"title": "oauth2",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/oauth2/",
	"title": "oauth2",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/17/seguridad-web-en-spring-boot/",
	"title": "Seguridad WEB en Spring Boot",
	"tags": ["java", "mvc", "seguridad", "spring", "spring boot", "thymeleaf"],
	"description": "",
	"content": "En esta entrada voy a explicar como gestiona Spring la seguridad. No todo, por supuesto, que el tema de la seguridad daría para un libro muy gordote, pero al menos aprender a securizar una pagina web. En una próxima entrada hablare de como securizar un servicio REST.\nComo siempre, comienzo diciendo que el código fuente de lo que explico lo tenéis en mi pagina de GITHUB, en https://github.com/chuchip/OAuthServer. El programa esta realizado en Java, usando Spring Boot.\nBien, empecemos por como securizar una pagina web en Spring.\nRealmente usando Spring Boot, es muy sencillo, pues haremos uso de lo que Spring denomina starters, que no son sino grupos de paquetes los cuales agrupan ciertas funcionalidades. Así en este caso, incluiremos el paquete Web, Thymeleaf y, por supuesto, Security.\nAquí tenéis un pantallazo de Eclipse seleccionando los paquetes necesarios.\nDe todos modos, ya sabéis que en el fichero pom.xml podéis ver las dependencias más detalladamente.\nThymeleaf, por si alguien no lo sabe, es un software que se integra perfectamente con Spring y que permite realizar plantillas de páginas WEB. Como JSP, pero muy mejorado o si lo preferís un JavaServer Faces si conocéis más el mundo JavaEE. El caso es que permite realizar paginas HTML que se integran perfectamente con nuestras clases desarrolladas con Spring.\nComo queremos poder ver en nuestra página web el nombre del usuario con el que nos hemos registrado, debemos usar la librería de seguridad de Thymeleaf para Spring. Para ello incluiremos las siguientes lineas en nuestro fichero pom.xml de Maven.\n\u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity4\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.0.3.RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; Y aquí podéis ver como quedara la estructura de nuestro programa\nAhora empecemos a declarar nuestra primera clase, a la que he llamado WebSecurityConfiguration.java\n@SpringBootApplication @EnableWebSecurity public class WebSecurityConfiguration extends WebSecurityConfigurerAdapter { public static void main(String[] args) { SpringApplication.run(WebSecurityConfiguration.class, args); } @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override public \u0026lt;a href=\u0026quot;#UserDetailsService\u0026quot;\u0026gt;UserDetailsService\u0026lt;/a\u0026gt; userDetailsService() { UserDetails user=User.builder().username(\u0026quot;user\u0026quot;) .password(passwordEncoder().encode(\u0026quot;secret\u0026quot;)) .roles(\u0026quot;USER\u0026quot;).build(); UserDetails userAdmin = User.builder().username(\u0026quot;admin\u0026quot;) .password(passwordEncoder().encode(\u0026quot;secret\u0026quot;)) .roles(\u0026quot;ADMIN\u0026quot;).build(); return new InMemoryUserDetailsManager(user,userAdmin); } @Bean public PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http .csrf().disable() .authorizeRequests() .antMatchers(\u0026quot;/\u0026quot;,\u0026quot;/index\u0026quot;,\u0026quot;/webpublico\u0026quot;).permitAll() .antMatchers(\u0026quot;/webprivado\u0026quot;).authenticated() .antMatchers(\u0026quot;/webadmin\u0026quot;).hasRole(\u0026quot;ADMIN\u0026quot;).and() .formLogin() .loginPage(\u0026quot;/login\u0026quot;) .permitAll() .and() .logout() // Metodo get pues he desabilitado CSRF .permitAll(); } }  Lo primero es poner las etiquetas @SpringBootApplication y @EnableWebSecurity. La primera etiqueta es obvia, ya que nuestra aplicación queremos que funcione con Spring Boot ;-). Vamos, que o la ponéis o no seria una aplicación Spring Boot y ya nos podemos ir a casa :-D. La segunda es para especificar que queremos que se active la seguridad Web, realmente esta etiqueta no es obligatorio ponerla porque Spring Boot que es muy listo, en cuanto ve que tenemos el paquete security (en el pom.xml, recordad) en nuestro proyecto la incluye, pero no es mala cosa ponerla por claridad, aunque sea redundante.\nAhora especificamos que nuestra clase va a heredar de WebSecurityConfigurerAdapter pues vamos a sobrescribir algunas de las funciones de esa clase. Para que lo entendáis, básicamente Spring mira a ver si hay alguna clase que implemente el interface WebSecurityConfigurer, el cual implementa la clase WebSecurityConfigurerAdapter , y si lo hay pues utiliza las funciones que tiene ese interface para configurar la seguridad de la aplicación.\nSi no tuviéramos una clase que implementara ese interface, Spring simplemente no dejaría acceder a ninguna pagina de nuestra aplicación, lo que, como comprenderéis no es muy práctico 😉\nBien, ahora sobrescribimos la función authenticationManagerBean que devolverá la clase encargada de manejar las autentificaciones (como su propio nombre indica 😉 ). Vale, os estaréis preguntando, ¿ pero si solo llama a la función padre para que la definimos?. Muy simple porque le ponemos la etiqueta @Bean, para que Spring sepa de donde sacar (inyectar) un objeto tipo AuthenticationManager pues lo necesita para controlar la seguridad.\nEn la función userDetailsService definimos los usuarios que van a tener acceso a nuestra web. En este caso creamos dos usuarios: user y admin (sí lo se, no es que me haya currado mucho el tema de los nombres 😉 ). Cada uno de ellos con su contraseña y su ROL. Aclarar que el ROL es un literal libre, es decir que ahí podemos poner lo que queramos, por ejemplo USUARIO_CON_PECAS. El caso es que luego ese ROL lo utilizaremos y debe coincidir letra a letra con el establecido.\nObservar también que la contraseña se la damos encriptada, en este caso con el algoritmo BCrypt. Esto lo hacemos llamando a la función passwordEncoder, la cual esta anotada con la etiqueta @Bean para que Spring la use.\nEs decir, Spring necesita saber que sistema de encriptación estamos usando para guardar nuestras contraseñas, y para ello busca un objeto que implemente el interface PasswordEncoder. Si no lo encuentra nos fallara la aplicación.\nAclarar que estamos usando la forma más sencilla de declarar los usuarios, guardándolos en memoria con la clase InMemoryUserDetailsManager. En un programa de verdad, se usaría JdbcUserDetailsManager que nos permitiría guardarlos en una base de datos o cualquier otra clase que implemente el interface UserDetailsManager como podría ser LdapUserDetailsManager si quisiéramos usar un servicio LDAP.\nY ya solo nos falta definir que partes de nuestra aplicación vamos a proteger y que roles deben de tener permisos para acceder a cada parte de ella. Sí, he escrito roles y no usuarios porque como hemos dicho antes, al definir un usuario, lo debemos asignar a un rol (o grupo que es más español, si lo preferís). Y, normalmente, las reglas de filtrado se aplican por el grupo al que pertenece el usuario. Para definir los permisos de cada recurso lo haremos configurando el objeto HttpSecurity recibido en la función protected void configure(HttpSecurity http)\nVoy explicando linea a linea lo que se hace en esta función:\n csrf().disable()  Deshabilita el control de csrf. CRSF son las siglas de Cross-site request forgery  como explica la Wikipedia\nCRSF del inglés Cross-site request forgery o falsificación de petición en sitios cruzados) es un tipo de exploit malicioso de un sitio web en el que comandos no autorizados son transmitidos por un usuario en el cual el sitio web confía. Esta vulnerabilidad es conocida también por otros nombres como XSRF, enlace hostil, ataque de un click, cabalgamiento de sesión, y ataque automático.  El deshabilitar el CRSF tiene como efecto secundario que se pueda realizar un logout de una sesión con una petición HTTP tipo GET, pues por defecto solo se puede hacer con una petición POST.\n .authorizeRequests()\n.antMatchers(\u0026#8220;/\u0026#8221;,\u0026#8221;/index\u0026#8221;,\u0026#8221;/webpublico\u0026#8221;).permitAll()\n  Especificamos que las peticiones que en la ruta este cualquiera de las cadenas \u0026#8220;/\u0026#8221;,\u0026#8221;/index\u0026#8221;,\u0026#8221;/webpublico\u0026#8221; no tendrán seguridad. Es decir estarán permitidas para todo el mundo.\n antMatchers(\u0026#8220;/webprivado\u0026#8221;).authenticated()  Especificamos que las peticiones a la ruta \u0026#8220;/webprivado\u0026#8221; solo podrán ser procesadas si el usuario esta autentificado, sin especificar a que ROL debe pertenecer.\n .antMatchers(\u0026#8220;/webadmin\u0026#8221;).hasRole(\u0026#8220;ADMIN\u0026#8221;)  Solo los usuarios que sean del grupo ADMIN tendrán acceso a la URL \u0026#8220;/webadmin\u0026#8221;\nLa función antMatchers permite el uso de expresiones regulares, por lo que si, por ejemplo, quisiéramos aplicar una regla a todo lo que dependa de una ruta, podríamos poner esto :\nhttp.antMatchers(\u0026#8220;/users/\u0026#8221;).hasRole(\u0026#8220;USER\u0026#8221;) **para especificar que cualquier petición a la URL /users/Y_LO_QUE_SEA solo tendrán acceso los usuarios que pertenezcan al grupo USER.\n .formLogin().loginPage(\u0026#8220;/login\u0026#8221;).permitAll()  Especificamos que la pagina de login sera \u0026#8220;/login\u0026#8221; (valga la repugnancia ;-)) y que que puede acceder todo el mundo.\n logout().permitAll()  Especificamos que a la pagina de desconexión (logout) pude acceder a todo el mundo. Por defecto esta pagina responde en la URL \u0026#8220;/logout\u0026#8221;\nPerfecto, ya tenemos definida la seguridad de nuestras paginas web, ahora solo queda definir los puntos de entrada a las páginas. Eso se hace en la clase WebController.java\n@Controller public class WebController { @RequestMapping({\u0026quot;/\u0026quot;,\u0026quot;index\u0026quot;}) public String inicio() { return \u0026quot;index\u0026quot;; } @RequestMapping(\u0026quot;/webprivado\u0026quot;) public String privado() { return \u0026quot;privado\u0026quot;; } @RequestMapping(\u0026quot;/webpublico\u0026quot;) public String loginpub() { return \u0026quot;publico\u0026quot;; } @RequestMapping(\u0026quot;/webadmin\u0026quot;) public String admin() { return \u0026quot;admin\u0026quot;; } @RequestMapping(\u0026quot;/login\u0026quot;) public String login() { return \u0026quot;login\u0026quot;; } }  La clase como se ve no tiene muchos misterios,simplemente especificamos con la etiqueta @Controller que sera una clase donde vamos a definir puntos de entrada para las peticiones web.\nEn las diferentes funciones tenemos la etiqueta @RequestMapping para especificar la URL que debe procesar cada función. Así la función inicio sera llamada cuando haya una petición a la URL \u0026#8220;/\u0026#8221; o a \u0026#8220;/index\u0026#8221;. Observar que no hay que poner la barra inicial en \u0026#8220;index\u0026#8221;.\nLa cadena devuelta sera la plantilla Thymeleaf devuelta, de tal manera que la llamada función inicio devolverá la plantilla \u0026#8220;index.html\u0026#8221; que es la siguiente:\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity5\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Página Inicio\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;Pagina Inicio\u0026lt;/h1\u0026gt; \u0026lt;p\u0026gt;Pulsa \u0026lt;a th:href=\"@{/webpublico}\"\u0026gt;aqui\u0026lt;/a\u0026gt; para ver una pagina publica.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Si eres un usuario normal pulsa \u0026lt;a th:href=\"@{/webprivado}\"\u0026gt;aqui\u0026lt;/a\u0026gt; para ver una pagina privada\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Si eres un administrador normal pulsa \u0026lt;a th:href=\"@{/webadmin}\"\u0026gt;aqui\u0026lt;/a\u0026gt; para ver la pagina del administrador\u0026lt;/p\u0026gt; \u0026lt;div sec:authorize=\"isAuthenticated()\"\u0026gt; Hello \u0026lt;span sec:authentication=\"name\"\u0026gt;someone\u0026lt;/span\u0026gt; \u0026lt;p\u0026gt;\u0026lt;a th:href=\"@{/logout}\"\u0026gt;Desconectar\u0026lt;/a\u0026gt;\u0026lt;/p\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ¿A que casi parece HTML puro?. Es una de las ventajas de Thymeleaf que usa etiquetas HTML estándar. No voy a explicar este lenguaje, pero os explicare un poco las etiquetas usadas:\n\u0026lt;a th:href=”@{/webpublico}”\u0026gt;\nCrea un enlace a la URL \u0026ldquo;/webpublico\u0026rdquo;;. Seria como poner la etiqueta \u0026#8220;\n\u0026lt;div sec:authorize=”isAuthenticated()”\u0026gt;\nSolo se renderizara el código en el DIV si el usuario esta autentificado. En otras palabras si el usuario no esta logueado no se mostrara en la página web lo que hay entre las etiquetas DIV (de hecho no se mostrara ni el DIV).\n\u0026lt;span sec:authentication=”name”\u0026gt;someone\u0026lt;/span\u0026gt; Si el usuario esta autentificado mostrara el nombre del usuario, en caso contrario mostrara lo que haya entre las etiquetas span. En este caso mostraría someone.\nY con esto ya tenemos una aplicación securizada. !Sí!, con solo dos clases java y sus correspondientes ficheros HTML.\nPara terminar esta entrada, os dejo unos capturas de pantalla de la aplicación:\n¡¡ Hasta otra !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/thymeleaf/",
	"title": "thymeleaf",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/thymeleaf/",
	"title": "thymeleaf",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-y-springboot-2a-parte/",
	"title": "Aplicacion CRUD con REST en Kotlin y SpringBoot (2ª Parte)",
	"tags": ["crud", "jpa", "kotlin", "spring boot"],
	"description": "",
	"content": "Hola de nuevo, chicos.\nContinuo con la entrada http://www.profesor-p.com/2018/10/11/aplicacion-crud-en-kotlin-con-springboot/ para ver como realizar las peticiones REST , con protocolo JSON que es el estándar de facto 😉 en Kotlin.\nUna vez que ya tenemos la lógica de acceso a nuestra base de datos, tenemos que hacer la parte Web. Pues, aunque os parezca increíble, esto se hace con una sola clase y ademas de muy pocas lineas.\nLa clase en cuestión es ApiController.kt\n@RestController @RequestMapping(\u0026quot;/api/\u0026quot;) class ApiController { @Autowired lateinit var localeRepository: LocaleRepository @CrossOrigin(\u0026quot;http://localhost:4200\u0026quot;) @GetMapping(\u0026quot;/\u0026quot;) fun getAll(): Iterable\u0026amp;lt;Locales\u0026amp;gt; { return localeRepository.findAll();\t} ​\t..... }  Bueno, lo primero es poner la anotación @RestController para que Spring sepa que esta clase responderá a las peticiones REST y despues especificar la ruta que tratara esta clase con la anotación @RequestMapping(\u0026#8220;/api/\u0026#8221;). Es decir esta clase responderá en la URL: http://localhost:8080/api/\nInyectamos una referencia a la clase LocaleRepository con la etiqueta @AutoWired, para poder acceder a nuestro repositorio (la base de datos, vamos). Observar el modificador lateinit para que Kotlin no se queje de que la variable es null.\n Función getAll  Esta responderá a las peticiones GET en \u0026#8220;/\u0026#8221; devolviendo una lista con todos los objetos tipo Locales disponibles. Observar la anotación @CrossOrigin(\u0026#8220;http://localhost:4200\u0026amp;#8221;) para que se pueda acceder desde un navegador solo si el cliente esta accediendo a http://localhost:4200.\nEsto es porque, por seguridad, los navegadores no permiten hacer peticiones AJAX (con las cuales se hacen las peticiones REST en angular normalmente) a una dirección que no sea la de la URL principal. Vamos, para que si tu estas en www.google.com, la página por debajo no pueda acceder a www.elpais.com. Sin embargo con la etiqueta @CrossOrigin nuestra aplicación informara al navegador de que permita acceder siempre y cuando la URL de origen sea la especificada.\nTener en cuenta que esta limitación la imponen los navegadores Web (Chrome, Firefox, IE, etc), si accedemos directamente con otro programa a la dirección http://localhost:8000/api no tendrá efecto esta directiva.\nAquí os muestro un pantallazo de la salida de PostMan:\n Función getByQuery\n@CrossOrigin(\u0026quot;http://localhost:4200\u0026quot;) @GetMapping(\u0026quot;/{codigo}/{nombre}\u0026quot;) fun getByQuery(@PathVariable codigo:String,@PathVariable nombre:String): Iterable\u0026amp;lt;Any\u0026amp;gt; { return localeRepository.findLike(\u0026quot;%\u0026quot;+codigo+\u0026quot;%\u0026quot;,\u0026quot;%\u0026quot;+nombre.toUpperCase()+\u0026quot;%\u0026quot;); }   Aquí vemos de nuevo la etiqueta @CrossOrign y la etiqueta @GetMapping(\u0026#8220;/{codigo}/{nombre}\u0026#8221;) con lo cual especificamos que esta función tratara las llamadas a la URL: http://localhost:8080/api/XX/YY . Observar las etiquetas @PathVariable en los parámetros de la función para especificar que debe pasar las diferentes partes de la ruta a las variables de la función.\nLlamamos a la función findLike de nuestro clase repositorio la cual nos devolverá todos los objetos Locales que cumplan los criterios de la búsqueda.\n Función insertar\n@CrossOrigin(\u0026quot;http://localhost:4200\u0026quot;) @PostMapping(\u0026quot;/\u0026quot;)\tfun insertar(@RequestBody locales:Locales): ResponseEntity\u0026amp;lt;Any\u0026amp;gt; { if (localeRepository.existsById(locales.codigo ) )\treturn ResponseEntity(HttpStatus.CONFLICT); localeRepository.save(locales) return ResponseEntity .created( URI(\u0026quot;/api/\u0026quot;+locales.codigo)).body(\u0026quot;\u0026quot;); }   Esta función sera invocada cuando la petición HTTP sea de tipo POST, a la ruta \u0026#8220;/\u0026#8221;, como así se indica con la etiqueta @PostMapping(\u0026#8220;/\u0026#8221;). En la función incluimos la etiqueta @RequestBody para indicarle a Spring que en el cuerpo de la petición HTTP ira un objeto tipo Locales. en formato JSON, al no especificar lo contrario.\nComprobamos si el código ya existe, para devolver una respuesta con el código CONFLICT, con lo cual indicaríamos al cliente que hay un error.\nDespués guardamos la entidad y devolvemos un código CREATED, con la URL que indica el código del país insertado.\nEsto es un pantallazo donde se ve como insertaríamos un nuevo país en la base de datos.\n Función deleteByCodigo\n@CrossOrigin(\u0026quot;http://localhost:4200\u0026quot;) @DeleteMapping (\u0026quot;/{codigo}\u0026quot;) fun deleteByCodigo(@PathVariable codigo:String):ResponseEntity\u0026amp;lt;Any\u0026amp;gt; { if (!localeRepository.existsById(codigo) )\tthrow NotFoundException(codigo) localeRepository.deleteById(codigo); return ResponseEntity( HttpStatus.OK) }   Esta función sera llamada cuando recibamos una petición HTTP tipo DELETE, a la ruta /XX. Es decir responderá con una petición DELETE como la del pantallazo que adjunto:\nObservar que si el país no existe lanzamos una excepción tipo NotFoundException . \nDetallo la clase a continuación:\n@ResponseStatus(HttpStatus.NOT_FOUND) class NotFoundException: RuntimeException { constructor(codigo: String?): super(\u0026quot;No encontrados registro \u0026quot;+codigo); }  Esta clase tiene la etiqueta @ResponseStatus que indica que tipo de respuesta recibirá el cliente cuando se lance esta excepción. En este caso recibirá un tipo NOT_FOUND (404), con el mensaje \u0026#8220;No encontrados registro xxx\u0026#8221;, como se ve en la siguiente pantalla.\n Función update\n@CrossOrigin(\u0026quot;http://localhost:4200\u0026quot;) @PutMapping (\u0026quot;/{codigo}\u0026quot;) fun update(@PathVariable codigo:String,@RequestBody locales:Locales):ResponseEntity\u0026amp;lt;Any\u0026amp;gt; { if (!localeRepository.existsById(codigo) )\tthrow NotFoundException(codigo) if (!codigo.equals(locales.codigo)) throw ConflictException(codigo) localeRepository.save(locales); return ResponseEntity( HttpStatus.OK) }   Esta función actualizara el nombre de un país mandado. Observar que recibe en la ruta el código del país a modificar y en el cuerpo de la petición (Body) un objeto Locales.\nSi el código del país mandado es diferente al del objeto, lanza una excepción tipo ConflictException que es muy parecida a NotFoundException pero devolviendo un código HTTP CONFLICT.\nY ya esta chicos. Para probar la aplicación usaremos el programa realizado en Angular, que explicaba en la entrada http://www.profesor-p.com/2018/10/08/aplicacion-crud-en-angular/ , teniendo cuidado de cambiar el valor de la variable URL de la clase datosserver.service.ts para que apunte a donde escucha nuestra aplicación.\n export class DatosserverService { url:string; constructor(private _http:HttpClient) { this.url=\u0026quot;http://localhost:8080/api/\u0026quot;; } ....  Y veremos como apenas 4 sencillas clases tenemos una aplicación totalmente funcional. ¿ A que es increíble la potencia de Spring y más si la juntamos con Kotilin?. ¡¡ Pues a programar que es la mejor manera de aprender 😉 !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/crud/",
	"title": "crud",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/kotlin/",
	"title": "kotlin",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/kotlin/",
	"title": "kotlin",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/angular/",
	"title": "angular",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/angular/",
	"title": "angular",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/frontend/",
	"title": "frontend",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/glassfish/",
	"title": "glassfish",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/glassfish/",
	"title": "glassfish",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/javaee/",
	"title": "javaee",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/javaee/",
	"title": "javaee",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/netbeans/",
	"title": "netbeans",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/acerca/",
	"title": "Acerca de",
	"tags": [],
	"description": "",
	"content": "Este es mi blog profesional, hecho con mimo personal.\nDetrás del Profesor P. esta Jesús Javier Puente Sánchez. Un analista/programador, que también es administrador de sistemas y bases de datos. Defensor del software libre, y con varios ERPs a sus espaldas, he querido aportar mi granito de arena a la comunidad, creando Anjelica.\nEn esta pagina, iré poniendo ejemplos (prácticos a poder ser) de programación, ademas de alguna que otra entrada sobre cosas de la Informática esa, que he convertido en mi pasión desde mi más tierna juventud 😉\nPara saber más de mi visitar mi página de Linkedin o ver mi experiencia profesional en este mismo blog.\nPuedes contactar conmigo a través de mi correo o seguir mi cuenta de Twitter que es @chuchip\nTambién Podéis ver algunos de mis proyectos en mi página de GitHub.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/24/hablando-espanol/",
	"title": "Angular – Hablando español",
	"tags": ["angular", "i18n", "internacionalizacion"],
	"description": "",
	"content": "Angular si no se le dice lo contrario, es ingles del bueno. Las fechas las pondrá en su formato de mes/dia/año . Los números serán con las comas con separadores de miles y los decimales con puntos. Vamos, muy ingles todo.\nEl problema es que no todo el mundo es ingles (aunque les pene a los ingleses ;- )) . Así que en esta entrada voy a explicar como hacer que Angular se nos vuelva español.\nLo primero es editar el fichero app.module.ts, para importar nuestros ficheros de locale (lease localización 😉 ) .\nimport localeEs from '@angular/common/locales/es'; registerLocaleData(localeEs, 'es');  Ahora tendremos que incluir un provider para que cuando mostremos un valor por pantalla y queramos formatearlo lo formatee con nuestro locale español.\nDe hecho, si no ponemos este provider, Angular cascara con gran alegría, si intentamos utilizar un pipe.\n@NgModule({ ..... providers: [ { provide: LOCALE_ID, useValue: 'es' } ], ..... })  Ahora si en nuestra aplicación tenemos este código:\nimport { Component } from '@angular/core'; @Component({ selector: 'app-prueba', template: ` \u0026lt;p\u0026gt; Numero: {{numero | number: '1.2-2'}}\u0026lt;br\u0026gt; Fecha: {{fecha | date: 'shortDate'}} \u0026lt;/p\u0026gt; ` }) export class PruebaComponent { numero=1234.5; fecha=new Date(); }  Donde, como podemos ver utilizamos pipes, para formatear un numero: {{numero | number: \u0026#8216;1.2-2\u0026#8217;}} y una fecha: {{fecha | date: \u0026#8216;shortDate\u0026#8217;}} \nEl resultado sera el siguiente, que como se ve, es la salida en nuestro querido lenguaje español.\nAhora ya solo falta que hagáis vuestra aplicación multi-lenguaje. O sea, que se pueda elegir el idioma en que se van a presentar tanto los textos como los lenguajes.\nPero eso, chavales, es para nota.. y si me apetece ya lo explicare otro día.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/i18n/",
	"title": "i18n",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/i18n/",
	"title": "i18n",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/internacionalizacion/",
	"title": "internacionalizacion",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/20/angular-6-anadir-bootstrap-4-con-jquery/",
	"title": "Angular 6 – Añadir Bootstrap 4 con JQuery",
	"tags": ["angular", "bootstrap", "jquery", "pooper"],
	"description": "",
	"content": "Recordar lo primero que para utilizar toda la potencia de BootStrap, necesitamos tener instaladas las librerias de JQuery y Popper Hay varias maneras de instalar estas librerías.\n Localmente usando npm  Una vez estemos situados el directorio principal del proyecto, desde tu terminal preferido ejecutar las instrucciones siguientes:\nnpm install bootstrap@4 jquery popper.js --save Esto nos instalara los archivos necesarios bajo el directorio node-modules. \nAhora debemos incluir el fichero de estilos (css) de BootStrap y las librerías JavaScript de BootStrap, JQuery y Pooper.\nUna de las opciones es editando el fichero angular.json, e incluirlas en los campos styles y scripts.\nEl fichero quedaría algo así como esto:\n...... CODIGO ANTERIOR .... \"styles\": [ \"src/styles.css\", \"./node_modules/bootstrap/dist/css/bootstrap.min.css\" ], \"scripts\": [ \"./node_modules/jquery/dist/jquery.min.js\", \"./node_modules/bootstrap/dist/js/bootstrap.min.js\", \"./node_modules/pooper.js/dist/js/pooper.min.js\", ] ...... CODIGO POSTERIOR .... Recordar que hay que parar el servidor de node.js y volverlo a ejecutar con ng serve si modificamos el fichero angular.json\nOtra manera de incluir estos ficheros seria añadirlos en index.html, dentro de HEAD. Esto si fuera un proyecto habitual en HTML.\n .... \u0026lt;head\u0026gt; \u0026lt;link rel=\"stylesheet\" href=\"../node_modules/bootstrap/dist/css/bootstrap.min.css\"\u0026gt; \u0026lt;script src=\"../node_modules/jquery/dist/jquery.min.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\"../node_modules/bootstrap/dist/js/bootstrap.min.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script src=\"../node_modules/pooper.js/dist/js/pooper.min.js\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/head\u0026gt; ....   Usando CDN  En este caso, no bajamos nada locamente y lo que hacemos es incluir los enlaces hacia los correspondientes ficheros en interner.\nAsí, como explican en la pagina de BootStrap CDN, añadiríamos esta linea para incluir bootstrap versión 4.1.3\n\u0026lt;span class=\"nt\"\u0026lt;link\u0026lt;/span \u0026lt;span class=\"na\"rel=\u0026lt;/span\u0026lt;span class=\"s\"\"stylesheet\"\u0026lt;/span \u0026lt;span class=\"na\"href=\u0026lt;/span\u0026lt;span class=\"s\"\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/css/bootstrap.min.css\"\u0026lt;/span \u0026lt;span class=\"na\"integrity=\u0026lt;/span\u0026lt;span class=\"s\"\"sha384-MCw98/SFnGE8fJT3GXwEOngsV7Zt27NXFoaoApmYm81iuXoPkFOJwJ8ERdknLPMO\"\u0026lt;/span \u0026lt;span class=\"na\"crossorigin=\u0026lt;/span\u0026lt;span class=\"s\"\"anonymous\"\u0026lt;/span\u0026lt;span class=\"nt\"\u0026gt;\u0026lt;/span \u0026lt;span class=\"nt\"\u0026lt;script \u0026lt;/span\u0026lt;span class=\"na\"src=\u0026lt;/span\u0026lt;span class=\"s\"\"https://stackpath.bootstrapcdn.com/bootstrap/4.1.3/js/bootstrap.min.js\"\u0026lt;/span \u0026lt;span class=\"na\"integrity=\u0026lt;/span\u0026lt;span class=\"s\"\"sha384-ChfqqxuZUCnJSK3+MXmPNIyE6ZbWh2IMqE241rYiqJxyMiZ6OW/JmZQ5stwEULTy\"\u0026lt;/span \u0026lt;span class=\"na\"crossorigin=\u0026lt;/span\u0026lt;span class=\"s\"\"anonymous\"\u0026lt;/span\u0026lt;span class=\"nt\"\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/span Y esta linea para incluir JQuery y Pooper\n\u0026lt;span class=\"nt\"\u0026lt;script \u0026lt;/span\u0026lt;span class=\"na\"src=\u0026lt;/span\u0026lt;span class=\"s\"\"https://code.jquery.com/jquery-3.3.1.slim.min.js\"\u0026lt;/span \u0026lt;span class=\"na\"integrity=\u0026lt;/span\u0026lt;span class=\"s\"\"sha384-q8i/X+965DzO0rT7abK41JStQIAqVgRVzpbzo5smXKp4YfRvH+8abtTE1Pi6jizo\"\u0026lt;/span \u0026lt;span class=\"na\"crossorigin=\u0026lt;/span\u0026lt;span class=\"s\"\"anonymous\"\u0026lt;/span\u0026lt;span class=\"nt\"\u0026gt;\u0026lt;/script\u0026gt;\u0026lt;/span \u0026lt;span class=\"nt\"\u0026lt;script \u0026lt;/span\u0026lt;span class=\"na\"src=\u0026lt;/span\u0026lt;span class=\"s\"\"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.3/umd/popper.min.js\"\u0026lt;/span \u0026lt;span class=\"na\"integrity=\u0026lt;/span\u0026lt;span class=\"s\"\"sha384-ZMP7rVo3mIykV+2+9J3UJ46jBk0WLaUAdn689aCwoqbBJiSnjAK/l8WvCWPIPm49\"\u0026lt;/span \u0026lt;span class=\"na\"crossorigin=\u0026lt;/span\u0026lt;span class=\"s\"\"anonymous\"\u0026lt;/span\u0026lt;span class=\"nt\"\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/span   ¡¡Y a trabajar con BootStrap y crear aplicaciones profesionales!!  "
},
{
	"uri": "http://ww2.profesor-p.com/categories/pooper/",
	"title": "pooper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/pooper/",
	"title": "pooper",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/19/curso-angular-6-reactivo/",
	"title": "Curso Angular 6 – Reactivo!",
	"tags": ["angular", "angular6", "reactivo"],
	"description": "",
	"content": "Antes de continuar con el curso quiero dejar claro que Angular es reactivo.\n¿ Que significa eso ?.\nPues básicamente que cualquier cambio que se haga en el modelo sera transmitido a la vista y viceversa. El modelo, entiéndase que son nuestros _Componentes. _Es decir, nuestras clases definidas en los ficheros TypeScript. La vista es el código HTML que se visualizara en nuestro navegador.\nAsí, si cambiamos el valor de un campo INPUT del HTML, que este unido con la directiva [(ngModel)] a una variable. Esa variable se modificara en tiempo real.\nObsérvese el siguiente código:\nimport { Component} from '@angular/core'; @Component({ selector: 'app-datos-mes', template: '\u0026lt;p\u0026gt;Teclea aquí: \u0026lt;input [(ngModel)]=\u0026quot;variable\u0026quot;/\u0026gt; \u0026lt;br\u0026gt;lo que estas tecleando: {{variable}} \u0026lt;/p\u0026gt;', }) export class DatosMesComponent{ variable:string=\u0026quot;\u0026quot;; }  Esto nos mostraría una pantalla como esta:\n!()[/img/2018/09/Captura1.png)\nAl modificar el valor del input, cambiara el valor mostrado.\nEn cuanto tecleemos una letra, el valor de variable cambiara y, por lo tanto, el valor mostrado con {{variable}} también cambiara.\nEsto funciona a todos los niveles. Incluyendo las condiciones.\nimport { Component} from '@angular/core'; @Component({ selector: 'app-datos-mes', template: `\u0026lt;p\u0026gt;Teclea aquí: \u0026lt;input [(ngModel)]=\u0026quot;variable\u0026quot;/\u0026gt; \u0026lt;br\u0026gt;lo que estas tecleando: {{variable}} \u0026lt;/p\u0026gt; \u0026lt;div *ngIf=\u0026quot;variable=='0'\u0026quot;\u0026gt;Variable es cero\u0026lt;/div\u0026gt; `, }) export class DatosMesComponent{ variable:string=\u0026quot;\u0026quot;; }  Así, en el momento que el valor de variable sea igual a \u0026#8220;0\u0026#8221; Nos mostrara el texto Variable es cero. Como se puede ver en el siguiente vídeo .\n/img/2018/09/prueba4.mp4  "
},
{
	"uri": "http://ww2.profesor-p.com/tags/angular6/",
	"title": "angular6",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/reactivo/",
	"title": "reactivo",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/09/19/curso-angular-6-formularios-1/",
	"title": "Curso Angular 6 – Formularios (1)",
	"tags": ["angular", "formularios"],
	"description": "",
	"content": "En la aplicación que estamos desarrollando, de la cual, os recuerdo tenéis el código fuente en https://github.com/chuchip/yagesclient-angular, tenemos que poder solicitar al usuario el ejercicio sobre el que vamos a realizar la consulta.\nPara introducir ese dato, vamos a utilizar un formulario muy simple, pero que nos servirá para entender algunos conceptos básicos de Angular.\nTrabajando con el componente AppComponent, definido en el fichero src/app/app.component.ts nos centramos primero en el código HTML el cual, es el siguiente:\napp.component.html\n\u0026lt;form (ngSubmit)=\"buscar()\"\u0026gt; \u0026lt;label value=\"Introduzca año\"\u0026gt;Introduzca Año \u0026lt;/label\u0026gt; \u0026lt;input [(ngModel)]=\"ejercicio\" /\u0026gt; \u0026lt;span *ngIf=\"msgError !=''\" \u0026gt; {{msgError}} \u0026lt;/span\u0026gt; \u0026lt;div\u0026gt;\u0026lt;button \u0026gt;Consultar\u0026lt;/button\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/form\u0026gt; En la etiqueta form con el modificador (ngSubmit)=\u0026#8221;buscar()\u0026#8221; indicaremos que llame a la función buscar del componente AppComponent cuando se envié el formulario con el botón correspondiente.\nEn el input, vemos la etiqueta [(ngModel)] , a la que le asignamos el valor \u0026#8220;ejercicio\u0026#8221;. Esta etiqueta sirve para unir el valor de la variable ejercicio con la vista. Esa unión es bidireccional; si se modifica el valor de la variable en AppComponent  se cambiara el valor en la vista y viceversa. Estos cambios son inmediatos, es decir en cuanto introduzcamos una letra (o la borremos) en la pagina web, el valor de la variable ejercicio cambiara inmediatamente.\nLa variable, esta definida como otra cualquiera, sin ningún tipo de decorador o etiqueta especial.\nA continuación, en la etiqueta span vemos la directiva *ngIf . Con ella indicamos que la etiqueta span y todo lo que haya dentro de ella solo se debe procesar (y por lo tanto mostrar) si se cumple la condición indicada.\nEn este caso, si la variable msgError es diferente de \u0026#8220;\u0026#8221; (o sea si no esta vacía) se ejecutara la etiqueta span. En caso contrario, simplemente saltara hasta donde se cierre esa etiqueta con \nDentro de span encontramos el texto {{msgError}}. Con las dobles llaves le indicamos a Angular que lo que hay en su interior es una variable de nuestro _componente _que debe mostrar. Digamos que es un poco como la directiva ngModel pero de solo salida. De tal modo que si cambia el valor de la variable, cambiara el valor mostrado en nuestro navegador.\nLa variable entre las dobles llaves puede ser de cualquier tipo. Una cadena de texto, un objeto, un número, etc.\napp.component.ts\nexport class AppComponent {  ejercicio=2018; ejercicioActual=0; msgError=\"\"; constructor( private router: Router) { } buscar(): void { let num:number=+this.ejercicio; if (num == 0 ) { this.msgError=\"Ejercicio no ES valido\"; return; } this.msgError=\"\"; this.ejercicioActual=this.ejercicio; this.router.navigate([''+this.ejercicioActual]) } } De este modo, cuando muestre el formulario en la página web, el input aparecerá con el valor 2018.\nObservemos ahora la función buscar. Esa función, como hemos dicho, sera llamada cuando pulsemos el botón de nuestro formulario.\nLo primero que hacemos es asignar a una variable local, a la que hemos llamado num el valor de la variable global ejercicio. Obsérvese la palabra this antes de ejercicio, para indicar que esa variable es global. Si pondríamos ejercicio sin la palabra reservada this, Angular daría un error, avisando de que esa variable no existe.\nSi nos fijamos vemos que se pone un más (+) antes de this.ejercicio  esto es una facilidad que nos da JavaScript para transformar una variable a tipo numérico. De ese modo, si el usuario ha introducido en el campo de texto algo que no sea un numero, por ejemplo \u0026#8220;pepe\u0026#8221;, como no se podrá transformar this.ejercicio a un número, el valor de num sera igual a cero.\nEn el caso de que num sea cero, ponemos la variable global this.msgError con el texto de error y saldrá de la función.\nEn caso de que num sea diferente a cero ponemos la variable this.msgError a \u0026#8220;\u0026#8221; (cadena vacía) , y la variable ejercicioActual la hacemos igual a ejercicio, para después navegar a la ruta ejercicioActual, llamando a la función navigate del objeto this.router que Angular habrá inyectado en nuestra clase al haber puesto en el constructor que recibimos la variable router del tipo Router.\nEntiéndase que _navegar _es a todos efectos como si el usuario pusiera en la barra de navegación lo que nosotros hemos programado. En este caso, si se ha introducido el valor 2018 en el formulario, iríamos a la dirección http://localhost:8080/2018\nResumiendo, cuando se pulse el botón Consultar, si el usuario introduce un número valido en el formulario, navegaremos al ejercicio tecleado. En caso contrario aparecerá el mensaje Ejercicio no ES valido.\n¡¡ Nos vemos en la próxima clase 😉 !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/formularios/",
	"title": "formularios",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/curso/",
	"title": "curso",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/routes/",
	"title": "routes",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/angular-6/",
	"title": "angular 6",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/jndi/",
	"title": "jndi",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/java-ee/",
	"title": "Java ee",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/netbeans/",
	"title": "netbeans",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/netbeans9/",
	"title": "netbeans9",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/categories/lambda/",
	"title": "lambda",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/jndi/",
	"title": "jndi",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/28/ejemplo-aplicacion-mvc-con-spring-boot-usando-netbeans-9/",
	"title": "Ejemplo aplicación MVC con Spring Boot  usando NetBeans 9",
	"tags": ["java", "mvc", "netbeans", "spring boot"],
	"description": "",
	"content": "En una entrada anterior explique como instalar NetBeans 9, añadiendole el plugin para usar Spring Boot.\nAhora vamos a crear nuestro primer proyecto en este entorno.\nPulsaremos New Project, lo cual nos mostrara una pantalla como la siguiente.\ny en el campo Filter pondremos spring,  para después eligir Spring Boot Inititilizr project. Pulsaremos Next y nos pedirá una serie de datos sobre nuestro proyecto. Para este ejemplo podemos dejar los campos como aparecen por defecto.\nPulsamos siguiente (Next) y ahora debemos especificar de que tipo es nuestro proyecto:\nComo se ve hay muchas opciones, nosotros solo marcaremos la casilla WEB, porque va a ser una aplicación WEB y Thymeleaf, porque es el motor de plantillas (Template Engines) que vamos a usar. Thymeleaf es un sustituto o evolución de JSP con diferentes mejoras y que se integra perfectamente con Spring. Su pagina web es: https://www.thymeleaf.org/ y tenéis una buena documentación. De todos modos, en este ejemplo solo usaremos código HTML sin poner código en nuestras plantillas.\nVolveremos a pulsar Next, para, en el ultimo paso poner el nombre de nuestro provecto\n\u0026nbsp;\nPulsaremos Finish  y esperaremos a que Maven baje los paquetes necesarios y configure el entorno de trabajo.\nAhora vamos a crear un par de paginas web. La primera sera index.html, la otra sera otrapagina.html. Esas paginas las debemos crear en OtherResources src/main/resources templates, como se ve en la siguiente imagen:\nLos ficheros creados son tipo HTML.\nLos Ficheros quedaran así\nindex.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html xmlns=\"http://www.w3.org/1999/xhtml\" xmlns:th=\"http://www.thymeleaf.org\" xmlns:sec=\"http://www.thymeleaf.org/thymeleaf-extras-springsecurity3\"\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Pagina de Inicio\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"UTF-8\"/\u0026gt; \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"/\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Mi pagina de inicio\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;a href=\"otra\"\u0026gt;ir a la otra pagina\u0026lt;/a\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; otrapagina.html\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;title\u0026gt;Otra pagina de prueba\u0026lt;/title\u0026gt; \u0026lt;meta charset=\"UTF-8\"\u0026gt; \u0026lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\"\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div\u0026gt;Mi otra pagina de prueba\u0026lt;/div\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Ahora mismo ya podríamos ejecutar nuestra aplicación, y veríamos nuestro index.html, pero vamos a crear el controlador para que se pueda mostrar la pagina otrapagina.html. Para ello, en Source Packages, dentro del paquete com.example.demo crearemos un nuevo fichero java al que llamaremos Controlador.java\nEn este fichero tendremos lo siguiente:\npackage com.example.demo; import org.springframework.stereotype.Controller; import org.springframework.web.bind.annotation.GetMapping; @Controller public class Controlador { @GetMapping(\u0026quot;otra\u0026quot;) public String login() {\treturn \u0026quot;otrapagina\u0026quot;; } }  Esta clase marcada con @Controller, tendrá una única función que tiene la etiqueta @GetMapping. El parámetro de esa etiqueta sera la URL o página que debe tratar la función que tenemos debajo.\nEs decir, que cuando nosotros pongamos en nuestro navegador:\nhttp://localhost:8080/otra\nSpring ejecutara lo que haya en la función login().\nSi quisiéramos tener mas paginas simplemente añadiremos más funciones, con la etiqueta @GetMapping(\u0026#8220;PAGINA QUE NOS DE LA GANA\u0026#8221;)\nTerminar, comentando que el String devuelto por nuestra función es la pagina web (el fichero) creado bajo el directorio templates (sin la extensión html). Resumiendo, en este ejemplo, al ir a:\nhttp://localhost:8080/otra\nSpring parseara el fichero otrapagina.html y devolverá la pagina HTML creada por el.\nY con esto, ya hemos creado nuestra primera pagina web con Spring 😉\nTerminar diciendo que el código fuente de este proyecto lo tenéis en mi repositorio de GITHUB.\n"
},
{
	"uri": "http://ww2.profesor-p.com/anjelica/",
	"title": "ERP Anjelica",
	"tags": [],
	"description": "",
	"content": "Para aquellas pequeñas empresas que necesitan tener una trazabilidad sencilla pero potente, y ademas gratis, prueba mi ERP.\nTotalmente funcional, te sorprenderá gratamente.\nMás información aquí.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/junit/",
	"title": "junit",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/junit/",
	"title": "junit",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/test/",
	"title": "test",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/27/instalar-plugin-spring-boot-con-netbeans-9-en-ubuntu-18-04/",
	"title": "Instalar plugin Spring Boot en NetBeans",
	"tags": ["java", "linux", "netbeans", "spring boot"],
	"description": "",
	"content": "En esta entrada explicare como crear un aplicación con el framework Spring Boot, usando el IDE NetBeans 9.\nAdemas haremos todo esto en un Linux Ubuntu 18.04\nSi no sabéis lo que es Spring Boot, ya estáis tardando en aprender al menos los conceptos básicos.\n Spring Boot es Spring hecho (más) fácil.  Con Spring Boot, entre otras cosas, se puede realizar una aplicación Web, con una mínima configuración. Una aplicación demo se crea en apenas 5 minutos. Y ademas, sin tener que usar un servidor de aplicaciones, pues Spring Boot, ya incluye una versión de Tomcat embebida. Spring Boot usa un sistema de paquetes, que hace mas fácil las dependencias de Maven (o Gradle). Spring Boot, la versión 5, funciona con Java 1.8 o superior, haciendo mucho uso de Lambdas, Streams y todas las nuevas capacidades de este lenguaje.  Este es un video con una charla de introducción, de la gente de Paradigma Digital.\n\nYa se que Spring tiene su propio IDE, basado en Eclipse, pero la ultima versión al menos, esta tan pensada para Spring Boot, que intentar utilizar otro servidor de aplicaciones es muy engorroso. Y bueno, que hay gente que nos sentimos cómodos con NetBeans y no nos apetece cambiar de IDE 🙂\nPero si os apetece probar un IDE, totalmente configurado para Spring Boot , usar Spring Tool Suite bajándolo de https://spring.io/tools/sts. No es mal IDE, pero \u0026#8230;. no es mi IDE 😉\nBueno, lo primero es tener NetBeans 9 instalado, para ello, lo primero seria ir a la siguiente página: https://netbeans.apache.org/download/nb90/nb90.html y bajarnos el IDE.\nUna vez tengamos el IDE descargado, como es un ZIP, simplemente lo descomprimimos. En este ejemplo voy a suponer que lo instalamos en /nb (sí, ya se que no es lo normal, pero es para hacer mas fácil el tutorial).\nPara ejecutar NetBeans 9, deberemos ir al directorio bin y ejecutar el fichero netbeans.sh. Es decir en nuestro ejemplo deberemos ejecutar /nb/bin/netbeans.sh.\nUn momento, ¿ que versión de Java tenéis instalado en vuestro Ubuntu?.\nMe temo que NetBeans solo funciona con el Java de Oracle. OpenJDK no le gusta y no os arrancara, así que no os queda otra (que yo sepa) que iros a la pagina web de Oracle y bajaros su JDK. En este caso yo me he bajado JDK 10.0.2. Bajaros el tar.gz de este enlace y lo descomprimís en el directorio /nb (podríamos dejarlo en cualquier otro lugar pero es por facilitar el tutorial una vez mas). Así, ahora, tendréis el JDK en /nb/jdk-10.0.2/\nAhora hay que decirle a NetBeans que use el nuevo JDK que hemos instalado, para ello deberéis editar el fichero situado en /nb/etc/netbeans.conf y cambiar la linea netbeans_jdkhome  para que ponga esto:\nnetbeans_jdkhome=\"/nb/jdk-10.0.2/\" Ok. Ya podemos ejecutar Netbeans, con el comando /nb/bin/netbeans.sh\nLa primera vez que ejecutamos NetBeans 9, nos solicita que instalemos la librería nbjavac, para mejorar el editor de textos y la funcionalidad en general. Le hacemos caso y la instalamos.\nUna vez instalada, nos pedirá que reiniciemos el IDE. Somos buenos chicos y lo reiniciamos.\nAhora toca instalar el plugin para poder funcionar con Spring Boot. Para ello nos vamos al menú Tools y elegimos la opción plugins. En la ventana que nos sale nos iremos a la pestaña de \u0026#8220;Available Plugins\u0026#8221; y elegiremos NB SpringBoot. Después le daremos al botón Install.\n\u0026nbsp;\nReiniciamos, una vez más nuestro IDE, y ya podremos crear nuestro proyecto Spring Boot, en NetBeans 9. Como crearlo lo contare en la próxima entrada.\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/linux/",
	"title": "linux",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/25/jpa-hibernate-en-spring/",
	"title": "JPA + Hibernate en Spring",
	"tags": [],
	"description": "",
	"content": "En un entrada anterior, explique como crear nuestra conexión a la base de datos, usando JNDI. En esta entrada explicare como usar esa conexión con JPA.\nRecordar que el código fuente de de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat\nImportante recalcar que este ejemplo solo funciona con Java 1.8 o superior.\nLo primero explicar un poco de que va esto de JPA. JPA son las siglas de Java Persistence API. Es decir la API de persistencia en Java. Vale, que te has quedado como antes, ¿ no ? 😉 . Bueno, la idea es tener una metodología de tener objetos en nuestro entorno Java y que esos objetos sean un reflejo de las diferentes tablas de la base de datos, de tal manera que nosotros modifiquemos nuestros objetos y en la base de datos se vean reflejados esos cambios.\nLa idea parece interesante, ¿ verdad ?. Bueno, pues encima no es nada complicado el hacerlo.\nManos a la obra.\nLo primero vamos a crear el objeto que representa la tabla de nuestra base de datos. Así, en nuestra base de datos tenemos la tabla usuario que solo tiene dos campos, el login y el nombre del usuario. Ambos campos son cadenas de caracteres (String, vamos). En nuestra tabla usuario no puede haber dos login igual, es lo que se llama un indice unico o \u0026#8220;unique constraint\u0026#8221; que dicen los ingleses.\nDefinamos entonces nuestro objeto (usando la librería Lombok, de la que ya hablaba en otra entrada)\n@Data @Entity @Table(name = \u0026quot;usuario\u0026quot;, uniqueConstraints = { @UniqueConstraint(columnNames = {\u0026quot;login\u0026quot;})}) // Esto no es necesario en este ejemplo public class Usuario implements Serializable { @Id String login; @Column String nombre; public Usuario() {} public Usuario(String login, String nombre) { this.login = login; this.nombre = nombre; } }  Como se ve fácilmente, es una simple clase POJO, que implementa el interface Serializable. Solo tiene dos campos y unas cuantas anotaciones, que ahora explicare.\nLo primero es declarar la clase del tipo Entidad, para eso usaremos la anotación @Entity. Gracias a eso, JPA marcara esa clase para poder usarla en su entorno de persistencia.\nEl siguiente parámetro @Table indica a que tabla de nuestra base de datos, hace referencia esa clase, ademas de cual es su indice único . Si, como es el caso, el indice es simple y ademas la tabla se llama como nuestra clase no hace falta poner ese parámetro pero yo lo he puesto para que sepáis que exista ( y por manías 😉 )\nLuego, dentro de la clase veis que antes de la definición de la variable login tenemos la anotación @Id, eso indicara que ese es nuestro campo indice o único. Antes de la definición de la variable nombre tenemos la anotación @Column para indicar que es una columna más de nuestra tabla. Aclarar que todas esas anotaciones permiten más parámetros.\nHay muchísima documentación en la red, sobre JPA, podéis empezar, por ejemplo, por este PDF de la Universidad de Oviedo\nBien, una vez tenemos nuestra entidad vamos a trabajar con ella. Por hacerlo simple vamos a hacer uso Spring y de su interfaz CrudRepository. Este interfaz nos permite con apenas 3 lineas de código acceder a los datos que representa nuestro POJO.\nSi, aunque parezca increíble, con solo crear esta interface ya podremos acceder a nuestra base de datos.\npublic interface UsuarioRepositorio extends CrudRepository{ } Veis que he creado un interface, al que he llamado UsuarioRepositorio que extiende del interface CrudRepository y le he añadido el nombre de la clase Usuario, que es mi @Entity, y el tipo de campo (String) que es el indice único.\n¿ Ya esta ?. Pues sí, ya esta. Ya podéis acceder a vuestra base de datos. ¿ Qué como ?. Pues lógicamente usando las funciones que implementa el interfaz CrudRepository. Por ejemplo existe la función findById, si ejecutáis esa función pasándole el nombre del usuario os devolverá un objeto Optional\u0026lt;usuario \u0026gt; . Os lo explico mejor con un ejemplo.\nCreamos esta clase en nuestro proyecto.\npublic class buscaUsuario { @Autowired UsuarioRepositorio usuRep; public String getNombreUsuario(String loginUsuario) { Optional usu=usuRep.findById(loginUsuario); String usuario = (usu.isPresent() ? usu.get().getNombre() : \u0026quot;Usuario \u0026quot;+loginUsuario+\u0026quot; No encontrado\u0026quot;); } } }  Teniendo inyectada una referencia, con la anotación @Autowired, a nuestro interface UsuarioRepositorio (Spring hace la magia), en la función getNombreUsuario, invocamos a findById , la cual nos devuelve una clase tipo Optional. Este tipo de objeto es para poder encapsular un posible valor null de tal manera que siempre se devuelva algo, aun en el caso de que no se encuentre ningún valor. Para saber si se ha encontrado algo usaremos isPresent el cual nos devolverá true si ha encontrado algún registro.\nOs estaréis preguntando, como mínimo, dos cosas:\n \u0026#8211; ¿ Como hace esto Java, si realmente no hemos creado ninguna clase, solo un interfaz ?  2.- ¿ Qué pasa si yo quiero acceder a a campos que no son indices o varios campos simultáneamente ?\nLa respuesta a la primera pregunta, esta en la Programación Orientada a Objetos de Spring (echar un vistazo a JAspect). Gracias a esta tecnología, cuando Spring recorre nuestras clases (al desplegarse la aplicación en nuestro servidor de aplicaciones) y ve un interfaz que extiende de la clase CrudRepository (hay otras clases que mejoran esta, pero no hablare de ellas en este ejemplo) crea al vuelo una clase que implementa vuestro interfaz (en este caso UsuarioRepositorio) con sus correspondientes funciones. Por eso, en nuestras clases, podemos ejecutar algo que ni siquiera hemos creado.\nLa respuesta a la segunda pregunta es la anotación @Query. Gracias a ella en nuestro interfaz podemos crear nuevas funciones, que ejecuten las sentencias SQL que necesitemos.\nAsí si ponemos la siguiente función en nuestra clase UsuarioRepositorio\n@Query(\u0026quot;select u from Usuario u where u.nombre like :nombre order by u.nombre\u0026quot;) List\u0026lt;Usuario\u0026gt; buscaPorNombre(@Param(\u0026quot;nombre\u0026quot;) String nombre);  Podremos buscar todos los usuarios cuyo nombre contenga el String pasado a la función buscaPorNombre.\nObservar que la sentencia SQL no es una sentencia SQL estándar sino que hace uso de Java Persistence Query (JPQ) Este lenguaje es muy parecido a SQL pero tiene sus particularidades 😉\nPara facilitar más las cosas, Spring es capaz de interpretar, a través del nombre de la función lo que quieres hacer con esa función.\nAsí, en el ejemplo anterior, si a nuestra función le llamamos findIsLikeNombreOrderByNombre, haría lo mismo, pero no tendriamos que tener la anotación @Query. Spring la crea por nosotros, interpretando el nombre de la función.\nAsí nuestra clase quedaría así:\npublic interface UsuarioRepositorio extends CrudRepository\u0026lt;Usuario, String\u0026gt; { @Query(\u0026quot;select u from Usuario u where u.nombre like :nombre order by u.nombre\u0026quot;) List\u0026lt;Usuario\u0026gt;buscaPorNombre(@Param(\u0026quot;nombre\u0026quot;) String nombre); /** * Esta funcion hace exactamente lo mismo que la funcion buscaPorNombre pero utilizando DSL (Domain Specificic Lenguage) de Spring * @param nombre Nombre de usuario a buscar (sin wildcards, ya lo pone JPL) * @return Lista de Usuarios a buscar */ List\u0026lt;Usuario\u0026gt; findIsLikeNombreOrderByNombre(String nombre); }  Esto se hace gracias a la Spring y su Domain Specificic Lenguage (DSL). Tenéis una referencia de como formar Querys usando esta nomenclatura en esta página de Spring\nY nada más por hoy, solo recordaros que tenéis muchísima documentación sobre JPA y Spring en la web, os dejo un par de enlaces (en español) donde se habla más de ello:\n http://acodigo.blogspot.com/2017/03/spring-data-jpa-acceso-datos-simple-y.html https://www.adictosaltrabajo.com/tutoriales/spring-data-jpa/  Espero que os haya gustado la entrada.\nUn saludo\nEl profe.\n"
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/24/jpa-con-lombok/",
	"title": "JPA con Lombok, simplificando.",
	"tags": [],
	"description": "",
	"content": "En un entrada anterior, explique que para usar JPA hay que tener nuestros objetos POJO definidos . En esta entrada hablare de como mejorar la la definicion de nuestro objeto POJO, con la libreria Lombok.\nRecordar que el código fuente de de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat\nAnteriormente teniamos definido nuestro objeto de esta manera:\n@Entity @Table(name = \u0026quot;usuario\u0026quot;, uniqueConstraints = { @UniqueConstraint(columnNames = {\u0026quot;login\u0026quot;})}) public class Usuario implements Serializable { @Id String login; @Column String nombre; public Usuario() { } public String getLogin() { return login; } public void setLogin(String login) { this.login = login; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public Usuario(String login, String nombre) { this.login = login; this.nombre = nombre; } }``` Ahora amos a hacer la clase mas facil, gracias a la Lombok. Para ello, a mi proyecto Maven (en el fichero pom.xml) añado la siguiente dependencia:    org.projectlombok lombok 1.18.2 provided \n Teneis documentación de este proyecto en \u0026lt;a href=\u0026quot;https://projectlombok.org/\u0026quot; target=\u0026quot;_blank\u0026quot; rel=\u0026quot;noopener\u0026quot;\u0026gt;su pagina web\u0026lt;/a\u0026gt;. De momento baste decir que gracias a la anotacion @Data nuestra clase **usuario** se queda así.  import lombok.Data;\n@Data @Entity @Table(name = \u0026ldquo;usuario\u0026rdquo;, uniqueConstraints = { @UniqueConstraint(columnNames = {\u0026ldquo;login\u0026rdquo;})}) public class Usuario implements Serializable {\n@Id String login; @Column String nombre;  public Usuario(String login, String nombre) { this.login = login; this.nombre = nombre; } } ```\nMucho mas limpia, ¿ a que si ?. Lombok se encargara de crear el constructor vacio, los setters y getters gracias la anotacion @Data.\nGracias a Lombok, a la hora de compilar Java crea funciones al vuelo, para que nosotros no tengamos que teclear tanto y no nos cansemos 😉\nEn esta página (una vez más en un perfecto ingles) teneis las diferentes anotaciones que proporciona la libreria Lombok\n\u0026nbsp;\n\u0026nbsp;\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/sin-categor%C3%ADa/",
	"title": "Sin categoría",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/23/usando-lambdas/",
	"title": "Usando Lambdas",
	"tags": ["java", "lambda"],
	"description": "",
	"content": "En esta breve entrada explicare como mejorar el ejemplo anterior, con el uso de lambdas.\nComo siempre el código fuente de este ejemplo lo tenéis en: https://github.com/chuchip/jdbc_jpa_tomcat\nLas lambdas, son un mecanismo introducido en Java 8, pero que realmente en el mundo de la programación no es nuevo.\nGracias a las lambdas se puede entre otras cosas, evitar, en gran medida el uso de las clases auxiliares. Tenéis muchos manuales en la web, solo preguntarle a google, que lo sabe \u0026#8216;casi\u0026#8217; todo ;-), pero os aconsejo que le echéis un vistazo al siguiente enlace:\nhttps://www.oracle.com/technetwork/es/articles/java/expresiones-lambda-api-stream-java-2633852-esa.html\nYo, lo que os voy a dar un ejemplo de como usar lambda, para mejorar el uso de Swing Data JDBC. ¡¡Vamos a ello!!.\nEn nuestra clase anterior teníamos el siguiente código:\npublic class JdbcEjemplo { ..... public List\u0026amp;lt;Usuario\u0026amp;gt; findAllUsernames() { return jdbc.queryForObject( \u0026quot;select login,nombre from usuario \u0026quot;, new usuarioListaRowMapper() ); } private class usuarioListaRowMapper implements RowMapper\u0026amp;lt;List\u0026amp;lt;Usuario\u0026amp;gt;\u0026amp;gt; { @Override public List\u0026amp;lt;Usuario\u0026amp;gt; mapRow(ResultSet rs, int rowNum) throws SQLException { ArrayList\u0026amp;lt;Usuario\u0026amp;gt; listaUsuarios = new ArrayList(); do { listaUsuarios.add(new Usuario(rs.getString(\u0026quot;login\u0026quot;), rs.getString(\u0026quot;nombre\u0026quot;))); } while (rs.next()); return listaUsuarios; } } }  Ahora vamos a ver como usar una expresion lambda de tal manera que no tengamos que crear la clase usuarioListaRowMapper y, ademas nuestro código quede mucho mas limpio.\npublic List\u0026amp;lt;Usuario\u0026amp;gt; findAllUsernames() { return jdbc.query( \u0026quot;select login,nombre from usuario \u0026quot;, (rs, rowNum) -\u0026amp;gt; new Usuario(rs.getString(\u0026quot;login\u0026quot;),rs.getString(\u0026quot;nombre\u0026quot;)) ); }  ¿ Sorprendido ?. Sí, gracias al uso de expresiones lambda hemos dejado nuestro código anterior en solo esas lineas. Y por supuesto no es necesario tener la clase usuarioListaRowMapper \nLo que hemos hecho es cambiar la llamada a la función queryForObject por la llamada a la función query que esta definida de tal manera\n\u0026lt;T\u0026gt; List\u0026lt;T\u0026gt; query(String sql, RowMapper\u0026lt;T\u0026gt; rowMapper) throws DataAccessException;  Es decir espera una sentencia SQL y un clase que implemente la interfaz funcional RowMapper (que es una interfaz funcional esta explicado en la página anteriormente referenciada)\nPues bien, hemos creado esa clase a través de la expresión lambda, y nos hemos ahorrado un montón de código y dejado todo mucho más limpio.\nChicos, aprender a usar expresiones lambda. ¡¡ Mejoraran vuestro código !!\n"
},
{
	"uri": "http://ww2.profesor-p.com/tags/lambda/",
	"title": "lambda",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/22/acceso-a-base-de-datos-con-jdbc-spring/",
	"title": "Acceso a Base de Datos con  Spring Data JDBC",
	"tags": ["java", "jdbc", "spring"],
	"description": "",
	"content": " En el anterior articulo explicaba como crear la conexion a la base de datos en un servidor de aplicaciones Tomcat . En este articulo explicare como acceder a esos datos a traves del paquete JDBC de Spring Data JDBC\nEl código fuente de este ejemplo esta en: https://github.com/chuchip/jdbc_jpa_tomcat\nCreando nuestro POJO y Repositorio Ahora que ya tenemos nuestro acceso a la base de datos configurado y disponible, vamos a utilizarlo (por eso de que no se aburra 😉 )\nLo primero definimos nuestro POJO. Ya sabeis Plain Object Java Object, es decir Objeto Plano de Java, o en otras palabras ‘Clase Tonta donde almacenar y que no tiene nada o muy poco de lógica),\nEste POJO que hará referencia a la tabla usuario, sera tal que así:\n@Entity @Table(name = \u0026quot;usuario\u0026quot;, uniqueConstraints = { @UniqueConstraint(columnNames = {\u0026quot;login\u0026quot;})}) public class Usuario implements Serializable { @Id String login; @Column String nombre; public Usuario() { } public String getLogin() { return login; } public void setLogin(String login) { this.login = login; } public String getNombre() { return nombre; } public void setNombre(String nombre) { this.nombre = nombre; } public Usuario(String login, String nombre) { this.login = login; this.nombre = nombre; } }  Creo que esto no hará falta explicarlo mucho. Si no entendéis lo que es una @Entitty y tal os recomiendo que leáis los siguientes manuales:\nhttps://www.arquitecturajava.com/ejemplo-de-jpa/\nhttps://www.oscarblancarteblog.com/2016/10/27/declarar-entidades-entity/\nUna vez que ya tenemos una clase (una @Entity) donde almacenar los registros de nuestra tabla usuario, vamos a ver como trabajar usando el paquete JDBC de Spring. Para ser mas exactos, utilizando JDBC Templates de Spring.\nEn la clase JdbcEjemplo tenemos lo siguiente:\n@Repository public class JdbcEjemplo { @Autowired private JdbcOperations jdbc; @Bean public JdbcTemplate jdbcTemplate(DataSource dataSource) { return new JdbcTemplate(dataSource); } public Usuario findByUsername(String username) { return jdbc.queryForObject( \u0026quot;select login,nombre from usuario where login=?\u0026quot;, new usuarioRowMapper(), username); } public List\u0026lt;Usuario\u0026gt; findAllUsernames() { return jdbc.queryForObject( \u0026quot;select login,nombre from usuario \u0026quot;, new usuarioListaRowMapper() ); } private class usuarioRowMapper implements RowMapper\u0026lt;Usuario\u0026gt; { @Override public Usuario mapRow(ResultSet rs, int rowNum) throws SQLException { return new Usuario( rs.getString(\u0026quot;login\u0026quot;), rs.getString(\u0026quot;nombre\u0026quot;)); } } private class usuarioListaRowMapper implements RowMapper\u0026lt;List\u0026lt;Usuario\u0026gt;\u0026gt; { @Override public List\u0026lt;Usuario\u0026gt; mapRow(ResultSet rs, int rowNum) throws SQLException { ArrayList\u0026lt;Usuario\u0026gt; listaUsuarios = new ArrayList(); do { listaUsuarios.add(new Usuario(rs.getString(\u0026quot;login\u0026quot;), rs.getString(\u0026quot;nombre\u0026quot;))); } while (rs.next()); return listaUsuarios; } } }  Explico la clase, poco a poco. Lo primero es marcarla como repositorio, eso se hace con la anotación @Repository. Con esto conseguiremos que Spring cargue la clase y este disponible para otras clases a través del sistema de inyección de dependencias (realmente para nuestro ejemplo nos habría valido con marcarla como @Component)\nCreamos la función jdbcTemplate(DataSource dataSource) , la cual nos devolverá un nuevo JdbcTemplate con el datasource que Spring ya tiene definido en su contexto. Como se puede ver, la función esta marcada con @Bean, para que la variable jdbc, que tenemos al principio de la clase, la llame y pueda asignarle un valor. JdbcOperations es el interface que usan las clases del paquete JDBC de Spring. La clase JdbcTemplate, por supuesto, lo implementa.\nNosotros usaremos la función findByUserName , para buscar el nombre del usuario (como nos gusta el ingles, madre mía 😉 ). Y esta función lo único que hará sera usando la variable global jdbc, invocando el método queryForObject. Este método usa los siguientes parámetros:\n La sentencia SQL a ejecutar, teniendo en cuenta que los parámetros a sustituir deben ser puestas con un ? , como si fuera un PreparedStatement, vamos.\n El objeto donde se van a guardar los resultados. Este objeto debe implementar el interface RowMapper. En nuestro ejemplo creamos la clase usuarioRowMapper donde definimos la función mapRow(ResultSet rs, int rowNum) la cual sera llamada por la función queryForObject, de tal manera que devuelva un objeto Usuario.\n Las variables a sustituir en la sentencia SQL. Tendra que haber tantas variables como ? hemos puesto en nuestra sentencia SQL.\n  El caso es que cuando llamemos la función findByUserName nos devolverá una clase tipo Usuario o null si no encuentra nada.\nEn la siguiente función, llamada findAllUsernames buscaremos todos los usuarios que haya en la base de datos, por lo cual necesesitamos que devolver una lista de usuarios, es decir una List. Como se ve la llamada es casi igual que la de findByUserName , con la diferencia de que el RowMapper a devolver es usuarioListaRowMapper que como se ve en su función mapRow devuelve un objeto List que contiene Usuarios, es decir List.\nObsérvese lo cómodo que es usar Templates JDBC. No tenemos que abrir Conexiones ni crear Statements ni nada, Spring lo hace todo por debajo. Simplemente ponemos la sentencia SQL y recibimos un objeto que contiene los resultados.\nEn el proximo articulo explicare como realizar busquedas en la base de datos a traves de JPA e Hibernate.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/sin-categoria/",
	"title": "Sin categoria",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/2018/08/21/conectando-con-postgresql-usando-jndi-y-spring-en-tomcat-parte-1/",
	"title": "Conectando a una base de datos usando JNDI y Spring en Tomcat",
	"tags": ["hibernate", "java", "jndi", "jpa", "spring", "tomcat"],
	"description": "",
	"content": "En este ejemplo veremos como conecta a Postgresql usando JPA + Hibernate y Spring JDBC. Para ello uso como servidor de aplicaciones Tomcat. La configuración esta realizada con anotaciones y XML y utilizo el pool de conexiones de Tomcat recogido a través de JNDI, para que la aplicación no deba saber realmente ni donde se conecta.\nEl código fuente lo teneis en: https://github.com/chuchip/jdbc_jpa_tomcat\nEn este enlace teneis este mismo documento (todas las partes) pero en PDF.\nEl ejemplo usa Maven y explicare como deberá estar configurado Tomcat para que la aplicación funcione correctamente.\n2. Configuración de Postgresql Esta sera la única tabla a la que accederemos a través de Postgresql:\ncreate table usuario ( login varchar(15) not null, nombre varchar(100) not null, constraint ix_usuario primary key (login) ); insert into usuario values('cpuente','El profe'); insert into usuario values('chuchi','El nombre del profe');  3. Configuración de Tomcat La configuración de Tomcat deberá tener las siguientes características:\nEn server.xml (estara en $TOMCAT_HOME/conf) deberemos añadir dentro de  las siguientes lineas:\n\u0026lt;GlobalNamingResources\u0026gt; ….. \u0026lt;Resource name=\"jdbc/anjelica\" auth=\"Container\" type=\"javax.sql.DataSource\" driverClassName=\"org.postgresql.Driver\" url=\"jdbc:postgresql://localhost:5432/MIBASEDATOS\" username=\"USUARIO\" password=\"CONTRASEÑA\" maxTotal=\"20\" maxIdle=\"10\" maxWaitMillis=\"-1\"/\u0026gt; ….. \u0026lt;/GlobalNamingResources\u0026gt; Esto se utilizara para configurar nuestra fuente JNDI que permitirá conectarnos con la base de datos. Para probar esta aplicación cambiar los valores de url para que apunten a vuestra base de datos, asi como el username y la password.\nTambién sera necesario añadir las siguientes lineas al fichero context.xml dentro de  __de tomcat, que también estará en $TOMCAT_HOME/conf\n\u0026lt;Context\u0026gt; …. \u0026lt;ResourceLink name=\"jdbc/anjelica\" global=\"jdbc/anjelica\" type=\"javax.sql.DataSource\"/\u0026gt; …. \u0026lt;/Context\u0026gt; Con estos dos ficheros ya tendremos nuestro tomcat configurado para que use su propio pool de conexiones al que hemos llamado “jdbc/anjelica”.\nAhora debemos añadir a Tomcat la libreríapara conectarnos a postgresql, en este caso usamos la versión 42.2.2\n\u0026#8211; postgresql-42.2.2.jar\n4. Configuración de la aplicación. En esta aplicación usaremos tanto ficheros xml como configuración en Java.\nLo primero es configurar nuestro ficheros xml para que Tomcat use Spring, para ello en el directorio src\\main\\webapp\\WEB-INF de nuestra aplicación tenderemos estos ficheros.\n applicationContext.xml dispatcher-servlet.xml web.xml  4.1 web.xml El único fichero que usa Tomcat es web.xml, y este, a su vez, usa los dos anteriores, de tal manera que básicamente en web.xml , lo primero que hacemos es especificar que use el servlet de Spring y le decimos donde tendrá la configuración para ese servlet. Esto se hace con estas lineas:\n\u0026lt;servlet\u0026gt; \u0026lt;servlet-name\u0026gt;dispatcher\u0026lt;/servlet-name\u0026gt; \u0026lt;servlet-class\u0026gt; org.springframework.web.servlet.DispatcherServlet \u0026lt;/servlet-class\u0026gt; \u0026lt;init-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;/WEB-INF/dispatcher-servlet.xml\u0026lt;/param-value\u0026gt; \u0026lt;/init-param\u0026gt; \u0026lt;load-on-startup\u0026gt;1\u0026lt;/load-on-startup\u0026gt; \u0026lt;/servlet\u0026gt; A continuación configuramos el contexto con las siguientes lineas:\n\u0026lt;context-param\u0026gt; \u0026lt;param-name\u0026gt;contextConfigLocation\u0026lt;/param-name\u0026gt; \u0026lt;param-value\u0026gt;/WEB-INF/applicationContext.xml\u0026lt;/param-value\u0026gt; \u0026lt;/context-param\u0026gt; \u0026lt;listener\u0026gt; \u0026lt;listener-class\u0026gt;org.springframework.web.context.ContextLoaderListener\u0026lt;/listener-class\u0026gt; \u0026lt;/listener\u0026gt; 4.2 dispatcher-servlet.xml Para configurar la parte Web de nuestra aplicación (el servlet realmente) pondremos las siguientes lineas en el fichero dispatcher-servlet.xml\n\u0026lt;annotation-driven /\u0026gt; \u0026lt;context:component-scan base-package=\"chu.jdbc\" /\u0026gt; \u0026lt;beans:bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"\u0026gt; \u0026lt;beans:property name=\"prefix\" value=\"/WEB-INF/views/\" /\u0026gt; \u0026lt;beans:property name=\"suffix\" value=\".jsp\" /\u0026gt; \u0026lt;/beans:bean\u0026gt; Con  permitiremos que en nuestra aplicación haya anotaciones @Controller y @RequestMapping\nCon  especificaremos que paquete deberá escanear Spring para buscar anotaciones en los ficheros java. En este caso especificamos que busque en el paquete “chu.jdbc” y sus hijos.\nLas ultimas lineas indican que usaremos JSP y especifica donde tendremos nuestros ficheros jsp.\nTenéis un excelente documento explicando como hacer esta misma configuración usando anotaciones java en la siguiente página: https://www.baeldung.com/bootstraping-a-web-application-with-spring-and-java-based-configuration\n4.3applicationContext.xml En este fichero crearemos nuestro DataSource que utilizaremos para conectarnos con el pool de conexiones anteriormente configurado en Tomcat.\nEsto se hace añadiendo la siguiente linea:\n\u0026lt;jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/anjelica\" resource-ref=\"true\"/\u0026gt; Tenéis más documentación de lo que hace esta linea en http://www.jtech.ua.es/j2ee/publico/spring-2012-13/sesion01-apuntes.html\nDe todos modos básicamente lo que hace es injectar en nuestra aplicación una clase DataSource que luego podremos usar con sentencias como esta:\n@Autowired DataSource ds; 5. La aplicación 5.1 Configuracion JPA y JDBC En la clase JpaConfig es donde se hace toda la configuración que necesitamos para conectarnos a la base de datos.\nPara ello, lo primero especificamos las siguientes configuraciones java\n@Configuration @EnableLoadTimeWeaving @EnableJpaRepositories(\"chu.jdbc\") Explico las directivas, una a una.\n @Configuration Especifica que es una clase de configuración, con ello haremos que Spring la cargue y ejecute.\n @EnableLoadTimeWeaving Con esto permitimos a tomcat usar AOP. Si no la ponemos simplemente Tomcat no podrá hacer uso de Programación Orienta a a Aspectos (AOP) y la aplicación no funcionara. Mas documentación en: https://docs.spring.io/spring/docs/5.0.8.RELEASE/spring-framework-reference/core.html#aop-aj-ltw-environment-tomcat\n @EnableJpaRepositories(\u0026#8220;chu.jdbc\u0026#8221;) especificamos que busque repositorios (clases marcadas con la directiva @Repository) en el paquete chu.jdbc\n  Ahora inyectamos el Datasource que ya tendremos disponible por la configuración aplicada anteriormente en nuestro fichero applicationContext.xml\n@Autowired DataSource ds; Lo siguiente es crear nuestro fabrica de controladores de entidades (bueno, en ingles, nuestro EntityManagerFactoryBean), para ello y como usamos una versión de Hibernate superior a la 4 (con versiones anteriores utilizaríamos otra clase), ponemos el siguiente código:\n@Bean public LocalContainerEntityManagerFactoryBean entityManagerFactory() { LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean(); em.setDataSource(ds); em.setPackagesToScan(new String[] { \"chu.jdbc\" }); JpaVendorAdapter vendorAdapter = new HibernateJpaVendorAdapter(); em.setJpaVendorAdapter(vendorAdapter); return em; } Como se puede ver simplemente creamos nuestro LocalContainerEntityManagerFactoryBean , le añadimos nuestro DataSource y el adaptador de Hibernate. También le decimos los paquetes que deberá escanear para buscar “Entity Classes” (clases que sean entidades, vamos).\nPor ultimo creamos nuestro controlador de transaciones con el siguiente código:\n@Bean public PlatformTransactionManager transactionManager( EntityManagerFactory emf){ JpaTransactionManager transactionManager = new JpaTransactionManager(); transactionManager.setEntityManagerFactory(emf); return transactionManager; } Ahora ya solo falta crear nuestro ficherito hibernate.cfg.xml en nuestro directorio de resources, pero en el solamente tenemos lo siguiente:\n\u0026lt;?xml version=\"1.0\" encoding=\"UTF-8\"?\u0026gt; \u0026lt;!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://hibernate.org/dtd/hibernate-configuration-3.0.dtd\"\u0026gt; \u0026lt;hibernate-configuration\u0026gt; \u0026lt;session-factory\u0026gt; \u0026lt;property name=\"hibernate.dialect\"\u0026gt;org.hibernate.dialect.PostgreSQLDialect\u0026lt;/property\u0026gt; \u0026lt;/session-factory\u0026gt; \u0026lt;/hibernate-configuration\u0026gt; Es decir, simplemente definimos que vamos a usar una base de datos Postgresql. Este fichero debe existir. Cosas de Hibernate que hay que complacer.\nY voila nuestro entorno para JPA + Hibernate ya esta configurado y listo para funcionar.\nEn la siguiente parte explicare como crear un respositorio y la magia que hay detras.\n¡¡ Hasta la proxima, chabales!!\n"
},
{
	"uri": "http://ww2.profesor-p.com/contacto/experiencia_basesdatos/",
	"title": "Bases de Datos",
	"tags": ["experiencia"],
	"description": "",
	"content": "Experiencia como administrador de Base de Datos:\n Informix \u0026#8211; 10 años Oracle \u0026#8211; 1 año Postgresql \u0026#8211; 2 años MYSQL \u0026#8211; 6 Meses SQL SERVER \u0026#8211; 3 Meses  "
},
{
	"uri": "http://ww2.profesor-p.com/contacto/experiencia_lenguajesprogramacion/",
	"title": "Lenguajes  de programación",
	"tags": ["experiencia"],
	"description": "",
	"content": " JAVA - 15 Años experiencia. Trabajando en entornos: SWING, SPRING y J2EE Informix 4GL \u0026#8211; 4 años experiencia. Ensamblador \u0026#8211; 4 años experiencia. C - 2 Años experiencia. PHP \u0026#8211; 6 Meses experiencia. PERL \u0026#8211; 6 Meses experiencia. PHP \u0026#8211; 6 Meses experiencia. KOTLIN \u0026#8211; 6 Meses experiencia. Android \u0026#8211; 6 Meses experiencia. Angular \u0026#8211; 9 Meses experiencia    "
},
{
	"uri": "http://ww2.profesor-p.com/contacto/experiencia_sistemas/",
	"title": "Sistemas",
	"tags": ["experiencia"],
	"description": "",
	"content": "Experiencia como administrador sistemas\n HPUX \u0026#8211; 6 Años Linux \u0026#8211; 10 años  Centos, Debian, Ubuntu.  Windows \u0026#8211; 1 año VMWARE \u0026#8211; 4 años CITRIX \u0026#8211; 1 Año  "
},
{
	"uri": "http://ww2.profesor-p.com/last/",
	"title": "Ultimas entradas",
	"tags": [],
	"description": "",
	"content": "Aquí tienes un listdo de las últimas entradas.\n Trabajando con la clase RestTemplate  Utiliza la clase RestTemplate para realizar peticiones HTTP fácilmente, produciéndose la serialización y deserialización de los objetos de una manera transparente.\n Estableciendo Filtros en Spring  Implementa filtros en Spring.Un filtro se puede establecer para controlar acciones a realizar cuando se recibe una petición HTTP.\n Cacheando resultados con Spring Boot  Aprende a utilizar cache en Spring para acelerar tus aplicaciones.\n Beans avanzados en Spring  Aprende como cargar Beans dinámicamente desde Spring.\n Optimizando relaciones entre entidades en Hibernate  Explicare como optimizar las consultas a la base de datos usando JPA. Se verán diferentes tipos de consultas, explicando como realizar uniones entre tablas de modo perezoso (lazy) o agresivo (eager).\n Accediendo facilmente a los datos con Spring Rest Data  Spring Boot ofrece un fantástico soporte para acceder a los datos con JPA a través de sus interfaces, del tipo Repository. Si a esto le añadimos la facilidad con que se crean servicios REST, podremos hacer una aplicación ofreciendo una API para acceder a nuestra base de datos preferida facilmente.\n"
},
{
	"uri": "http://ww2.profesor-p.com/categories/experiencia/",
	"title": "experiencia",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "http://ww2.profesor-p.com/tags/experiencia/",
	"title": "experiencia",
	"tags": [],
	"description": "",
	"content": ""
}]